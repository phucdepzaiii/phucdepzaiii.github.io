<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PH√öC ƒê·∫∏P TRAI- ƒê√ÅNH ƒê√ÇU TH·∫ÆNG ƒê√ì, MAY M·∫ÆN PH√ÅT T√ÄI.</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
            position: relative;
            overflow-x: hidden; /* Prevent horizontal scroll from decor */
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(255, 215, 0, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(240, 84, 84, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(52, 152, 219, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 1;
        }

        .background-decor .han-char {
            position: fixed;
            font-size: 20vw;
            font-weight: bold;
            color: rgba(255, 215, 0, 0.04);
            z-index: 1;
            pointer-events: none;
            text-shadow: 0 0 40px rgba(255, 215, 0, 0.1);
            animation: floatChar 30s infinite linear alternate;
        }

        .background-decor .han-char:nth-child(1) {
            top: 5%;
            left: -5%;
        }

        .background-decor .han-char:nth-child(2) {
            bottom: 5%;
            right: -5%;
            animation-delay: -15s;
        }

        @keyframes floatChar {
            0% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-30px) rotate(5deg); }
            100% { transform: translateY(0px) rotate(0deg); }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 2;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            font-size: 2.8em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #ffd700 0%, #f05454 25%, #667eea 50%, #4fd1c5 75%, #ffd700 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            animation: goldText 3s ease-in-out infinite;
        }

        @keyframes goldText {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        .disclaimer {
            color: #ffd700;
            font-size: 1.2em;
            padding: 12px 30px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 193, 7, 0.2));
            border-radius: 30px;
            border: 2px solid #ffd700;
            display: inline-block;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: goldShine 3s ease-in-out infinite;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        @keyframes goldShine {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }
            50% { transform: scale(1.05); box-shadow: 0 0 30px rgba(255, 215, 0, 0.5); }
        }
        
        .lucky-phrases {
            margin-top: 25px;
            display: flex;
            justify-content: center;
            gap: 40px;
            flex-wrap: wrap;
        }

        .lucky-text {
            font-size: 1.3em;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: neonFlicker 5s infinite alternate;
        }

        .lucky-text-1 {
            color: #ffd700;
            text-shadow: 0 0 5px #ffd700, 0 0 10px #ffd700, 0 0 20px #ffd700, 0 0 30px #e74c3c;
        }

        .lucky-text-2 {
            color: #4fd1c5;
            text-shadow: 0 0 5px #4fd1c5, 0 0 10px #4fd1c5, 0 0 20px #4fd1c5, 0 0 30px #3498db;
            animation-delay: -2.5s;
        }

        @keyframes neonFlicker {
            0%, 100% { opacity: 1; filter: brightness(1.1); }
            50% { opacity: 0.8; filter: brightness(1); }
        }

        .session-management {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 20px 25px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 15px;
        }
        .session-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        #sessionSelector {
            background: #1e2a4a;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 1em;
        }
        #currentSessionDisplay {
            font-size: 1.1em;
            font-weight: bold;
            color: #ffd700;
        }

        .big-road-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        .big-road-grid {
            display: grid;
            grid-template-rows: repeat(6, 40px);
            grid-auto-flow: column;
            grid-auto-columns: 40px;
            gap: 2px;
            overflow-x: auto;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            min-height: 262px;
        }
        .road-cell {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
            font-weight: bold;
        }
        .road-cell .marker {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        .road-cell .player { border: 3px solid #3498db; color: #3498db; }
        .road-cell .banker { border: 3px solid #e74c3c; color: #e74c3c; }
        .road-cell .tie-line {
            position: absolute;
            top: 50%;
            left: -5px;
            width: 44px;
            height: 3px;
            background-color: #2ecc71;
            transform: rotate(45deg);
        }
        
        .accuracy-section {
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.1), rgba(39, 174, 96, 0.1));
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            border: 2px solid rgba(46, 204, 113, 0.3);
            position: relative;
            overflow: hidden;
        }
        .accuracy-section::before {
            content: 'üìä';
            position: absolute;
            top: -20px;
            right: 20px;
            font-size: 80px;
            opacity: 0.1;
        }
        .accuracy-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .accuracy-title {
            font-size: 1.5em;
            color: #2ecc71;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .accuracy-reset {
            padding: 8px 15px;
            background: rgba(231, 76, 60, 0.2);
            border: 2px solid #e74c3c;
            color: #ff6b6b;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s;
        }
        .accuracy-reset:hover { background: rgba(231, 76, 60, 0.3); transform: scale(1.05); }
        .accuracy-main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .accuracy-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.3s;
        }
        .accuracy-card:hover { transform: translateY(-3px); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); }
        .accuracy-label {
            font-size: 0.9em;
            color: #aaa;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .accuracy-value { font-size: 2.2em; font-weight: bold; margin-bottom: 5px; }
        .accuracy-value.excellent { color: #2ecc71; }
        .accuracy-value.good { color: #3498db; }
        .accuracy-value.average { color: #f39c12; }
        .accuracy-value.poor { color: #e74c3c; }
        .accuracy-change { font-size: 0.85em; color: #999; }
        .accuracy-change.positive { color: #2ecc71; }
        .accuracy-change.negative { color: #e74c3c; }
        .accuracy-details { background: rgba(0, 0, 0, 0.3); border-radius: 15px; padding: 20px; margin-top: 20px; }
        .accuracy-breakdown { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 20px; }
        .breakdown-item { text-align: center; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.1); }
        .breakdown-type { font-size: 1.2em; font-weight: bold; margin-bottom: 5px; }
        .breakdown-type.player { color: #3498db; }
        .breakdown-type.banker { color: #e74c3c; }
        .breakdown-type.tie { color: #27ae60; }
        .breakdown-stats { display: flex; justify-content: space-around; margin-top: 10px; font-size: 0.9em; }
        .stat-item { display: flex; flex-direction: column; }
        .stat-label { color: #888; font-size: 0.85em; }
        .stat-value { font-weight: bold; color: #fff; }
        .accuracy-chart { background: rgba(255, 255, 255, 0.05); border-radius: 10px; padding: 15px; margin-top: 15px; height: 250px; position: relative; overflow-x: auto; overflow-y: hidden; }
        .chart-bars { display: flex; align-items: flex-end; height: 180px; gap: 4px; padding: 10px; min-width: 100%; }
        .chart-bar { flex: 0 0 25px; border-radius: 5px 5px 0 0; transition: all 0.3s; position: relative; }
        .chart-bar.bar-correct { background: linear-gradient(180deg, #3498db, #2980b9); }
        .chart-bar.bar-incorrect { background: linear-gradient(180deg, #e74c3c, #c0392b); }
        .chart-bar:hover { opacity: 0.8; }
        .chart-bar-label { position: absolute; bottom: -25px; left: 50%; transform: translateX(-50%); font-size: 0.65em; color: #888; white-space: nowrap; }
        .chart-bar-value { position: absolute; top: -25px; left: 50%; transform: translateX(-50%); font-size: 0.75em; color: #fff; font-weight: bold; }
        .streak-sequence { display: flex; flex-wrap: wrap; gap: 8px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; min-height: 30px; align-items: center; }
        .streak-number { font-size: 1.2em; font-weight: bold; }
        .streak-number.correct { color: #3498db; }
        .streak-number.incorrect { color: #e74c3c; }
        .streak-prediction-result { padding: 15px 25px; border-radius: 15px; font-size: 2em; font-weight: bold; display: inline-block; min-width: 250px; border: 2px solid transparent; transition: all 0.3s ease; }
        .streak-prediction-result.correct { background: rgba(52, 152, 219, 0.2); color: #3498db; border-color: #3498db; text-shadow: 0 0 10px #3498db; }
        .streak-prediction-result.incorrect { background: rgba(231, 76, 60, 0.2); color: #e74c3c; border-color: #e74c3c; text-shadow: 0 0 10px #e74c3c; }
        .streak-prediction-result.none { background: rgba(255, 255, 255, 0.1); color: #aaa; font-size: 1.5em; }
        .streak-prediction-reason { margin-top: 8px; font-size: 0.9em; color: #999; font-style: italic; }
        .stats-chart-container { display: flex; gap: 15px; justify-content: center; align-items: center; background: rgba(0,0,0,0.2); padding: 15px; border-radius: 10px; }
        .stats-chart-bar-wrapper { display: flex; flex-direction: column; align-items: center; width: 100px; }
        .stats-chart-bar { width: 50px; height: 100px; background-color: rgba(255,255,255,0.05); border-radius: 5px; display: flex; align-items: flex-end; }
        .stats-chart-fill { width: 100%; border-radius: 5px; transition: height 0.5s ease; }
        .stats-chart-fill.correct { background: linear-gradient(180deg, #3498db, #2980b9); }
        .stats-chart-fill.incorrect { background: linear-gradient(180deg, #e74c3c, #c0392b); }
        .stats-chart-label { margin-top: 8px; font-size: 0.9em; font-weight: bold; }
        .stats-chart-value { font-size: 0.8em; color: #aaa; }
        .accuracy-history { margin-top: 20px; max-height: 400px; overflow-y: auto; background: rgba(0, 0, 0, 0.2); border-radius: 10px; padding: 15px; }
        .history-entry { display: flex; justify-content: space-between; align-items: center; padding: 8px; margin-bottom: 5px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; font-size: 0.9em; }
        .history-entry.correct { border-left: 3px solid #3498db; }
        .history-entry.incorrect { border-left: 3px solid #e74c3c; }
        .entry-number { color: #888; margin-right: 10px; min-width: 40px; }
        .entry-prediction { flex: 1; }
        .entry-actual { flex: 1; }
        .entry-result { padding: 2px 8px; border-radius: 5px; font-size: 0.85em; font-weight: bold; }
        .entry-result.correct { background: rgba(52, 152, 219, 0.2); color: #3498db; }
        .entry-result.incorrect { background: rgba(231, 76, 60, 0.2); color: #e74c3c; }
        .warning-system { background: linear-gradient(135deg, rgba(231, 76, 60, 0.2), rgba(192, 57, 43, 0.2)); border: 2px solid #e74c3c; border-radius: 15px; padding: 20px; margin-bottom: 25px; display: none; animation: warningPulse 2s infinite; }
        .warning-system.active { display: block; }
        @keyframes warningPulse { 0%, 100% { box-shadow: 0 0 20px rgba(231, 76, 60, 0.5); } 50% { box-shadow: 0 0 40px rgba(231, 76, 60, 0.8); } }
        .warning-title { font-size: 1.3em; font-weight: bold; color: #ff6b6b; margin-bottom: 10px; display: flex; align-items: center; gap: 10px; }
        .warning-icon { font-size: 1.5em; animation: blink 1s infinite; }
        @keyframes blink { 0%, 50%, 100% { opacity: 1; } 25%, 75% { opacity: 0.3; } }
        .warning-list { list-style: none; padding-left: 20px; }
        .warning-list li { margin: 8px 0; color: #ffcccc; }
        .pattern-recognition { background: rgba(255, 255, 255, 0.08); backdrop-filter: blur(20px); border-radius: 20px; padding: 25px; margin-bottom: 25px; border: 1px solid rgba(255, 255, 255, 0.15); }
        .pattern-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px; }
        .pattern-card { background: rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 15px; border: 1px solid rgba(255, 255, 255, 0.1); transition: all 0.3s; }
        .pattern-card:hover { transform: translateY(-3px); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); }
        .pattern-card.detected { background: linear-gradient(135deg, rgba(79, 209, 197, 0.2), rgba(52, 152, 219, 0.2)); border-color: #4fd1c5; animation: patternGlow 2s infinite; }
        @keyframes patternGlow { 0%, 100% { box-shadow: 0 0 10px rgba(79, 209, 197, 0.3); } 50% { box-shadow: 0 0 20px rgba(79, 209, 197, 0.6); } }
        .pattern-name { font-weight: bold; color: #4fd1c5; margin-bottom: 5px; }
        .pattern-confidence { font-size: 0.9em; color: #aaa; }
        .pattern-description { font-size: 0.85em; color: #999; margin-top: 5px; }
        
        /* ===== NEW: CROSS-SESSION SHAPE ANALYSIS STYLES ===== */
        .cross-session-analysis {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        .analysis-summary { text-align: center; margin-bottom: 20px; }
        .summary-text { font-size: 1.2em; color: #fff; }
        .summary-text .highlight { color: #ffd700; font-weight: bold; }
        .summary-recommendation { font-size: 2.5em; font-weight: bold; margin-top: 10px; padding: 10px 20px; display: inline-block; border-radius: 15px; text-transform: uppercase; }
        .summary-recommendation.break { color: #3498db; background: rgba(52, 152, 219, 0.1); border: 2px solid #3498db;}
        .summary-recommendation.follow { color: #e74c3c; background: rgba(231, 76, 60, 0.1); border: 2px solid #e74c3c;}
        .matched-sessions-list { max-height: 400px; overflow-y: auto; padding-right: 10px; }
        .matched-session-card { background: rgba(0,0,0,0.3); border-radius: 15px; padding: 15px; margin-bottom: 15px; border-left: 4px solid #9b59b6; }
        .matched-session-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; font-size: 1.1em; }
        .matched-session-title { font-weight: bold; }
        .matched-session-similarity { font-size: 0.9em; color: #aaa; background: rgba(255,255,255,0.1); padding: 3px 8px; border-radius: 10px; }
        .matched-pattern-display { display: flex; flex-wrap: wrap; gap: 5px; align-items: center; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; font-family: monospace; }
        .pattern-item { padding: 4px 8px; border-radius: 5px; font-size: 1em; font-weight: 600; }
        .pattern-arrow { font-size: 1.5em; color: #ffd700; margin: 0 5px; }
        .analysis-placeholder { text-align: center; padding: 40px; color: #888; }


        .algorithm-142857 { background: linear-gradient(135deg, rgba(155, 89, 182, 0.1), rgba(142, 68, 173, 0.1)); border-radius: 20px; padding: 25px; margin-bottom: 25px; border: 2px solid #9b59b6; position: relative; overflow: hidden; }
        .algorithm-142857::before { content: "142857"; position: absolute; top: -50px; right: -50px; font-size: 100px; font-weight: bold; color: rgba(155, 89, 182, 0.1); transform: rotate(25deg); }
        .algorithm-title { font-size: 1.5em; color: #bb8fce; margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }
        .magic-number { display: inline-block; padding: 5px 15px; background: rgba(155, 89, 182, 0.3); border-radius: 20px; font-family: monospace; font-size: 1.2em; margin: 0 5px; animation: magicPulse 3s infinite; }
        @keyframes magicPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        .algorithm-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-top: 20px; }
        .algorithm-cell { background: rgba(255, 255, 255, 0.05); border-radius: 10px; padding: 15px; text-align: center; border: 1px solid rgba(155, 89, 182, 0.3); }
        .algorithm-value { font-size: 1.5em; font-weight: bold; color: #bb8fce; }
        .algorithm-label { font-size: 0.85em; color: #999; margin-top: 5px; }
        .input-section { background: rgba(255, 255, 255, 0.08); backdrop-filter: blur(20px); border-radius: 20px; padding: 25px; margin-bottom: 25px; border: 1px solid rgba(255, 255, 255, 0.15); }
        .main-buttons { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 20px; }
        button { padding: 15px 25px; border: none; border-radius: 12px; cursor: pointer; font-weight: 600; font-size: 1.1em; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 1px; position: relative; overflow: hidden; }
        button::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent); transition: left 0.5s; }
        button:hover::before { left: 100%; }
        .btn-player { background: linear-gradient(135deg, #3498db, #2980b9); color: white; border: 2px solid #3498db; }
        .btn-banker { background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; border: 2px solid #e74c3c; }
        .btn-tie { background: linear-gradient(135deg, #27ae60, #229954); color: white; border: 2px solid #27ae60; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 25px; }
        .stat-card { background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05)); backdrop-filter: blur(10px); border-radius: 15px; padding: 20px; border: 1px solid rgba(255, 255, 255, 0.15); transition: all 0.3s ease; }
        .stat-title { font-size: 0.95em; color: #b0b0b0; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
        .stat-value { font-size: 2em; font-weight: bold; background: linear-gradient(135deg, #ffd700, #ffffff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .prediction-section { background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(240, 84, 84, 0.1)); backdrop-filter: blur(20px); border-radius: 20px; padding: 25px; margin-bottom: 25px; border: 2px solid rgba(255, 255, 255, 0.2); }
        .prediction-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-top: 20px; }
        .prediction-card { background: rgba(255, 255, 255, 0.08); border-radius: 15px; padding: 20px; text-align: center; border: 2px solid transparent; transition: all 0.3s ease; }
        .prediction-card.recommended { border-color: #ffd93d; background: rgba(255, 217, 61, 0.1); animation: pulse-glow 2s ease-in-out infinite; }
        @keyframes pulse-glow { 0%, 100% { box-shadow: 0 0 20px rgba(255, 217, 61, 0.3); } 50% { box-shadow: 0 0 30px rgba(255, 217, 61, 0.6); } }
        .confidence-badge { display: inline-block; padding: 5px 15px; border-radius: 20px; font-size: 0.9em; font-weight: bold; margin-top: 10px; }
        .confidence-high { background: linear-gradient(135deg, #27ae60, #229954); color: white; }
        .confidence-medium { background: linear-gradient(135deg, #f39c12, #e67e22); color: white; }
        .confidence-low { background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; }
        #historyDisplay { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 15px; padding: 15px; background: rgba(0, 0, 0, 0.4); border-radius: 12px; min-height: 60px; border: 1px solid rgba(255, 255, 255, 0.1); }
        .history-item { padding: 8px 15px; border-radius: 8px; font-size: 0.95em; font-weight: 600; letter-spacing: 0.5px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); }
        .history-item.player-history { background: linear-gradient(135deg, #3498db, #2980b9); color: white; }
        .history-item.banker-history { background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; }
        .history-item.tie-history { background: linear-gradient(135deg, #27ae60, #229954); color: white; }
        .secondary-buttons { display: flex; flex-wrap: wrap; gap: 10px; }
        .btn-action { background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid #34495e; padding: 12px 20px; font-size: 1em; }
        .btn-action.warning { background: linear-gradient(135deg, #f39c12, #e67e22); border: 2px solid #f39c12; }
        .btn-action.success { background: linear-gradient(135deg, #27ae60, #229954); border: 2px solid #27ae60; }
        .section-title { font-size: 1.4em; margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }
        .section-title::before { content: ''; width: 4px; height: 24px; background: linear-gradient(180deg, #667eea, #f05454); border-radius: 2px; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(5px); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background: #1e2a4a; padding: 30px; border-radius: 20px; border: 1px solid rgba(255, 255, 255, 0.2); text-align: center; max-width: 400px; width: 90%; box-shadow: 0 10px 30px rgba(0,0,0,0.5); animation: modal-fade-in 0.3s ease-out; }
        @keyframes modal-fade-in { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        .modal-message { font-size: 1.2em; margin-bottom: 25px; color: #eee; }
        .modal-buttons { display: flex; justify-content: center; gap: 15px; }
        .modal-button { padding: 12px 25px; font-size: 1em; }
        .modal-button.confirm { background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; }
        .modal-button.cancel { background: linear-gradient(135deg, #34495e, #2c3e50); color: white; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.3); }
    </style>
</head>
<body>
    <div class="background-decor"><div class="han-char">Á¶è</div><div class="han-char">Á¶è</div></div>
    <div class="container">
        <div class="header">
            <h1>üé∞ H·ªÜ TH·ªêNG BCR 6868 üé∞</h1>
            <p class="disclaimer">üíé PH√öC ƒê·∫∏P TRAI- ƒê√ÅNH ƒê√ÇU TH·∫ÆNG ƒê√ì, MAY M·∫ÆN PH√ÅT T√ÄI. Hihi üíé</p>
            <div class="lucky-phrases"><span class="lucky-text lucky-text-1">MAY M·∫ÆN PH√ÅT T√ÄI</span><span class="lucky-text lucky-text-2">ƒê√ÅNH ƒê√ÇU TR√öNG ƒê√ì</span></div>
        </div>

        <div class="session-management">
            <h2 class="section-title" style="margin-bottom: 0;">üóÇÔ∏è Qu·∫£n L√Ω Phi√™n</h2>
            <div class="session-controls">
                <span id="currentSessionDisplay">Phi√™n #1</span>
                <select id="sessionSelector" onchange="selectSession(this.value)"></select>
                <button class="btn-action success" id="newSessionBtn" onclick="startNewSession()">‚ûï Phi√™n M·ªõi</button>
            </div>
        </div>

        <div class="big-road-section"><h2 class="section-title">üó∫Ô∏è B·∫£ng L·ªô Tr√¨nh "Big Road"</h2><div class="big-road-grid" id="bigRoadGrid"></div></div>

        <div class="cross-session-analysis">
            <h2 class="section-title">üîÆ Ph√¢n T√≠ch H√¨nh C·∫ßu & ƒê·ªÅ Xu·∫•t B·∫ª/Theo</h2>
            <div id="crossSessionResults"><div class="analysis-placeholder"><p>ƒêang ch·ªù ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ ph√¢n t√≠ch...</p></div></div>
        </div>

        <div class="input-section">
            <h2 class="section-title">üé≤ Nh·∫≠p K·∫øt Qu·∫£</h2>
            <div class="main-buttons">
                <button class="btn-player" onclick="addResult('P')"><span style="font-size: 1.5em;">üë§</span><br>PLAYER</button>
                <button class="btn-banker" onclick="addResult('B')"><span style="font-size: 1.5em;">üè¶</span><br>BANKER</button>
                <button class="btn-tie" onclick="addResult('T')"><span style="font-size: 1.5em;">ü§ù</span><br>TIE</button>
            </div>
            <div class="secondary-buttons">
                <button class="btn-action" onclick="undoLast()">‚Ü©Ô∏è Ho√†n T√°c</button>
                <button class="btn-action warning" onclick="confirmClearCurrentSession()">üóëÔ∏è X√≥a Phi√™n N√†y</button>
                <button class="btn-action" onclick="generateRandom()">üé≤ Demo (30 v√°n)</button>
            </div>
            <div id="historyDisplay"></div>
        </div>
        
        <div class="prediction-section">
            <h2 class="section-title">üîÆ D·ª± ƒêo√°n AI N·ªôi B·ªô</h2>
            <div class="prediction-grid">
                <div class="prediction-card" id="predPlayer"><h3>üë§ PLAYER</h3><div class="stat-value" id="playerProb">0%</div><div class="confidence-badge" id="playerConfidence">-</div></div>
                <div class="prediction-card" id="predBanker"><h3>üè¶ BANKER</h3><div class="stat-value" id="bankerProb">0%</div><div class="confidence-badge" id="bankerConfidence">-</div></div>
                <div class="prediction-card" id="predTie"><h3>ü§ù TIE</h3><div class="stat-value" id="tieProb">0%</div><div class="confidence-badge" id="tieConfidence">-</div></div>
            </div>
        </div>

        <div class="accuracy-section">
            <div class="accuracy-header"><div class="accuracy-title">üéØ TH·ªêNG K√ä ƒê·ªò CH√çNH X√ÅC H·ªÜ TH·ªêNG</div><button class="accuracy-reset" onclick="confirmResetStats()">üîÑ Reset Th·ªëng K√™</button></div>
            <div class="accuracy-main">
                <div class="accuracy-card"><div class="accuracy-label">ƒê·ªô Ch√≠nh X√°c T·ªïng</div><div class="accuracy-value" id="overallAccuracy">0%</div><div class="accuracy-change" id="accuracyTrend">-</div></div>
                <div class="accuracy-card"><div class="accuracy-label">T·ªïng D·ª± ƒêo√°n</div><div class="accuracy-value" id="totalPredictions">0</div><div class="accuracy-change">ƒê√∫ng: <span id="correctPredictions">0</span></div></div>
                <div class="accuracy-card"><div class="accuracy-label">Chu·ªói Th·∫Øng</div><div class="accuracy-value" id="winStreak">0</div><div class="accuracy-change">Max: <span id="maxWinStreak">0</span></div></div>
                <div class="accuracy-card"><div class="accuracy-label">ROI Gi·∫£ L·∫≠p</div><div class="accuracy-value" id="simulatedROI">0%</div><div class="accuracy-change" id="roiTrend">-</div></div>
            </div>
            <div class="accuracy-details">
                <h3 style="margin-bottom: 15px; color: #3498db;">üìà Ph√¢n T√≠ch Chi Ti·∫øt</h3>
                <div class="accuracy-breakdown">
                    <div class="breakdown-item"><div class="breakdown-type player">üë§ PLAYER</div><div class="breakdown-stats"><div class="stat-item"><span class="stat-label">D·ª± ƒëo√°n</span><span class="stat-value" id="playerPredCount">0</span></div><div class="stat-item"><span class="stat-label">ƒê√∫ng</span><span class="stat-value" id="playerCorrect">0</span></div><div class="stat-item"><span class="stat-label">T·ª∑ l·ªá</span><span class="stat-value" id="playerAccuracy">0%</span></div></div></div>
                    <div class="breakdown-item"><div class="breakdown-type banker">üè¶ BANKER</div><div class="breakdown-stats"><div class="stat-item"><span class="stat-label">D·ª± ƒëo√°n</span><span class="stat-value" id="bankerPredCount">0</span></div><div class="stat-item"><span class="stat-label">ƒê√∫ng</span><span class="stat-value" id="bankerCorrect">0</span></div><div class="stat-item"><span class="stat-label">T·ª∑ l·ªá</span><span class="stat-value" id="bankerAccuracy">0%</span></div></div></div>
                    <div class="breakdown-item"><div class="breakdown-type tie">ü§ù TIE</div><div class="breakdown-stats"><div class="stat-item"><span class="stat-label">D·ª± ƒëo√°n</span><span class="stat-value" id="tiePredCount">0</span></div><div class="stat-item"><span class="stat-label">ƒê√∫ng</span><span class="stat-value" id="tieCorrect">0</span></div><div class="stat-item"><span class="stat-label">T·ª∑ l·ªá</span><span class="stat-value" id="tieAccuracy">0%</span></div></div></div>
                </div>
                <div class="streak-prediction-display" style="margin-top: 20px; text-align: center; margin-bottom: 20px;"><h4 style="margin-bottom: 10px; color: #aaa; font-size: 0.95em;">üîÆ ƒê·ªÄ XU·∫§T CHU·ªñI TI·∫æP THEO</h4><div id="streakPrediction" class="streak-prediction-result none">CH·ªú D·ªÆ LI·ªÜU</div><div id="streakPredictionReason" class="streak-prediction-reason"></div></div>
                <div class="streak-prediction-stats" style="margin-top: 20px; margin-bottom: 20px;"><h4 style="margin-bottom: 10px; color: #aaa; font-size: 0.95em; text-align: center;">üìä Th·ªëng K√™ ƒê·ªÅ Xu·∫•t Chu·ªói</h4><div class="stats-chart-container" id="streakStatsChart"></div></div>
                <div class="accuracy-streak-display" style="margin-top: 20px;"><h4 style="margin-bottom: 10px; color: #aaa; font-size: 0.95em;">üîó Chu·ªói ƒê√∫ng/Sai (ƒê√∫ng / Sai)</h4><div id="accuracyStreakSequence" class="streak-sequence"></div></div>
                <div class="accuracy-chart"><h4 style="margin-bottom: 10px; color: #aaa; font-size: 0.95em;">üìä Bi·ªÉu ƒë·ªì ƒë·ªô ch√≠nh x√°c to√†n b·ªô</h4><div class="chart-bars" id="accuracyChart"></div></div>
                <div class="accuracy-history"><h4 style="margin-bottom: 10px; color: #aaa; font-size: 0.95em;">üìù L·ªãch s·ª≠ d·ª± ƒëo√°n 20 v√°n g·∫ßn ƒë√¢y</h4><div id="predictionHistory"></div></div>
            </div>
        </div>

        <div class="warning-system" id="warningSystem"><div class="warning-title"><span class="warning-icon">‚ö†Ô∏è</span> C·∫¢NH B√ÅO M·∫™U NGUY HI·ªÇM</div><ul class="warning-list" id="warningList"></ul></div>
        <div class="algorithm-142857"><div class="algorithm-title">üîÆ Thu·∫≠t To√°n Th·∫ßn S·ªë <span class="magic-number">142857</span></div><div class="algorithm-grid" id="algorithmDisplay"><div class="algorithm-cell"><div class="algorithm-value" id="magicPhase">1</div><div class="algorithm-label">Pha Hi·ªán T·∫°i</div></div><div class="algorithm-cell"><div class="algorithm-value" id="magicCycle">0</div><div class="algorithm-label">Chu K·ª≥</div></div><div class="algorithm-cell"><div class="algorithm-value" id="magicPrediction">-</div><div class="algorithm-label">D·ª± ƒêo√°n</div></div><div class="algorithm-cell"><div class="algorithm-value" id="magicAccuracy">0%</div><div class="algorithm-label">ƒê·ªô Ch√≠nh X√°c</div></div></div></div>
        <div class="pattern-recognition"><h2 class="section-title">üéØ Nh·∫≠n Di·ªán M·∫´u Chu·∫©n</h2><div class="pattern-grid" id="patternGrid"></div></div>

        <div class="stats-grid">
            <div class="stat-card"><div class="stat-title">üìà T·ªïng V√°n</div><div class="stat-value" id="totalGames">0</div></div>
            <div class="stat-card"><div class="stat-title">üë§ Player Win</div><div class="stat-value" id="playerRate">0%</div></div>
            <div class="stat-card"><div class="stat-title">üè¶ Banker Win</div><div class="stat-value" id="bankerRate">0%</div></div>
            <div class="stat-card"><div class="stat-title">ü§ù Tie Rate</div><div class="stat-value" id="tieRate">0%</div></div>
            <div class="stat-card"><div class="stat-title">üî• Streak</div><div class="stat-value" id="currentStreak">-</div></div>
            <div class="stat-card"><div class="stat-title">üìä Pattern</div><div class="stat-value" id="currentPattern">-</div></div>
        </div>

    </div>

    <div id="confirmModal" class="modal-overlay">
        <div class="modal-content">
            <p id="modalMessage" class="modal-message">B·∫°n c√≥ ch·∫Øc ch·∫Øn?</p>
            <div class="modal-buttons">
                <button id="modalCancel" class="modal-button cancel">H·ªßy B·ªè</button>
                <button id="modalConfirm" class="modal-button confirm">X√°c Nh·∫≠n</button>
            </div>
        </div>
    </div>

    <script>
        // All class definitions are included here, but minified for brevity in this view.
        // The full, readable script is in the actual code.
        class AccuracyTracker{constructor(){this.reset()}makePrediction(t){this.currentPrediction&&(this.predictions.push(this.currentPrediction),this.results.push(null));const e=Math.max(t.P,t.B,t.T);let i=null;e>35&&(e===t.P?i="P":e===t.B?i="B":e===t.T&&(i="T")),this.currentPrediction={prediction:i,probabilities:{...t},confidence:e,timestamp:Date.now()}}recordActualResult(t){if(!this.currentPrediction)return;const e=this.currentPrediction.prediction,i=e===t;this.predictions.push(this.currentPrediction),this.results.push(t),e&&(this.stats[e].predicted++,i?(this.stats[e].correct++,this.currentStreak++,this.maxStreak=Math.max(this.maxStreak,this.currentStreak)):this.currentStreak=0),this.accuracyHistory.push(i?1:0),this.last20Accuracy.push(i?1:0),this.last20Accuracy.length>20&&this.last20Accuracy.shift(),this.updateROI(e,t),this.currentPrediction=null}updateROI(t,e){if(!t)return;const i=10;t===e?this.roi+="T"===e?8*i:.95*i:this.roi-=i,this.roiHistory.push(this.roi),this.roiHistory.length>100&&this.roiHistory.shift()}getOverallAccuracy(){const t=this.predictions.filter((t,e)=>t.prediction&&null!==this.results[e]);if(0===t.length)return 0;const e=t.filter((t,e)=>t.prediction===this.results[e]).length;return e/t.length*100}getAccuracyByType(t){return 0===this.stats[t].predicted?0:this.stats[t].correct/this.stats[t].predicted*100}getROIPercentage(){return(this.roi-100)/100*100}getRecentHistory(t=20){const e=[];for(let i=Math.max(0,this.predictions.length-t);i<this.predictions.length;i++)null!==this.results[i]&&this.predictions[i].prediction&&e.push({number:i+1,predicted:this.predictions[i].prediction,actual:this.results[i],correct:this.predictions[i].prediction===this.results[i],confidence:this.predictions[i].confidence});return e}reset(){this.predictions=[],this.results=[],this.currentPrediction=null,this.currentStreak=0,this.maxStreak=0,this.stats={P:{predicted:0,correct:0},B:{predicted:0,correct:0},T:{predicted:0,correct:0}},this.accuracyHistory=[],this.last20Accuracy=[],this.roi=100,this.roiHistory=[]}}
        class StreakPredictor{analyze(t){return t.length<5?{recommendation:"KH√îNG",reason:"C·∫ßn th√™m d·ªØ li·ªáu"}:t.slice(-4).every(t=>1===t)?{recommendation:"ƒê√öNG",reason:"ƒêang trong chu·ªói ƒê√∫ng d√†i (4+)"}:t.slice(-4).every(t=>0===t)?{recommendation:"SAI",reason:"ƒêang trong chu·ªói Sai d√†i (4+)"}:"10101"===t.slice(-5).join("")?{recommendation:"SAI",reason:"M·∫´u xen k·∫Ω 1-0-1-0-1"}:"01010"===t.slice(-5).join("")?{recommendation:"ƒê√öNG",reason:"M·∫´u xen k·∫Ω 0-1-0-1-0"}:(()=>{const e=t.slice(-3),i=t.slice(-4,-3)[0];return e.every(t=>1===t)&&0===i?{recommendation:"SAI",reason:"Th∆∞·ªùng g√£y sau chu·ªói 3 ƒê√∫ng"}:e.every(t=>0===t)&&1===i?{recommendation:"ƒê√öNG",reason:"Th∆∞·ªùng g√£y sau chu·ªói 3 Sai"}:"110011"===t.slice(-6).join("")?{recommendation:"SAI",reason:"M·∫´u l·∫∑p ƒë√¥i 11-00-11"}:"001100"===t.slice(-6).join("")?{recommendation:"ƒê√öNG",reason:"M·∫´u l·∫∑p ƒë√¥i 00-11-00"}:{recommendation:"KH√îNG",reason:"Kh√¥ng c√≥ m·∫´u quy lu·∫≠t r√µ r√†ng"}})()}}
        class StreakPredictionTracker{constructor(){this.history=[],this.currentPrediction="KH√îNG"}recordPrediction(t){this.currentPrediction=["ƒê√öNG","SAI"].includes(t)?t:"KH√îNG"}recordOutcome(t){if("KH√îNG"===this.currentPrediction)return;let e="ƒê√öNG"===this.currentPrediction&&t||"SAI"===this.currentPrediction&&!t;this.history.push({prediction:this.currentPrediction,correct:e}),this.currentPrediction="KH√îNG"}getStats(){const t=this.history.length;if(0===t)return{correct:0,incorrect:0,total:0,correctPercent:0,incorrectPercent:0};const e=this.history.filter(t=>t.correct).length,i=t-e;return{correct:e,incorrect:i,total:t,correctPercent:e/t*100,incorrectPercent:i/t*100}}}
        class MagicNumber142857{constructor(){this.base=142857,this.sequence=[1,4,2,8,5,7],this.phase=0,this.cycle=0,this.predictions=[],this.results=[]}getNextPhase(){return this.phase=(this.phase+1)%6,0===this.phase&&this.cycle++,this.sequence[this.phase]}calculatePrediction(t){if(t.length<3)return null;const e=this.sequence[this.phase],i=(e*this.base)%1e6,s=i.toString().padStart(6,"0").split("").map(Number),n=s.reduce((t,e)=>t+e,0);if(0===n)return{P:33.3,B:33.3,T:1};const r=(s[0]+s[2]+s[4])/n,c=(s[1]+s[3]+s[5])/n,o=this.analyzeRecentTrend(t);return{P:70*r+30*o.P,B:70*c+30*o.B,T:Math.max(5,100*Math.abs(1-r-c)),phase:e,cycle:this.cycle}}analyzeRecentTrend(t){const e=t.slice(-7),i={P:0,B:0,T:0};e.forEach(t=>i[t]++);const s=e.length||1;return{P:i.P/s*100,B:i.B/s*100,T:i.T/s*100}}updateAccuracy(t,e){t&&(this.predictions.push(t),this.results.push(e),this.predictions.length>100&&(this.predictions.shift(),this.results.shift()))}getAccuracy(){if(0===this.predictions.length)return 0;let t=0;return this.predictions.forEach((e,i)=>{const s=this.results[i],n=Math.max(e.P,e.B,e.T);n===e.P&&"P"===s||n===e.B&&"B"===s||n===e.T&&"T"===s?t++:t}),t/this.predictions.length*100}}
        class PatternRecognitionSystem{constructor(){this.patterns={Dragon:{check:t=>this.checkDragon(t),danger:!1,description:"Chu·ªói d√†i c√πng k·∫øt qu·∫£ (5+)"},"Baby Dragon":{check:t=>this.checkBabyDragon(t),danger:!1,description:"Chu·ªói ng·∫Øn (3-4)"},"Ping Pong":{check:t=>this.checkPingPong(t),danger:!1,description:"Xen k·∫Ω P-B-P-B"},Choppy:{check:t=>this.checkChoppy(t),danger:!0,description:"Thay ƒë·ªïi li√™n t·ª•c, kh√≥ ƒëo√°n"},Trend:{check:t=>this.checkTrend(t),danger:!1,description:"Xu h∆∞·ªõng r√µ r√†ng P ho·∫∑c B"},"Anti-Trend":{check:t=>this.checkAntiTrend(t),danger:!0,description:"ƒê·∫£o chi·ªÅu xu h∆∞·ªõng"},ZigZag:{check:t=>this.checkZigZag(t),danger:!1,description:"M·∫´u 2-1-2-1"},Streaky:{check:t=>this.checkStreaky(t),danger:!1,description:"Nhi·ªÅu chu·ªói ng·∫Øn"},TTT:{check:t=>this.checkTripleTie(t),danger:!0,description:"3 Tie li√™n ti·∫øp"},Sandwich:{check:t=>this.checkSandwich(t),danger:!1,description:"P-B-P ho·∫∑c B-P-B"},"Double Dragon":{check:t=>this.checkDoubleDragon(t),danger:!1,description:"2 chu·ªói d√†i li√™n ti·∫øp"},Mirror:{check:t=>this.checkMirror(t),danger:!1,description:"M·∫´u ƒë·ªëi x·ª©ng"},"Repeating Streaks":{check:t=>this.checkRepeatingStreaks(t),danger:!1,description:"Chu·ªói ƒë·ªô d√†i l·∫∑p l·∫°i (vd: 2,1,2,1)"},"Symmetrical Streaks":{check:t=>this.checkSymmetricalStreaks(t),danger:!1,description:"Chu·ªói ƒë·ªô d√†i ƒë·ªëi x·ª©ng (vd: 1,2,3,2,1)"},"Complex Alternation":{check:t=>this.checkComplexAlternation(t),danger:!1,description:"Xen k·∫Ω ph·ª©c t·∫°p (vd: PPB-PPB)"}}}getStreakInfo(t){const e=t.filter(t=>"T"!==t);if(0===e.length)return[];const i=[];let s={type:e[0],length:0};return e.forEach(t=>{t===s.type?s.length++:(i.push(s),s={type:t,length:1})}),i.push(s),i}checkRepeatingStreaks(t){const e=this.getStreakInfo(t);if(e.length<4)return{detected:!1};const i=e.map(t=>t.length);if(e.length>=4){const s=i.slice(-4);if(s[0]===s[2]&&s[1]===s[3])return{detected:!0,confidence:.75,next:e[e.length-2].type,description:`L·∫∑p l·∫°i chu·ªói ${s[0]}-${s[1]}`}}if(e.length>=6){const s=i.slice(-6);if(s[0]===s[3]&&s[1]===s[4]&&s[2]===s[5])return{detected:!0,confidence:.85,next:e[e.length-3].type,description:`L·∫∑p l·∫°i chu·ªói ${s[0]}-${s[1]}-${s[2]}`}}return{detected:!1}}checkSymmetricalStreaks(t){const e=this.getStreakInfo(t);if(e.length<5)return{detected:!1};const i=e.map(t=>t.length).slice(-5);if(i[0]===i[4]&&i[1]===i[3]){const t="P"===e[e.length-1].type?"B":"P";return{detected:!0,confidence:.7,next:t,description:`ƒê·ªëi x·ª©ng 5 chu·ªói: ${i.join(",")}`}}return{detected:!1}}checkComplexAlternation(t){const e=t.filter(t=>"T"!==t);if(e.length<6)return{detected:!1};const i=e.slice(-6),s=i.slice(0,3).join(""),n=i.slice(3,6).join("");return s===n?{detected:!0,confidence:.8,next:i[0],description:`L·∫∑p l·∫°i m·∫´u 3: ${s}`}:{detected:!1}}checkDragon(t){if(t.length<5)return{detected:!1};const e=t.slice(-5),i=e.every(t=>t===e[0]&&"T"!==t);return{detected:i,confidence:i?.9:0,next:i?e[0]:null}}checkBabyDragon(t){if(t.length<3)return{detected:!1};const e=t.slice(-4),i=t.slice(-3),s=i.every(t=>t===i[0]&&"T"!==t),n=4===e.length&&e.every(t=>t===e[0]&&"T"!==t);return{detected:s||n,confidence:n?.8:s?.7:0,next:s?i[0]:n?e[0]:null}}checkPingPong(t){if(t.length<4)return{detected:!1};const e=t.slice(-4),i="T",s=e[0]!==e[1]&&e[1]!==e[2]&&e[2]!==e[3]&&e[0]===e[2]&&e[1]===e[3]&&!e.includes(i);return{detected:s,confidence:s?.75:0,next:s?e[0]:null}}checkChoppy(t){if(t.length<10)return{detected:!1};const e=t.slice(-10);let i=0;for(let s=1;s<e.length;s++)e[s]!==e[s-1]&&i++;const s=i>=7;return{detected:s,confidence:s?.6:0,next:null}}checkTrend(t){if(t.length<10)return{detected:!1};const e=t.slice(-10).filter(t=>"T"!==t),i=e.filter(t=>"P"===t).length,s=e.filter(t=>"B"===t).length,n=i>=7||s>=7;return{detected:n,confidence:n?.8:0,next:i>=7?"P":s>=7?"B":null}}checkAntiTrend(t){if(t.length<15)return{detected:!1};const e=t.slice(-15,-8).filter(t=>"T"!==t),i=t.slice(-7).filter(t=>"T"!==t),s=e.filter(t=>"P"===t).length,n=i.filter(t=>"P"===t).length,r=s>=5&&n<=2||s<=2&&n>=5;return{detected:r,confidence:r?.7:0,next:null}}checkZigZag(t){if(t.length<6)return{detected:!1};const e=t.slice(-6).filter(t=>"T"!==t),i=[];let s=e[0],n=1;for(let r=1;r<e.length;r++)e[r]===s?n++:(i.push(n),s=e[r],n=1);i.push(n);const r=i.length>=3&&i.every(t=>1===t||2===t);return{detected:r,confidence:r?.65:0,next:null}}checkStreaky(t){if(t.length<12)return{detected:!1};const e=t.slice(-12);let i=0,s=1;for(let n=1;n<e.length;n++)e[n]===e[n-1]&&"T"!==e[n]?s++:(s>=2&&i++,s=1);s>=2&&i++;const n=i>=3;return{detected:n,confidence:n?.7:0,next:n?e[e.length-1]:null}}checkTripleTie(t){if(t.length<3)return{detected:!1};const e=t.slice(-3).every(t=>"T"===t);return{detected:e,confidence:e?.9:0,next:null}}checkSandwich(t){if(t.length<3)return{detected:!1};const e=t.slice(-3),i="T",s=e[0]===e[2]&&e[0]!==e[1]&&!e.includes(i);return{detected:s,confidence:s?.6:0,next:s?e[1]:null}}checkDoubleDragon(t){if(t.length<10)return{detected:!1};let e=null,i=0;let s=t[t.length-10],n=1;for(let r=t.length-9;r<t.length;r++)t[r]===s&&"T"!==t[r]?n++:(n>=4&&!e?(e=s,i=n):n>=4&&e&&s!==e&&{detected:!0,confidence:.85,next:t[t.length-1]},s=t[r],n=1);return{detected:!1}}checkMirror(t){if(t.length<6)return{detected:!1};const e=t.slice(-6),i=e.slice(0,3).join(""),s=e.slice(3,6).reverse().join(""),n=i===s;return{detected:n,confidence:n?.7:0,next:n?e[2]:null}}analyzePatterns(t){const e=[],i=[];for(let s in this.patterns){const n=this.patterns[s],r=n.check(t);r.detected&&(e.push({name:s,confidence:r.confidence,next:r.next,danger:n.danger,description:n.description}),n.danger&&i.push({name:s,description:n.description}))}return{detected:e,warnings:i}}}
        
        // ===== NEW: CROSS-SESSION SHAPE ANALYZER =====
        class CrossSessionShapeAnalyzer {
            transformToStreakShape(history) {
                const cleanHistory = history.filter(r => r !== 'T');
                if (cleanHistory.length === 0) return { shape: [], last_type: null };
                
                const shape = [];
                let currentStreak = 1;
                let last_type = cleanHistory[0];

                for (let i = 1; i < cleanHistory.length; i++) {
                    if (cleanHistory[i] === cleanHistory[i-1]) {
                        currentStreak++;
                    } else {
                        shape.push(currentStreak);
                        currentStreak = 1;
                    }
                }
                shape.push(currentStreak);
                return { shape, last_type: cleanHistory[cleanHistory.length-1] };
            }

            levenshteinDistance(a, b) {
                const matrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));
                for (let i = 0; i <= a.length; i++) { matrix[0][i] = i; }
                for (let j = 0; j <= b.length; j++) { matrix[j][0] = j; }
                for (let j = 1; j <= b.length; j++) {
                    for (let i = 1; i <= a.length; i++) {
                        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                        matrix[j][i] = Math.min(matrix[j][i - 1] + 1, matrix[j - 1][i] + 1, matrix[j - 1][i - 1] + cost);
                    }
                }
                return matrix[b.length][a.length];
            }

            analyze(allSessions, currentSessionIndex) {
                const { shape: currentShape, last_type: currentLastType } = this.transformToStreakShape(allSessions[currentSessionIndex]);
                const lookback = Math.min(8, currentShape.length);

                if (currentSessionIndex < 1 || lookback < 3) {
                    return { found: false, reason: 'C·∫ßn √≠t nh·∫•t 3 chu·ªói trong phi√™n hi·ªán t·∫°i v√† c√≥ c√°c phi√™n c≈© ƒë·ªÉ so s√°nh.' };
                }

                const patternToSearch = currentShape.slice(-lookback);
                const threshold = Math.floor(lookback * 0.25); // Allow 25% noise
                
                let matches = [];

                for (let i = 0; i < currentSessionIndex; i++) {
                    const { shape: pastShape } = this.transformToStreakShape(allSessions[i]);
                    if (pastShape.length < lookback + 1) continue;

                    for (let j = 0; j <= pastShape.length - (lookback + 1); j++) {
                        const pastPattern = pastShape.slice(j, j + lookback);
                        const distance = this.levenshteinDistance(patternToSearch, pastPattern);

                        if (distance <= threshold) {
                            matches.push({
                                sessionIndex: i,
                                startIndex: j,
                                pattern: pastPattern,
                                outcomeStreakLength: pastShape[j + lookback],
                                similarity: (1 - (distance / lookback)) * 100
                            });
                        }
                    }
                }
                
                if (matches.length === 0) {
                    return { found: false, reason: 'Kh√¥ng t√¨m th·∫•y h√¨nh c·∫ßu d·∫°ng s·ªë t∆∞∆°ng t·ª± trong c√°c phi√™n tr∆∞·ªõc.' };
                }

                const outcomeCounts = { break: 0, follow: 0 }; // Break = 1, Follow > 1
                matches.forEach(m => {
                    if (m.outcomeStreakLength === 1) {
                        outcomeCounts.break++;
                    } else {
                        outcomeCounts.follow++;
                    }
                });

                const totalOutcomes = outcomeCounts.break + outcomeCounts.follow;
                const suggestion = {
                    break: (outcomeCounts.break / totalOutcomes) * 100,
                    follow: (outcomeCounts.follow / totalOutcomes) * 100,
                };
                
                let recommended = 'KH√îNG';
                if (suggestion.break > 60) recommended = 'BREAK';
                if (suggestion.follow > 60) recommended = 'FOLLOW';
                
                return {
                    found: true,
                    matchCount: matches.length,
                    matches: matches.sort((a,b) => b.similarity - a.similarity),
                    suggestion,
                    recommended,
                    currentShape: patternToSearch,
                    currentLastType
                };
            }
        }

        class AdvancedBaccaratAnalyzer {
            constructor() {
                this.magicNumber = new MagicNumber142857();
                this.patternSystem = new PatternRecognitionSystem();
                this.accuracyTracker = new AccuracyTracker();
                this.streakPredictor = new StreakPredictor();
                this.streakPredictionTracker = new StreakPredictionTracker();
                this.crossSessionAnalyzer = new CrossSessionShapeAnalyzer();
                this.history = [];
            }
            addResult(result) {
                this.accuracyTracker.recordActualResult(result);
                const wasCorrect = this.accuracyTracker.accuracyHistory.length > 0 ? this.accuracyTracker.accuracyHistory.slice(-1)[0] === 1 : false;
                this.streakPredictionTracker.recordOutcome(wasCorrect);
                this.history.push(result);
                this.magicNumber.getNextPhase();
            }
            analyze(allSessions, currentSessionIndex) {
                const crossSessionAnalysis = this.crossSessionAnalyzer.analyze(allSessions, currentSessionIndex);
                
                if (this.history.length < 3) {
                    const initial = { prediction: { P: 33.3, B: 33.3, T: 33.3 }, patterns: { detected: [], warnings: [] }, magic: null, streakPrediction: { recommendation: 'KH√îNG', reason: 'C·∫ßn th√™m d·ªØ li·ªáu' }, crossSession: crossSessionAnalysis };
                    this.accuracyTracker.makePrediction(initial.prediction);
                    return initial;
                }
                const patterns = this.patternSystem.analyzePatterns(this.history);
                const magicPred = this.magicNumber.calculatePrediction(this.history);
                const streakPred = this.streakPredictor.analyze(this.accuracyTracker.accuracyHistory);
                this.streakPredictionTracker.recordPrediction(streakPred.recommendation);
                let final = { P: 0, B: 0, T: 0 };
                if (magicPred) { final.P += magicPred.P * 0.3; final.B += magicPred.B * 0.3; final.T += magicPred.T * 0.3; }
                patterns.detected.forEach(p => {
                    if (p.next && p.confidence > 0.6) {
                        if (p.next === 'P') final.P += p.confidence * 0.2 * 100;
                        if (p.next === 'B') final.B += p.confidence * 0.2 * 100;
                    }
                });
                const statPred = this.getStatisticalPrediction();
                final.P += statPred.P * 0.2; final.B += statPred.B * 0.2; final.T += statPred.T * 0.2;
                const total = final.P + final.B + final.T;
                if (total > 0) { final.P = (final.P / total) * 100; final.B = (final.B / total) * 100; final.T = (final.T / total) * 100; }
                else { final = { P: 33.3, B: 33.3, T: 33.3 }; }
                this.accuracyTracker.makePrediction(final);
                
                return { prediction: final, patterns, magic: magicPred, streakPrediction: streakPred, crossSession: crossSessionAnalysis };
            }
            getStatisticalPrediction() {
                const recent = this.history.slice(-20).filter(r => ['P', 'B', 'T'].includes(r));
                const counts = { P: 0, B: 0, T: 0 };
                recent.forEach(r => counts[r]++);
                const total = recent.length || 1, expected = total / 3;
                const p = { P: 33.3 + (expected - counts.P) * 2, B: 33.3 + (expected - counts.B) * 2, T: 33.3 + (expected - counts.T) * 2 };
                p.P = Math.max(5, Math.min(90, p.P)); p.B = Math.max(5, Math.min(90, p.B)); p.T = Math.max(5, Math.min(30, p.T));
                return p;
            }
        }

        // ===== GLOBAL & SESSION MANAGEMENT =====
        let sessions = [[]];
        let currentSessionIndex = 0;
        let analyzer = new AdvancedBaccaratAnalyzer();
        const BACCARAT_SESSIONS_KEY = 'baccaratSessions6868_v3'; // Updated key

        function startNewSession() {
            if (sessions[currentSessionIndex].length > 0) {
                sessions.push([]);
                currentSessionIndex = sessions.length - 1;
            }
            loadSession(currentSessionIndex);
        }

        function selectSession(index) {
            currentSessionIndex = parseInt(index, 10);
            loadSession(currentSessionIndex);
        }
        
        function loadSession(index) {
            currentSessionIndex = index;
            const sessionData = sessions[currentSessionIndex] || [];
            analyzer = new AdvancedBaccaratAnalyzer();
            sessionData.forEach(result => {
                analyzer.addResult(result);
            });
            updateAllDisplays();
            updateSessionSelector();
            saveSessionsToLocalStorage();
        }

        function updateAllDisplays() {
            const currentHistory = sessions[currentSessionIndex] || [];
            updateDisplay(currentHistory);
            analyzeAndPredict();
            updateAccuracyStats();
        }
        
        function addResult(result) {
            analyzer.analyze(sessions, currentSessionIndex);
            sessions[currentSessionIndex].push(result);
            analyzer.addResult(result);
            updateAllDisplays();
            saveSessionsToLocalStorage();
        }

        function undoLast() {
            if (sessions[currentSessionIndex].length > 0) {
                sessions[currentSessionIndex].pop();
                loadSession(currentSessionIndex);
            }
        }

        function clearCurrentSession() {
            if (sessions.length > 1 && sessions[currentSessionIndex].length === 0) {
                 sessions.splice(currentSessionIndex, 1);
                 currentSessionIndex = Math.max(0, currentSessionIndex - 1);
            } else {
                sessions[currentSessionIndex] = [];
            }
            loadSession(currentSessionIndex);
        }
        
        function confirmClearCurrentSession() {
            showModal('B·∫°n c√≥ ch·∫Øc mu·ªën X√ìA TO√ÄN B·ªò d·ªØ li·ªáu c·ªßa PHI√äN HI·ªÜN T·∫†I kh√¥ng?', clearCurrentSession);
        }

        function generateRandom() {
            for (let i = 0; i < 30; i++) {
                const r = Math.random();
                addResult(r < 0.45 ? 'P' : r < 0.9 ? 'B' : 'T');
            }
        }

        function resetAccuracyStats() {
            analyzer.accuracyTracker.reset();
            analyzer.streakPredictionTracker.history = [];
            updateAccuracyStats();
        }

        function confirmResetStats() {
            showModal('B·∫°n c√≥ ch·∫Øc mu·ªën reset l·∫°i to√†n b·ªô th·ªëng k√™ ƒë·ªô ch√≠nh x√°c c·ªßa phi√™n n√†y kh√¥ng?', resetAccuracyStats);
        }

        function saveSessionsToLocalStorage() {
            try {
                localStorage.setItem(BACCARAT_SESSIONS_KEY, JSON.stringify({ sessions, currentSessionIndex }));
            } catch (e) { console.error("Could not save sessions:", e); }
        }

        function loadSessionsFromLocalStorage() {
            try {
                const savedData = localStorage.getItem(BACCARAT_SESSIONS_KEY);
                if (savedData) {
                    const d = JSON.parse(savedData);
                    if (Array.isArray(d.sessions)) {
                        sessions = d.sessions;
                        currentSessionIndex = d.currentSessionIndex || 0;
                        if (currentSessionIndex >= sessions.length) currentSessionIndex = sessions.length - 1;
                        return;
                    }
                }
            } catch (e) { console.error("Could not load sessions:", e); }
            sessions = [[]];
            currentSessionIndex = 0;
        }

        // ===== UI UPDATE FUNCTIONS =====
        function updateDisplay(history) {
            const historyDiv = document.getElementById('historyDisplay');
            historyDiv.innerHTML = history.map((result, index) => {
                const className = result === 'P' ? 'player-history' : result === 'B' ? 'banker-history' : 'tie-history';
                return `<span class="history-item ${className}">${index + 1}. ${result}</span>`;
            }).join('');
            updateStatistics(history);
            renderBigRoad(history);
        }

        function updateSessionSelector() {
            const selector = document.getElementById('sessionSelector');
            selector.innerHTML = '';
            sessions.forEach((session, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `Phi√™n #${index + 1} (${session.length} v√°n)`;
                selector.appendChild(option);
            });
            selector.value = currentSessionIndex;
            document.getElementById('currentSessionDisplay').textContent = `Phi√™n #${currentSessionIndex + 1}`;
        }
        
        function updateStatistics(history) {
            const total = history.length;
            const counts = { P: 0, B: 0, T: 0 };
            history.forEach(r => counts[r]++);
            
            document.getElementById('totalGames').textContent = total;
            document.getElementById('playerRate').textContent = total > 0 ? (counts.P / total * 100).toFixed(1) + '%' : '0%';
            document.getElementById('bankerRate').textContent = total > 0 ? (counts.B / total * 100).toFixed(1) + '%' : '0%';
            document.getElementById('tieRate').textContent = total > 0 ? (counts.T / total * 100).toFixed(1) + '%' : '0%';
            
            if (total > 0) {
                let streak = 1;
                const lastResult = history[total - 1];
                for (let i = total - 2; i >= 0; i--) {
                    if (history[i] === lastResult) streak++; else break;
                }
                document.getElementById('currentStreak').textContent = `${streak} ${lastResult}`;
            } else {
                document.getElementById('currentStreak').textContent = '-';
            }
        }

        function analyzeAndPredict() {
            const analysis = analyzer.analyze(sessions, currentSessionIndex);
            updatePredictions(analysis.prediction);
            updatePatterns(analysis.patterns);
            updateWarnings(analysis.patterns.warnings);
            updateMagicNumber(analysis.magic);
            updateStreakPrediction(analysis.streakPrediction);
            updateCrossSessionAnalysis(analysis.crossSession);
        }
        
        function updateCrossSessionAnalysis(analysis) {
            const container = document.getElementById('crossSessionResults');
            if (!analysis.found) {
                container.innerHTML = `<div class="analysis-placeholder"><p>${analysis.reason}</p></div>`;
                return;
            }

            const recommendationClass = analysis.recommended.toLowerCase();
            let recommendationText = analysis.recommended === 'BREAK' ? 'B·∫∫ C·∫¶U' : analysis.recommended === 'FOLLOW' ? 'THEO C·∫¶U' : 'CH·ªú';
            if(analysis.recommended === 'BREAK') {
                recommendationText += ` (${analysis.currentLastType === 'P' ? 'B' : 'P'})`;
            } else if (analysis.recommended === 'FOLLOW') {
                recommendationText += ` (${analysis.currentLastType})`;
            }


            const summaryHTML = `
                <div class="analysis-summary">
                        <p class="summary-text">
                            H√¨nh c·∫ßu hi·ªán t·∫°i: <span class="highlight">${analysis.currentShape.join('-')}</span>
                        </p>
                        <p class="summary-text">
                            T√¨m th·∫•y <span class="highlight">${analysis.matchCount}</span> h√¨nh c·∫ßu s·ªë t∆∞∆°ng t·ª± trong c√°c phi√™n tr∆∞·ªõc.
                        </p>
                        <p class="summary-text">
                            K·∫øt qu·∫£ sau ƒë√≥: 
                            <span class="highlight break">B·∫ª C·∫ßu: ${analysis.suggestion.break.toFixed(1)}%</span> | 
                            <span class="highlight follow">Theo C·∫ßu: ${analysis.suggestion.follow.toFixed(1)}%</span>
                        </p>
                        <div class="summary-recommendation ${recommendationClass}">
                            ${recommendationText}
                        </div>
                </div>
            `;

            const renderPattern = (pattern) => pattern.map(p => `<span class="pattern-item">${p}</span>`).join('<span style="color:#888">-</span>');

            const matchesHTML = analysis.matches.slice(0, 10).map(match => `
                <div class="matched-session-card">
                    <div class="matched-session-header">
                        <span class="matched-session-title">Phi√™n #${match.sessionIndex + 1}</span>
                        <span class="matched-session-similarity">T∆∞∆°ng ƒë·ªìng: ${match.similarity.toFixed(0)}%</span>
                    </div>
                    <div class="matched-pattern-display">
                        ${renderPattern(match.pattern)}
                        <span class="pattern-arrow">‚Üí</span>
                        <span class="pattern-item ${match.outcomeStreakLength > 1 ? 'follow' : 'break'}">${match.outcomeStreakLength}</span>
                    </div>
                </div>
            `).join('');

            container.innerHTML = summaryHTML + `<div class="matched-sessions-list">${matchesHTML}</div>`;
        }


        function renderBigRoad(history) {
            const grid = document.getElementById('bigRoadGrid');
            grid.innerHTML = '';
            if (history.length === 0) { grid.style.display = 'none'; return; }
            grid.style.display = 'grid';

            const road = []; let currentCol = -1; let lastWinner = null;
            history.forEach(result => {
                if (result === 'T') {
                    if (road.length > 0 && currentCol >= 0 && road[currentCol] && road[currentCol].length > 0) {
                        const lastCell = road[currentCol][road[currentCol].length - 1];
                        lastCell.ties = (lastCell.ties || 0) + 1;
                    }
                    return;
                }
                if (result !== lastWinner) { currentCol++; road.push([]); lastWinner = result; }
                road[currentCol].push({ type: result, ties: 0 });
            });

            road.forEach(col => {
                for (let row = 0; row < 6; row++) {
                    const cellData = col[row];
                    const cell = document.createElement('div');
                    cell.className = 'road-cell';
                    if (cellData) {
                        const marker = document.createElement('div');
                        marker.className = `marker ${cellData.type === 'P' ? 'player' : 'banker'}`;
                        if (cellData.ties > 0) {
                            const tieLine = document.createElement('div');
                            tieLine.className = 'tie-line';
                            marker.appendChild(tieLine);
                            if (cellData.ties > 1) marker.textContent = cellData.ties;
                        }
                        cell.appendChild(marker);
                    }
                    grid.appendChild(cell);
                }
            });
            grid.scrollLeft = grid.scrollWidth;
        }

        function showModal(message, onConfirmCallback) {
            const modal = document.getElementById('confirmModal');
            document.getElementById('modalMessage').textContent = message;
            modal.style.display = 'flex';
            const confirmBtn = document.getElementById('modalConfirm');
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            newConfirmBtn.onclick = () => { onConfirmCallback(); hideModal(); };
            document.getElementById('modalCancel').onclick = hideModal;
            modal.onclick = (e) => { if (e.target === modal) hideModal(); };
        }
        function hideModal() { document.getElementById('confirmModal').style.display = 'none'; }
        
        function updateAccuracyStats() {
            const tracker = analyzer.accuracyTracker;
            const overallAcc = tracker.getOverallAccuracy();
            const totalPred = tracker.predictions.filter(p => p.prediction).length;
            const overallElem = document.getElementById('overallAccuracy');
            overallElem.textContent = overallAcc.toFixed(1) + '%';
            overallElem.className = 'accuracy-value';
            if (overallAcc >= 70) overallElem.classList.add('excellent');
            else if (overallAcc >= 55) overallElem.classList.add('good');
            else if (overallAcc >= 45) overallElem.classList.add('average');
            else if (totalPred > 0) overallElem.classList.add('poor');
            document.getElementById('totalPredictions').textContent = totalPred;
            document.getElementById('correctPredictions').textContent = tracker.stats.P.correct + tracker.stats.B.correct + tracker.stats.T.correct;
            document.getElementById('winStreak').textContent = tracker.currentStreak;
            document.getElementById('maxWinStreak').textContent = tracker.maxStreak;
            const roi = tracker.getROIPercentage();
            const roiElem = document.getElementById('simulatedROI');
            roiElem.textContent = (roi > 0 ? '+' : '') + roi.toFixed(1) + '%';
            roiElem.className = 'accuracy-value';
            if (roi > 20) roiElem.classList.add('excellent');
            else if (roi > 5) roiElem.classList.add('good');
            else if (roi > -5) roiElem.classList.add('average');
            else if (totalPred > 0) roiElem.classList.add('poor');
            ['P', 'B', 'T'].forEach(type => {
                const stats = tracker.stats[type];
                const typeName = type === 'P' ? 'player' : type === 'B' ? 'banker' : 'tie';
                document.getElementById(`${typeName}PredCount`).textContent = stats.predicted;
                document.getElementById(`${typeName}Correct`).textContent = stats.correct;
                document.getElementById(`${typeName}Accuracy`).textContent = tracker.getAccuracyByType(type).toFixed(1) + '%';
            });
            updateAccuracyChart();
            updatePredictionHistory();
            updateAccuracyStreakSequence();
            updateStreakPredictionStatsChart();
        }
        function updateAccuracyChart() {
            const chartDiv = document.getElementById('accuracyChart');
            const history = analyzer.accuracyTracker.accuracyHistory;
            if (history.length === 0) { chartDiv.innerHTML = '<div style="text-align: center; color: #888; width: 100%;">Ch∆∞a c√≥ d·ªØ li·ªáu</div>'; return; }
            chartDiv.innerHTML = history.map((acc, idx) => `<div class="chart-bar ${acc ? 'bar-correct' : 'bar-incorrect'}" style="height: ${acc ? '100%' : '5%'};" title="V√°n #${idx + 1} - ${acc ? 'ƒê√∫ng' : 'Sai'}"><div class="chart-bar-value">${acc ? '‚úì' : '‚úó'}</div><div class="chart-bar-label">#${idx + 1}</div></div>`).join('');
            chartDiv.parentElement.scrollLeft = chartDiv.parentElement.scrollWidth;
        }
        function updatePredictionHistory() {
            const historyDiv = document.getElementById('predictionHistory');
            const recent = analyzer.accuracyTracker.getRecentHistory(20);
            if (recent.length === 0) { historyDiv.innerHTML = '<div style="text-align: center; color: #888;">Ch∆∞a c√≥ l·ªãch s·ª≠</div>'; return; }
            historyDiv.innerHTML = recent.reverse().map(e => `<div class="history-entry ${e.correct ? 'correct' : 'incorrect'}"><span class="entry-number">#${e.number}</span><span class="entry-prediction">D·ª± ƒëo√°n: ${e.predicted}</span><span class="entry-actual">K·∫øt qu·∫£: ${e.actual}</span><span class="entry-result ${e.correct ? 'correct' : 'incorrect'}">${e.correct ? 'ƒê√öNG' : 'SAI'}</span></div>`).join('');
        }
        function updateAccuracyStreakSequence() {
            const sequenceDiv = document.getElementById('accuracyStreakSequence');
            const history = analyzer.accuracyTracker.accuracyHistory;
            if (history.length === 0) { sequenceDiv.innerHTML = '<span style="color: #888;">Ch∆∞a c√≥ d·ªØ li·ªáu</span>'; return; }
            const streaks = []; let currentType = history[0]; let currentLength = 0;
            history.forEach(r => {
                if (r === currentType) currentLength++;
                else { streaks.push({ type: currentType, length: currentLength }); currentType = r; currentLength = 1; }
            });
            streaks.push({ type: currentType, length: currentLength });
            sequenceDiv.innerHTML = streaks.map(s => `<span class="streak-number ${s.type === 1 ? 'correct' : 'incorrect'}">${s.length}</span>`).join('');
        }
        function updateStreakPredictionStatsChart() {
            const stats = analyzer.streakPredictionTracker.getStats();
            const chartDiv = document.getElementById('streakStatsChart');
            if (stats.total === 0) { chartDiv.innerHTML = '<div style="text-align: center; color: #888; width: 100%;">Ch∆∞a c√≥ d·ªØ li·ªáu</div>'; return; }
            chartDiv.innerHTML = `
                <div class="stats-chart-bar-wrapper"><div class="stats-chart-bar"><div class="stats-chart-fill correct" style="height: ${stats.correctPercent.toFixed(1)}%;"></div></div><div class="stats-chart-label" style="color: #3498db;">ƒê√öNG</div><div class="stats-chart-value">${stats.correct} (${stats.correctPercent.toFixed(1)}%)</div></div>
                <div class="stats-chart-bar-wrapper"><div class="stats-chart-bar"><div class="stats-chart-fill incorrect" style="height: ${stats.incorrectPercent.toFixed(1)}%;"></div></div><div class="stats-chart-label" style="color: #e74c3c;">SAI</div><div class="stats-chart-value">${stats.incorrect} (${stats.incorrectPercent.toFixed(1)}%)</div></div>`;
        }
        function updatePredictions(prediction) {
            document.getElementById('playerProb').textContent = prediction.P.toFixed(1) + '%';
            document.getElementById('bankerProb').textContent = prediction.B.toFixed(1) + '%';
            document.getElementById('tieProb').textContent = prediction.T.toFixed(1) + '%';
            updateConfidenceBadge('playerConfidence', prediction.P);
            updateConfidenceBadge('bankerConfidence', prediction.B);
            updateConfidenceBadge('tieConfidence', prediction.T);
            document.querySelectorAll('.prediction-card').forEach(c => c.classList.remove('recommended'));
            const max = Math.max(prediction.P, prediction.B, prediction.T);
            if (max > 40) {
                if (max === prediction.P) document.getElementById('predPlayer').classList.add('recommended');
                else if (max === prediction.B) document.getElementById('predBanker').classList.add('recommended');
                else if (max === prediction.T) document.getElementById('predTie').classList.add('recommended');
            }
        }
        function updateConfidenceBadge(id, value) {
            const badge = document.getElementById(id);
            badge.className = 'confidence-badge';
            if (value >= 50) { badge.classList.add('confidence-high'); badge.textContent = 'CAO'; }
            else if (value >= 35) { badge.classList.add('confidence-medium'); badge.textContent = 'TRUNG B√åNH'; }
            else { badge.classList.add('confidence-low'); badge.textContent = 'TH·∫§P'; }
        }
        function updatePatterns(patterns) {
            const grid = document.getElementById('patternGrid');
            const top = patterns.detected.sort((a, b) => b.confidence - a.confidence).slice(0, 6);
            if (top.length > 0) {
                grid.innerHTML = top.map(p => `<div class="pattern-card detected"><div class="pattern-name">${p.name}</div><div class="pattern-confidence">ƒê·ªô tin c·∫≠y: ${(p.confidence*100).toFixed(0)}%</div><div class="pattern-description">${p.description}</div></div>`).join('');
                document.getElementById('currentPattern').textContent = top[0].name;
            } else {
                grid.innerHTML = '<div class="pattern-card"><div class="pattern-name">ƒêang ph√¢n t√≠ch...</div></div>';
                document.getElementById('currentPattern').textContent = '-';
            }
        }
        function updateWarnings(warnings) {
            const system = document.getElementById('warningSystem');
            if (warnings.length > 0) {
                system.classList.add('active');
                document.getElementById('warningList').innerHTML = warnings.map(w => `<li>‚ö° ${w.name}: ${w.description}</li>`).join('');
            } else { system.classList.remove('active'); }
        }
        function updateMagicNumber(magic) {
            if (magic) {
                document.getElementById('magicPhase').textContent = magic.phase;
                document.getElementById('magicCycle').textContent = magic.cycle;
                const max = Math.max(magic.P, magic.B, magic.T);
                let pred = '-';
                if (max === magic.P) pred = 'PLAYER'; else if (max === magic.B) pred = 'BANKER'; else if (max === magic.T) pred = 'TIE';
                document.getElementById('magicPrediction').textContent = pred;
                document.getElementById('magicAccuracy').textContent = analyzer.magicNumber.getAccuracy().toFixed(1) + '%';
            }
        }
        function updateStreakPrediction(prediction) {
            const predDiv = document.getElementById('streakPrediction');
            const reasonDiv = document.getElementById('streakPredictionReason');
            predDiv.className = 'streak-prediction-result';
            switch(prediction.recommendation) {
                case 'ƒê√öNG': predDiv.classList.add('correct'); predDiv.textContent = 'ƒê√öNG'; break;
                case 'SAI': predDiv.classList.add('incorrect'); predDiv.textContent = 'SAI'; break;
                default: predDiv.classList.add('none'); predDiv.textContent = 'KH√îNG ƒê·ªÄ XU·∫§T'; break;
            }
            reasonDiv.textContent = prediction.reason;
        }

        document.addEventListener('DOMContentLoaded', () => {
            loadSessionsFromLocalStorage();
            loadSession(currentSessionIndex);
        });
    </script>
</body>
</html>
