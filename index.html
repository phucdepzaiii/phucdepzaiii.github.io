<!DOCTYPE html>

<html lang="vi">

<head>

<meta charset="UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>H·ªá Th·ªëng Ph√¢n T√≠ch C·∫ßu (Th·ªëng K√™ N√¢ng Cao)</title>

<script src="https://cdn.tailwindcss.com"></script>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

<style>

body {

font-family: 'Inter', sans-serif;

background-color: #111827; /* Tailwind gray-900 */

color: #F9FAFB; /* Tailwind gray-50 */

}

.btn {

transition: all 0.3s ease;

box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);

}

.btn:hover {

transform: translateY(-2px);

box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);

}

.btn:active {

transform: translateY(1px);

}

.card-glow-p {

box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);

}

.card-glow-b {

box-shadow: 0 0 20px rgba(239, 68, 68, 0.5);

}

.card-glow-certain {

box-shadow: 0 0 25px rgba(250, 204, 21, 0.7);

}

/* Big Road Styles */

#bigRoadDisplay {

display: grid;

grid-auto-flow: column;

grid-auto-columns: 2.5rem; /* 40px */

gap: 2px;

overflow-x: auto;

padding: 8px;

}

.road-col {

display: grid;

grid-auto-rows: 2.5rem; /* 40px */

gap: 2px;

}

.road-item {

width: 2.5rem; /* 40px */

height: 2.5rem; /* 40px */

border-radius: 9999px;

display: flex;

align-items: center;

justify-content: center;

font-weight: bold;

font-size: 1.125rem; /* 18px */

color: white;

animation: fadeIn 0.5s ease;

}

@keyframes fadeIn {

from { opacity: 0; transform: scale(0.8); }

to { opacity: 1; transform: scale(1); }

}

/* Added styles for highlighting */
.road-item.previous-hand {
¬† ¬† border: 3px solid #6B7280; /* gray-500 */
}
.road-item.current-hand {
¬† ¬† border: 3px solid #FBBF24; /* amber-400 */
¬† ¬† animation: pulse 1.5s infinite, fadeIn 0.5s ease;
}

@keyframes pulse {
¬† ¬† 0%, 100% {
¬† ¬† ¬† ¬† box-shadow: 0 0 10px rgba(250, 204, 21, 0.3);
¬† ¬† }
¬† ¬† 50% {
¬† ¬† ¬† ¬† box-shadow: 0 0 20px rgba(250, 204, 21, 0.8);
¬† ¬† }
}

/* NEW: More prominent highlighting effect */
.current-prediction-range {
    animation: pulse-bg-blue 1.5s infinite;
    border: 2px solid #60a5fa !important; /* blue-400 */
}

@keyframes pulse-bg-blue {
    0%, 100% {
        background-color: rgba(59, 130, 246, 0.3); /* blue-500 with opacity */
    }
    50% {
        background-color: rgba(59, 130, 246, 0.6); /* brighter blue-500 */
    }
}

.previous-prediction-range {
    animation: pulse-bg-gray 1.5s infinite;
    border: 2px solid #9ca3af !important; /* gray-400 */
}

@keyframes pulse-bg-gray {
    0%, 100% {
        background-color: rgba(107, 114, 128, 0.3); /* gray-500 with opacity */
    }
    50% {
        background-color: rgba(107, 114, 128, 0.6); /* brighter gray-500 */
    }
}


/* Session List Item Styles */
.session-item.active {
    background-color: #3b82f6; /* blue-500 */
    color: white;
}
.session-item.active .text-gray-400 {
    color: #bfdbfe; /* blue-200 */
}
.session-item {
    transition: background-color 0.2s ease-in-out;
}

/* Bar Chart for Confidence Stats */
.bar-chart-container {
    display: flex;
    gap: 2px;
    height: 24px;
    align-items: flex-end;
    overflow: hidden;
    padding-top: 4px;
}
.bar {
    flex-shrink: 0;
    width: 5px;
    border-radius: 1px;
    transition: all 0.3s ease;
}
.bar.win {
    height: 100%;
    background-color: #60a5fa; /* blue-400 */
}
.bar.loss {
    height: 40%;
    background-color: #f87171; /* red-400 */
}


</style>

</head>

<body class="p-4 md:p-8">



<div class="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-3 gap-6">



<!-- Left Column: Input & History -->

<div class="lg:col-span-2 space-y-6">

<!-- Header -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg text-center">

<h1 class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-red-400">H·ªá Th·ªëng Ph√¢n T√≠ch H√¨nh C·∫ßu</h1>

<p class="text-gray-400 mt-2">Ghi nh·ªõ - ƒê·ªëi chi·∫øu - Ph√°n ƒëo√°n</p>

</div>



<!-- Session Management -->
<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
    <div class="flex justify-between items-center mb-4">
        <h2 class="text-xl font-semibold text-blue-300">üìÅ Qu·∫£n L√Ω Phi√™n</h2>
        <div class="flex items-center">
            <input type="checkbox" id="selectAllCheckbox" class="h-4 w-4 rounded bg-gray-700 border-gray-600 text-blue-600 focus:ring-blue-500">
            <label for="selectAllCheckbox" class="ml-2 text-sm font-medium text-gray-300">Ch·ªçn t·∫•t c·∫£</label>
        </div>
    </div>

    <div id="sessionListContainer" class="space-y-1 bg-gray-900/50 p-2 rounded-lg max-h-48 overflow-y-auto mb-4 border border-gray-700">
        <!-- Session list will be dynamically inserted here -->
    </div>

    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
        <button onclick="createNewSession()" class="btn w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-4 rounded-lg">‚ûï M·ªõi</button>
        <button onclick="renameSession()" class="btn w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-4 rounded-lg">‚úèÔ∏è ƒê·ªïi T√™n</button>
        <button onclick="deleteSelectedSessions()" class="btn w-full bg-red-600 hover:bg-red-500 text-white font-bold py-3 px-4 rounded-lg">üóëÔ∏è X√≥a Ch·ªçn</button>
        <button onclick="deleteAllSessions()" class="btn w-full bg-red-800 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg">üí• X√≥a H·∫øt</button>
    </div>

    <!-- Import/Export -->
    <div class="flex flex-col sm:flex-row gap-4">
        <button onclick="exportData()" class="btn w-full bg-sky-600 hover:bg-sky-500 text-white font-bold py-3 px-4 rounded-lg">üì§ Xu·∫•t D·ªØ Li·ªáu</button>
        <button onclick="document.getElementById('fileInput').click()" class="btn w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-4 rounded-lg">üì• Nh·∫≠p D·ªØ Li·ªáu</button>
        <input type="file" id="fileInput" class="hidden" accept=".json" onchange="importData(event)">
    </div>
</div>



<!-- Input Section -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<h2 class="text-xl font-semibold mb-4 text-blue-300">üé≤ Nh·∫≠p K·∫øt Qu·∫£ V√°n Hi·ªán T·∫°i</h2>

<div class="grid grid-cols-2 gap-4 mb-4">

<button onclick="addResult('P')" class="btn bg-blue-600 hover:bg-blue-500 text-white font-bold py-6 rounded-lg text-2xl">

<span>üë§</span> PLAYER

</button>

<button onclick="addResult('B')" class="btn bg-red-600 hover:bg-red-500 text-white font-bold py-6 rounded-lg text-2xl">

<span>üè¶</span> BANKER

</button>

</div>

<div class="flex gap-4">

<button onclick="undoLast()" class="btn flex-1 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg">‚Ü©Ô∏è Ho√†n T√°c</button>

<button onclick="clearCurrentSessionHistory()" class="btn flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg">üóëÔ∏è X√≥a L·ªãch S·ª≠</button>

</div>

</div>


<!-- Analysis Settings -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<h2 class="text-xl font-semibold mb-4 text-purple-300">‚öôÔ∏è C√†i ƒê·∫∑t Ph√¢n T√≠ch (Th·ªß c√¥ng)</h2>

<p class="text-sm text-gray-400 mb-4">C√†i ƒë·∫∑t n√†y ch·ªâ ƒë∆∞·ª£c s·ª≠ d·ª•ng khi h·ªá th·ªëng ch∆∞a t√¨m th·∫•y chi·ªÅu d√†i c·∫ßu t·ªëi ∆∞u.</p>

<div class="space-y-4">

<div>

<label for="minPatternLength" class="block text-sm font-medium text-gray-300 mb-1">ƒê·ªô d√†i c·∫ßu t·ªëi thi·ªÉu ƒë·ªÉ so s√°nh</label>

<input type="number" id="minPatternLength" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-purple-500 focus:outline-none">

</div>

<div>

<label for="maxPatternLength" class="block text-sm font-medium text-gray-300 mb-1">ƒê·ªô d√†i c·∫ßu t·ªëi ƒëa ƒë·ªÉ so s√°nh</label>

<input type="number" id="maxPatternLength" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-purple-500 focus:outline-none">

</div>

<div>

<label for="minCertainOccurrences" class="block text-sm font-medium text-gray-300 mb-1">S·ªë l·∫ßn l·∫∑p l·∫°i t·ªëi thi·ªÉu cho "Tay Ch·∫Øc Ch·∫Øn"</label>

<input type="number" id="minCertainOccurrences" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-purple-500 focus:outline-none">

</div>

</div>

<button onclick="saveSettings()" class="btn w-full mt-6 bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-4 rounded-lg">L∆∞u C√†i ƒê·∫∑t</button>

</div>



<!-- History Display -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<div class="flex justify-between items-center mb-4">

<h2 class="text-xl font-semibold text-blue-300">üìú B·∫£ng C·∫ßu Big Road</h2>

<span class="text-gray-400 font-medium">T·ªïng: <span id="totalGames">0</span> v√°n</span>

</div>

<div class="bg-gray-900 rounded-lg min-h-[280px] border border-gray-700">

<div id="bigRoadDisplay">

<p class="text-gray-500 p-4">Ch∆∞a c√≥ k·∫øt qu·∫£...</p>

</div>

</div>

</div>

</div>



<!-- Right Column: Analysis & Stats -->

<div class="space-y-6">

<!-- Accuracy Stats -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<h2 class="text-xl font-semibold mb-4 text-green-300">üéØ Th·ªëng K√™ (Phi√™n Hi·ªán T·∫°i)</h2>

<div class="space-y-4">

<div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">

<span class="font-medium text-gray-300">T·ª∑ L·ªá Th·∫Øng</span>

<span id="accuracyRate" class="text-2xl font-bold text-green-400">0.0%</span>

</div>

<div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">

<span class="font-medium text-gray-300">Th·∫Øng / T·ªïng Ph√°n ƒêo√°n</span>

<div>

<span id="correctPredictions" class="text-lg font-semibold text-white">0</span>

<span class="text-gray-400">/</span>

<span id="totalPredictions" class="text-lg font-semibold text-white">0</span>

</div>

</div>

</div>

</div>



<!-- Global Accuracy Stats -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<h2 class="text-xl font-semibold mb-4 text-cyan-300">üåê Th·ªëng K√™ (To√†n C·ª•c)</h2>

<div class="space-y-4">

<div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">

<span class="font-medium text-gray-300">T·ª∑ L·ªá Th·∫Øng</span>

<span id="globalAccuracyRate" class="text-2xl font-bold text-cyan-400">0.0%</span>

</div>

<div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">

<span class="font-medium text-gray-300">Th·∫Øng / T·ªïng Ph√°n ƒêo√°n</span>

<div>

<span id="globalCorrectPredictions" class="text-lg font-semibold text-white">0</span>

<span class="text-gray-400">/</span>

<span id="globalTotalPredictions" class="text-lg font-semibold text-white">0</span>

</div>

</div>

</div>

</div>



<!-- Pattern Analysis -->

<div id="analysis-card" class="bg-gray-800 p-6 rounded-2xl shadow-lg transition-shadow duration-500">

<h2 class="text-xl font-semibold mb-4 text-yellow-300">üß† Ph√¢n T√≠ch & ƒê·ªÅ Xu·∫•t</h2>

<div id="analysisResult" class="space-y-4">

<p class="text-gray-400 text-center py-8">C·∫ßn √≠t nh·∫•t 10 k·∫øt qu·∫£ ƒë·ªÉ b·∫Øt ƒë·∫ßu ph√¢n t√≠ch...</p>

</div>

</div>


<!-- Confidence Stats Table -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<h2 class="text-xl font-semibold mb-2 text-blue-300">üìä Th·ªëng K√™ ƒê·ªô Tin C·∫≠y (Phi√™n Hi·ªán T·∫°i)</h2>

<div id="confidenceRecommendation" class="my-4 p-3 bg-gray-900 rounded-lg text-center"></div>

<div class="space-y-2" id="confidenceStatsTable">

<!-- Rows will be generated by JS -->

</div>

</div>



</div>

</div>



<script>

// --- CORE LOGIC: PATTERN MATCHER ---

class PatternMatcher {

constructor() {

this.MIN_HISTORY_FOR_ANALYSIS = 10;

this.MIN_PATTERN_LENGTH = 10;

this.MAX_PATTERN_LENGTH = 15;

this.MIN_CERTAIN_OCCURRENCES = 2; // Default value

}



calculateSimilarity(arr1, arr2) {

if (arr1.length !== arr2.length || arr1.length === 0) return 0;

const matches = arr1.filter((item, index) => item === arr2[index]).length;

return matches / arr1.length;

}



findPatternOccurrences(pattern, allHistory) {

const occurrences = [];

// This check is now more dynamic, so we rely on the calling function's length checks

// if (pattern.length < this.MIN_PATTERN_LENGTH) return occurrences;

const reversedPattern = [...pattern].reverse();



for (const session of allHistory) {

const sessionHistory = session.history || [];

if (sessionHistory.length < pattern.length + 1) continue;


for (let i = 0; i <= sessionHistory.length - pattern.length - 1; i++) {

const segment = sessionHistory.slice(i, i + pattern.length);

const nextResult = sessionHistory[i + pattern.length];

const similarity = this.calculateSimilarity(pattern, segment);


if (similarity >= 0.9) occurrences.push({ type: 'similar', next: nextResult, similarity });


const reverseSimilarity = this.calculateSimilarity(reversedPattern, segment);

if (reverseSimilarity >= 0.9) occurrences.push({ type: 'reversed', next: nextResult, similarity: reverseSimilarity });

}

}

return occurrences;

}



getPredictionForPattern(pattern, allHistoricalSessions) {

const occurrences = this.findPatternOccurrences(pattern, allHistoricalSessions);


if (occurrences.length === 0) {

return { prediction: null };

}



const votes = { P: 0, B: 0 };

occurrences.forEach(match => {

if (votes[match.next] !== undefined) votes[match.next] += match.similarity;

});



const totalVotes = votes.P + votes.B;

if (totalVotes === 0) {

return { prediction: null };

}


const predictedWinner = votes.P > votes.B ? 'P' : 'B';

const confidence = (Math.max(votes.P, votes.B) / totalVotes) * 100;


return { prediction: predictedWinner, confidence, votes, totalOccurrences: occurrences.length };

}


findCertainPrediction(currentHistory, allHistoricalSessions) {

for (let len = Math.min(this.MAX_PATTERN_LENGTH, currentHistory.length); len >= this.MIN_PATTERN_LENGTH; len--) {

const pattern = currentHistory.slice(-len);

const patternString = pattern.join('');

const occurrences = [];



for (const session of allHistoricalSessions) {

const sessionHistory = session.history || [];

if (sessionHistory.length < pattern.length + 1) continue;


for (let i = 0; i <= sessionHistory.length - pattern.length - 1; i++) {

const segment = sessionHistory.slice(i, i + pattern.length);

if (segment.join('') === patternString) {

const nextResult = sessionHistory[i + pattern.length];

occurrences.push(nextResult);

}

}

}



if (occurrences.length >= this.MIN_CERTAIN_OCCURRENCES && new Set(occurrences).size === 1) {

const predictedWinner = occurrences[0];

return {

prediction: predictedWinner,

recommendation: 'TAY CH·∫ÆC CH·∫ÆN',

analysisText: `T√¨m th·∫•y ${occurrences.length} l·∫ßn xu·∫•t hi·ªán ch√≠nh x√°c c·ªßa h√¨nh c·∫ßu n√†y trong l·ªãch s·ª≠.\nT·∫•t c·∫£ ƒë·ªÅu cho k·∫øt qu·∫£ ti·∫øp theo l√†: ${predictedWinner}`,

confidence: 100,

isCertain: true

};

}

}

return null;

}





analyzeCurrentStreak(currentHistory) {

if (currentHistory.length < 2) return { type: 'none', length: currentHistory.length };

const last = currentHistory[currentHistory.length - 1];

const secondLast = currentHistory[currentHistory.length - 2];

if (last === secondLast) {

let length = 0;

for (let i = currentHistory.length - 1; i >= 0; i--) {

if (currentHistory[i] === last) length++; else break;

}

return { type: 'b·ªát', length, value: last };

} else {

let length = 0;

for (let i = currentHistory.length - 1; i >= 1; i--) {

if (currentHistory[i] !== currentHistory[i-1]) length++; else break;

}

return { type: '1-1', length: length + 1 };

}

}



getPrediction(currentHistory, allHistoricalSessions, { optimalLength = null, lengthPerformance = {} } = {}) {

if (currentHistory.length < this.MIN_HISTORY_FOR_ANALYSIS) {

return { prediction: null, analysisText: `C·∫ßn √≠t nh·∫•t ${this.MIN_HISTORY_FOR_ANALYSIS} k·∫øt qu·∫£...`, confidence: 0, isCertain: false };

}


// --- NEW: Optimal Length Logic ---

if (optimalLength && currentHistory.length >= optimalLength) {

const pattern = currentHistory.slice(-optimalLength);

const result = this.getPredictionForPattern(pattern, allHistoricalSessions);

if (result.prediction) {

const perf = lengthPerformance[optimalLength] || { wins: 0, total: 0 };

const rate = perf.total > 0 ? (perf.wins / perf.total * 100).toFixed(1) : 'N/A';

// --- MODIFICATION START ---
let confidenceRangeTextOptimal = '';
if (result.confidence >= 50) {
¬† ¬† const ranges = [
¬† ¬† ¬† ¬† {min: 50, max: 60}, {min: 60, max: 70}, {min: 70, max: 80},
¬† ¬† ¬† ¬† {min: 80, max: 90}, {min: 90, max: 100}
¬† ¬† ];
¬† ¬† for (const range of ranges) {
¬† ¬† ¬† ¬† if (result.confidence >= range.min && (result.confidence < range.max || (range.max === 100 && result.confidence >= 100))) {
¬† ¬† ¬† ¬† ¬† ¬† confidenceRangeTextOptimal = `(Thu·ªôc kho·∫£ng ${range.min}%-${range.max}%)`;
¬† ¬† ¬† ¬† ¬† ¬† break;
¬† ¬† ¬† ¬† }
¬† ¬† }
}
const analysisText = `S·ª≠ d·ª•ng chi·ªÅu d√†i c·∫ßu t·ªëi ∆∞u: ${optimalLength} v√°n.\n(T·ª∑ l·ªá th·∫Øng c·ªßa chi·ªÅu d√†i n√†y: ${rate}% - ${perf.wins}/${perf.total})\n\nL·ªãch s·ª≠ cho th·∫•y:\n- PLAYER: ${result.votes.P.toFixed(1)} ƒëi·ªÉm\n- BANKER: ${result.votes.B.toFixed(1)} ƒëi·ªÉm\n\nüèÜ ƒê·ªô tin c·∫≠y: ${result.confidence.toFixed(1)}% ${confidenceRangeTextOptimal}`;
// --- MODIFICATION END ---

return {

prediction: result.prediction,

recommendation: 'THEO CHI·ªÄU D√ÄI T·ªêI ∆ØU',

analysisText,

confidence: result.confidence,

isCertain: false

};

}

}


// --- FALLBACK: Original Logic ---

const certainPrediction = this.findCertainPrediction(currentHistory, allHistoricalSessions);

if (certainPrediction) {

return certainPrediction;

}



const allMatches = [];

for (let len = Math.min(this.MAX_PATTERN_LENGTH, currentHistory.length); len >= this.MIN_PATTERN_LENGTH; len--) {

const pattern = currentHistory.slice(-len);

const occurrences = this.findPatternOccurrences(pattern, allHistoricalSessions);

if (occurrences.length > 0) {

allMatches.push(...occurrences);

break;

}

}



if (allMatches.length === 0) {

return { prediction: null, analysisText: 'Kh√¥ng t√¨m th·∫•y h√¨nh c·∫ßu t∆∞∆°ng t·ª± (ch·∫ø ƒë·ªô th·ªß c√¥ng).', confidence: 0, isCertain: false };

}



const votes = { P: 0, B: 0 };

allMatches.forEach(match => {

if (votes[match.next] !== undefined) votes[match.next] += match.similarity;

});



const totalVotes = votes.P + votes.B;

if (totalVotes === 0) {

return { prediction: null, analysisText: 'Kh√¥ng t√¨m th·∫•y h√¨nh c·∫ßu t∆∞∆°ng t·ª± (ch·∫ø ƒë·ªô th·ªß c√¥ng).', confidence: 0, isCertain: false };

}



const confidenceP = (votes.P / totalVotes) * 100;

const confidenceB = (votes.B / totalVotes) * 100;

const maxConfidence = Math.max(confidenceP, confidenceB);

const predictedWinner = votes.P > votes.B ? 'P' : 'B';



const analysisTextPrefix = `T√¨m th·∫•y ${allMatches.length} h√¨nh c·∫ßu t∆∞∆°ng t·ª±. L·ªãch s·ª≠ cho th·∫•y:\n- PLAYER: ${votes.P.toFixed(1)} ƒëi·ªÉm\n- BANKER: ${votes.B.toFixed(1)} ƒëi·ªÉm`;


const streakInfo = this.analyzeCurrentStreak(currentHistory);

let recommendation = '';

if (streakInfo.type === 'b·ªát' && predictedWinner === streakInfo.value) recommendation = `THEO C·∫¶U B·ªÜT (${streakInfo.value} x${streakInfo.length})`;

else if (streakInfo.type === 'b·ªát' && predictedWinner !== streakInfo.value) recommendation = `B·∫∫ C·∫¶U B·ªÜT (${streakInfo.value} x${streakInfo.length})`;

else if (streakInfo.type === '1-1' && predictedWinner !== currentHistory[currentHistory.length - 1]) recommendation = `THEO C·∫¶U 1-1 (D√†i ${streakInfo.length})`;

else if (streakInfo.type === '1-1' && predictedWinner === currentHistory[currentHistory.length - 1]) recommendation = `B·∫∫ C·∫¶U 1-1 (D√†i ${streakInfo.length})`;

else recommendation = `THEO PH√ÇN T√çCH L·ªäCH S·ª¨`;


// --- MODIFICATION START ---
let confidenceRangeTextFallback = '';
if (maxConfidence >= 50) {
¬† ¬† const ranges = [
¬† ¬† ¬† ¬† {min: 50, max: 60}, {min: 60, max: 70}, {min: 70, max: 80},
¬† ¬† ¬† ¬† {min: 80, max: 90}, {min: 90, max: 100}
¬† ¬† ];
¬† ¬† for (const range of ranges) {
¬† ¬† ¬† ¬† if (maxConfidence >= range.min && (maxConfidence < range.max || (range.max === 100 && maxConfidence >= 100))) {
¬† ¬† ¬† ¬† ¬† ¬† confidenceRangeTextFallback = `(Thu·ªôc kho·∫£ng ${range.min}%-${range.max}%)`;
¬† ¬† ¬† ¬† ¬† ¬† break;
¬† ¬† ¬† ¬† }
¬† ¬† }
}
const analysisText = `${analysisTextPrefix}\n\nüèÜ ƒê·ªô tin c·∫≠y: ${maxConfidence.toFixed(1)}% ${confidenceRangeTextFallback}`;
// --- MODIFICATION END ---
return { prediction: predictedWinner, recommendation, analysisText, confidence: maxConfidence, isCertain: false };

}

}



// --- GLOBAL STATE ---

let state = {

currentSessionId: null,

sessions: {},

matcher: new PatternMatcher(),

currentPrediction: null,

goldenRange: null

};

// For Shift-Click functionality
let lastCheckedSessionBox = null;


// --- STATS CALCULATION ---

function getPredictionStats(predictions) {
¬† ¬† const total = predictions.length;
¬† ¬† if (total === 0) return { rate: 0, correct: 0, total: 0 };
¬† ¬† const correct = predictions.filter(p => p.predicted === p.actual).length;
¬† ¬† return { rate: (correct / total) * 100, correct, total };
}





// --- UI UPDATE FUNCTIONS ---

function updateBigRoadUI() {

const history = state.sessions[state.currentSessionId]?.history || [];

const roadDiv = document.getElementById('bigRoadDisplay');

document.getElementById('totalGames').textContent = history.length;



if (history.length === 0) {

roadDiv.innerHTML = '<p class="text-gray-500 p-4">Ch∆∞a c√≥ k·∫øt qu·∫£...</p>';

roadDiv.style.display = 'block';

return;

}

roadDiv.style.display = 'grid';

roadDiv.innerHTML = '';



const columns = [];

if (history.length > 0) {

let currentCol = [history[0]];

for (let i = 1; i < history.length; i++) {

if (history[i] === history[i-1]) {

currentCol.push(history[i]);

} else {

columns.push(currentCol);

currentCol = [history[i]];

}

}

columns.push(currentCol);

}


let itemCounter = 0;
const totalLength = history.length;

columns.forEach(colData => {

const colDiv = document.createElement('div');

colDiv.className = 'road-col';

colData.forEach(item => {

const itemDiv = document.createElement('div');

const bgColor = item === 'P' ? 'bg-blue-600' : 'bg-red-600';


let highlightClass = '';
if (itemCounter === totalLength - 2) {
¬† ¬† highlightClass = ' previous-hand';
} else if (itemCounter === totalLength - 1) {
¬† ¬† highlightClass = ' current-hand';
}


itemDiv.className = `road-item ${bgColor}${highlightClass}`;

itemDiv.textContent = item;

colDiv.appendChild(itemDiv);
itemCounter++;
});

roadDiv.appendChild(colDiv);

});

roadDiv.scrollLeft = roadDiv.scrollWidth;

}



function updateAccuracyUI() {

const predictions = state.sessions[state.currentSessionId]?.predictions || [];

const stats = getPredictionStats(predictions);

document.getElementById('accuracyRate').textContent = `${stats.rate.toFixed(1)}%`;

document.getElementById('correctPredictions').textContent = stats.correct;

document.getElementById('totalPredictions').textContent = stats.total;

}



function updateGlobalAccuracyUI() {

const allPredictions = Object.values(state.sessions).flatMap(s => s.predictions || []);

const stats = getPredictionStats(allPredictions);

document.getElementById('globalAccuracyRate').textContent = `${stats.rate.toFixed(1)}%`;

document.getElementById('globalCorrectPredictions').textContent = stats.correct;

document.getElementById('globalTotalPredictions').textContent = stats.total;

}



function updateAnalysisUI() {

const session = state.sessions[state.currentSessionId] || { history: [], optimalLength: null, lengthPerformance: {} };

const currentHistory = session.history;

const allHistory = Object.values(state.sessions);



let { prediction, recommendation, analysisText, confidence, isCertain } = state.matcher.getPrediction(currentHistory, allHistory, {

optimalLength: session.optimalLength,

lengthPerformance: session.lengthPerformance

});


state.currentPrediction = { prediction, confidence };



let finalPrediction = prediction;

let finalRecommendation = recommendation;

let recommendationNote = '';



if (prediction && !isCertain) {

let isInGoldenRange = false;

if (state.goldenRange && confidence >= state.goldenRange.min && confidence <= state.goldenRange.max) {

isInGoldenRange = true;

}



if (isInGoldenRange) {

if (state.goldenRange.rate < 30) {

finalPrediction = prediction === 'P' ? 'B' : 'P';

finalRecommendation = `ƒê·ªÄ XU·∫§T NG∆Ø·ª¢C (T·ª∑ l·ªá th·∫•p)`;

recommendationNote = `<div class="mt-2 p-2 text-center bg-red-800 bg-opacity-50 rounded-lg text-sm text-red-300 font-semibold">‚ö†Ô∏è ƒê·∫£o ng∆∞·ª£c! Kho·∫£ng v√†ng (${state.goldenRange.min}-${state.goldenRange.max}%) c√≥ t·ª∑ l·ªá th·∫Øng ch·ªâ ${state.goldenRange.rate.toFixed(1)}%.</div>`;

} else {

recommendationNote = `<div class="mt-2 p-2 text-center bg-green-800 bg-opacity-50 rounded-lg text-sm text-green-300 font-semibold">‚ú® Ph√°n ƒëo√°n n√†y n·∫±m trong KHO·∫¢NG V√ÄNG!</div>`;

}

} else if (state.goldenRange) {

recommendationNote = `<div class="mt-2 p-2 text-center bg-yellow-800 bg-opacity-50 rounded-lg text-sm text-yellow-300 font-semibold">‚ö†Ô∏è C·∫©n tr·ªçng: Kh√¥ng thu·ªôc Kho·∫£ng V√†ng.</div>`;

}

}


const analysisResultDiv = document.getElementById('analysisResult');

const analysisCard = document.getElementById('analysis-card');

analysisCard.classList.remove('card-glow-p', 'card-glow-b', 'card-glow-certain');



let optimalLengthDisplay = '';

if (session.optimalLength) {

optimalLengthDisplay = `<div class="mb-4 p-3 bg-gray-900 rounded-lg text-center text-cyan-300 text-sm">

<span class="font-semibold">Chi·ªÅu d√†i c·∫ßu t·ªëi ∆∞u ƒëang √°p d·ª•ng:</span>

<span class="text-lg font-bold ml-2">${session.optimalLength}</span>

</div>`;

}



if (finalPrediction) {

let predictionBlockHTML = '';

if (isCertain) {

predictionBlockHTML = `

<div class="text-center bg-yellow-800 bg-opacity-50 py-6 rounded-lg border-2 border-yellow-400">

<p class="text-lg text-yellow-300 mb-2 animate-pulse">ƒê·ªÅ Xu·∫•t Ch·∫Øc Ch·∫Øn (L·ªãch s·ª≠):</p>

<p class="text-3xl font-extrabold text-yellow-300">${finalRecommendation}</p>

<p class="text-4xl font-bold mt-2">${finalPrediction === 'P' ? 'üë§ PLAYER' : 'üè¶ BANKER'}</p>

</div>

`;

analysisCard.classList.add('card-glow-certain');

} else {

predictionBlockHTML = `

<div class="text-center bg-gray-900 py-6 rounded-lg border-2 ${finalPrediction === 'P' ? 'border-blue-500' : 'border-red-500'}">

<p class="text-lg text-gray-400 mb-2">ƒê·ªÅ xu·∫•t:</p>

<p class="text-3xl font-extrabold ${finalPrediction === 'P' ? 'text-blue-400' : 'text-red-400'}">${finalRecommendation}</p>

<p class="text-4xl font-bold mt-2">${finalPrediction === 'P' ? 'üë§ PLAYER' : 'üè¶ BANKER'}</p>

${recommendationNote}

</div>

`;

analysisCard.classList.add(finalPrediction === 'P' ? 'card-glow-p' : 'card-glow-b');

}



analysisResultDiv.innerHTML = `

${optimalLengthDisplay}

<div class="bg-gray-700 p-4 rounded-lg">

<p class="text-gray-300 whitespace-pre-wrap">${analysisText}</p>

</div>

${predictionBlockHTML}

`;



} else {

analysisResultDiv.innerHTML = `

${optimalLengthDisplay}

<p class="text-gray-400 text-center py-8 whitespace-pre-wrap">${analysisText}</p>

`;

}

}


function updateConfidenceStatsUI() {

if (!state.currentSessionId || !state.sessions[state.currentSessionId]) return;



const sessionPredictions = state.sessions[state.currentSessionId].predictions || [];

const ranges = [

{min: 50, max: 60, total: 0, wins: 0},

{min: 60, max: 70, total: 0, wins: 0},

{min: 70, max: 80, total: 0, wins: 0},

{min: 80, max: 90, total: 0, wins: 0},

{min: 90, max: 100, total: 0, wins: 0},

];



const tableDiv = document.getElementById('confidenceStatsTable');

const recommendationDiv = document.getElementById('confidenceRecommendation');

const currentConfidence = state.currentPrediction?.confidence;
const previousConfidence = sessionPredictions.length > 0 ? sessionPredictions[sessionPredictions.length - 1].confidence : null;


let bestRange = null;

let maxRate = -1;



ranges.forEach(range => {

const predictionsForRange = sessionPredictions.filter(p => {

const confidence = p.confidence;

return confidence >= range.min && (confidence < range.max || (range.max === 100 && confidence >= 100));

});


range.predictions = predictionsForRange; // Store predictions for the chart
range.total = predictionsForRange.length;

range.wins = predictionsForRange.filter(p => p.predicted === p.actual).length;

const rate = range.total > 0 ? ((range.wins / range.total) * 100) : -1;

range.rate = rate;


// Calculate trend

let trendIndicator = '';

let streak = 0;

if (predictionsForRange.length >= 1) {

const lastResultIsWin = (predictionsForRange[predictionsForRange.length - 1].predicted === predictionsForRange[predictionsForRange.length - 1].actual);

for (let i = predictionsForRange.length - 1; i >= 0; i--) {

const currentResultIsWin = (predictionsForRange[i].predicted === predictionsForRange[i].actual);

if (currentResultIsWin === lastResultIsWin) {

streak++;

} else {

break;

}

}



if (streak >= 1) {

if (lastResultIsWin) {

trendIndicator = `<span class="flex items-center text-blue-400 ml-1.5">

<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z" clip-rule="evenodd"></path></svg>

<span class="font-bold text-xs">${streak}</span>

</span>`;

} else {

trendIndicator = `<span class="flex items-center text-red-400 ml-1.5">

<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>

<span class="font-bold text-xs">${streak}</span>

</span>`;

}

}

}

range.trendIndicator = trendIndicator;



if (range.total >= 3 && rate > maxRate) {

maxRate = rate;

bestRange = range;

}

});


state.goldenRange = bestRange;



if (bestRange) {

recommendationDiv.innerHTML = `<p class="text-sm text-yellow-300"><span class="font-bold">‚ú® Kho·∫£ng V√†ng (Phi√™n):</span> T·ª∑ l·ªá th·∫Øng cao nh·∫•t l√† <b class="text-blue-400">${maxRate.toFixed(1)}%</b> trong kho·∫£ng <b class="text-white">${bestRange.min}%-${bestRange.max}%</b>.</p>`;

} else {

recommendationDiv.innerHTML = `<p class="text-sm text-gray-400">Ch∆∞a ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ t√¨m ra kho·∫£ng v√†ng cho phi√™n n√†y (c·∫ßn t·ªëi thi·ªÉu 3 ph√°n ƒëo√°n trong 1 kho·∫£ng).</p>`;

}



let html = `

<div class="grid gap-x-2 text-xs font-semibold text-gray-400 px-3" style="grid-template-columns: 4fr 2fr 2fr 4fr;">

<span class="text-left">Kho·∫£ng</span>

<span class="text-center">T·ªïng</span>

<span class="text-center">Th·∫Øng</span>

<span class="text-right">T·ª∑ L·ªá</span>

</div>

`;

if (sessionPredictions.length === 0 && !currentConfidence) {

tableDiv.innerHTML = '<p class="text-gray-500 text-center py-4">Ch∆∞a c√≥ d·ªØ li·ªáu th·ªëng k√™ cho phi√™n n√†y.</p>';

} else {

ranges.forEach(range => {

const rate = range.rate;

const isBest = range === bestRange;

let isCurrentPredictionRange = false;
if (currentConfidence) {
¬† ¬† if (currentConfidence >= range.min && (currentConfidence < range.max || (range.max === 100 && currentConfidence >= 100))) {
¬† ¬† ¬† ¬† isCurrentPredictionRange = true;
¬† ¬† }
}
let isPreviousPredictionRange = false;
if (previousConfidence) {
¬† ¬† if (previousConfidence >= range.min && (previousConfidence < range.max || (range.max === 100 && previousConfidence >= 100))) {
¬† ¬† ¬† ¬† isPreviousPredictionRange = true;
¬† ¬† }
}


// --- Build Bar Chart ---
let chartHtml = '';
if (range.predictions && range.predictions.length > 0) {
    chartHtml += '<div class="bar-chart-container mt-2">';
    range.predictions.forEach(p => {
        const resultClass = p.predicted === p.actual ? 'win' : 'loss';
        const title = `D·ª± ƒëo√°n: ${p.predicted}, Th·ª±c t·∫ø: ${p.actual}, ƒê·ªô tin c·∫≠y: ${p.confidence.toFixed(1)}%`;
        chartHtml += `<div class="bar ${resultClass}" title="${title}"></div>`;
    });
    chartHtml += '</div>';
}

// CORRECTED LOGIC: Prioritize current, but allow previous if not overlapping.
const rowHighlightClasses = [
    'p-3', 'rounded-lg', 'mt-2', 'transition-all', 'duration-300',
    ...(isBest ? ['bg-blue-800', 'bg-opacity-40', 'border', 'border-blue-500'] : ['bg-gray-700', 'bg-opacity-50']),
    ...(isCurrentPredictionRange ? ['current-prediction-range'] : 
        (isPreviousPredictionRange ? ['previous-prediction-range'] : [])
    )
].join(' ');


html += `
<div class="${rowHighlightClasses}">
    <div class="grid gap-x-2 items-center text-sm" style="grid-template-columns: 4fr 2fr 2fr 4fr;">
        <span class="font-medium text-gray-300 text-left">${range.min}%-${range.max}%</span>
        <span class="text-white font-semibold text-center">${range.total}</span>
        <span class="text-blue-400 font-semibold text-center">${range.wins}</span>
        <span class="font-bold flex items-center justify-end ${rate >= 70 ? 'text-blue-400' : (rate >= 50 ? 'text-yellow-400' : 'text-red-400')}">
            ${rate > -1 ? rate.toFixed(1) + '%' : '-'}
            ${range.trendIndicator}
        </span>
    </div>
    ${chartHtml}
</div>
`;

});

tableDiv.innerHTML = html;

}

}



function updateAllUI() {
updateSessionListUI();
updateBigRoadUI();
updateAccuracyUI();
updateGlobalAccuracyUI();
updateAnalysisUI();
updateConfidenceStatsUI();
}



// --- EVENT HANDLERS & ACTIONS ---

function addResult(result) {

if (!state.currentSessionId) return;

const session = state.sessions[state.currentSessionId];

const historyBeforeAdd = [...session.history];

const allSessions = Object.values(state.sessions);



// New logic: Update stats and find optimal length based on the result being added

const newOptimalLength = updateLengthPerformanceAndFindOptimal(historyBeforeAdd, allSessions, result);

session.optimalLength = newOptimalLength;



// Original logic: Store the last prediction vs actual result

if (state.currentPrediction && state.currentPrediction.prediction) {

session.predictions.push({

predicted: state.currentPrediction.prediction,

actual: result,

confidence: state.currentPrediction.confidence

});

}

state.currentPrediction = null;



session.history.push(result);


saveSessions();

updateAllUI();

}



// --- NEW: Optimal Length Finder ---

function updateLengthPerformanceAndFindOptimal(history, allSessions, newResult) {

const session = state.sessions[state.currentSessionId];

if (!session.lengthPerformance) {

session.lengthPerformance = {};

}



const candidates = [];



for (let len = 10; len <= 20; len++) {

if (history.length < len) continue;



const pattern = history.slice(-len);

const { prediction } = state.matcher.getPredictionForPattern(pattern, allSessions);



if (prediction) {

// Initialize stats if not present

if (!session.lengthPerformance[len]) {

session.lengthPerformance[len] = { wins: 0, total: 0 };

}


// Update stats for this length based on its prediction for the newResult

const stats = session.lengthPerformance[len];

stats.total++;

if (prediction === newResult) {

stats.wins++;

}


// Check if this length is a candidate for being the new optimal

// A length is a candidate if its prediction for the previous hand matched the new result

if (prediction === newResult) {

candidates.push({

length: len,

rate: stats.wins / stats.total,

total: stats.total

});

}

}

}


if (candidates.length === 0) {

return session.optimalLength; // Keep the old one if no candidates found

}



// Sort by rate desc, then total desc

candidates.sort((a, b) => {

if (b.rate !== a.rate) {

return b.rate - a.rate;

}

return b.total - a.total;

});


return candidates[0].length; // The new optimal length

}



function undoLast() {

if (!state.currentSessionId || state.sessions[state.currentSessionId].history.length === 0) return;


// This is complex with the new logic, so a simple pop is best.

// Re-calculating optimal length on undo is too intensive.

state.sessions[state.currentSessionId].history.pop();


const predictions = state.sessions[state.currentSessionId].predictions;

if (predictions.length > 0) {

predictions.pop();

}


saveSessions();

updateAllUI();

}



function clearCurrentSessionHistory() {

if (!state.currentSessionId) return;

if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô l·ªãch s·ª≠ v√† th·ªëng k√™ c·ªßa phi√™n n√†y kh√¥ng?')) {

const session = state.sessions[state.currentSessionId];

session.history = [];

session.predictions = [];

session.lengthPerformance = {};

session.optimalLength = null;

saveSessions();

updateAllUI();

}

}



// --- SESSION MANAGEMENT ---

function getSessions() {

try {

return JSON.parse(localStorage.getItem('baccaratPatternSessions_v5')) || {};

} catch (e) { return {}; }

}



function saveSessions() {

localStorage.setItem('baccaratPatternSessions_v5', JSON.stringify(state.sessions));

localStorage.setItem('lastActiveSession_v5', state.currentSessionId);

}

function updateSessionListUI() {
    const container = document.getElementById('sessionListContainer');
    container.innerHTML = '';
    const sortedKeys = Object.keys(state.sessions).sort((a, b) => parseInt(b.split('-')[1]) - parseInt(a.split('-')[1]));

    if (sortedKeys.length === 0) {
        container.innerHTML = '<p class="text-center text-gray-500 p-4">Kh√¥ng c√≥ phi√™n n√†o.</p>';
        return;
    }

    sortedKeys.forEach((sessionId) => {
        const session = state.sessions[sessionId];
        const isActive = sessionId === state.currentSessionId;

        const itemDiv = document.createElement('div');
        itemDiv.className = `session-item flex items-center justify-between p-2 rounded-md hover:bg-gray-700 cursor-pointer ${isActive ? 'active' : 'bg-gray-800'}`;
        itemDiv.dataset.sessionId = sessionId;

        itemDiv.innerHTML = `
            <div class="flex items-center gap-3">
                <input type="checkbox" onclick="event.stopPropagation()" class="session-checkbox h-5 w-5 rounded bg-gray-600 border-gray-500 text-blue-500 focus:ring-blue-600 focus:ring-offset-gray-800 shrink-0">
                <div class="flex flex-col">
                    <span class="font-semibold text-sm">${session.name}</span>
                    <span class="text-xs text-gray-400">${session.history.length} v√°n</span>
                </div>
            </div>
            ${isActive ? `<span class="text-xs font-bold bg-gray-900/50 px-2 py-1 rounded-full">ƒêang ch·ªçn</span>` : ''}
        `;
        container.appendChild(itemDiv);
    });
    lastCheckedSessionBox = null;
    document.getElementById('selectAllCheckbox').checked = false;
}


function renameSession() {
    if (!state.currentSessionId) return;
    const currentName = state.sessions[state.currentSessionId].name;
    const newName = prompt("Nh·∫≠p t√™n m·ªõi cho phi√™n ƒëang ho·∫°t ƒë·ªông:", currentName);
    if (newName && newName.trim() !== "") {
        state.sessions[state.currentSessionId].name = newName.trim();
        saveSessions();
        updateSessionListUI();
    }
}

function deleteSelectedSessions() {
    const selectedIds = [...document.querySelectorAll('.session-checkbox:checked')]
        .map(cb => cb.closest('.session-item').dataset.sessionId);

    if (selectedIds.length === 0) {
        alert('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt phi√™n ƒë·ªÉ x√≥a.');
        return;
    }

    const totalSessions = Object.keys(state.sessions).length;
    if (selectedIds.length >= totalSessions) {
        alert('Kh√¥ng th·ªÉ x√≥a t·∫•t c·∫£ c√°c phi√™n. S·ª≠ d·ª•ng n√∫t "X√≥a H·∫øt" ho·∫∑c gi·ªØ l·∫°i √≠t nh·∫•t m·ªôt phi√™n.');
        return;
    }

    if (confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a ${selectedIds.length} phi√™n ƒë√£ ch·ªçn kh√¥ng?`)) {
        let activeSessionDeleted = false;
        selectedIds.forEach(id => {
            if (id === state.currentSessionId) {
                activeSessionDeleted = true;
            }
            delete state.sessions[id];
        });

        if (activeSessionDeleted) {
            const remainingKeys = Object.keys(state.sessions).sort((a, b) => parseInt(b.split('-')[1]) - parseInt(a.split('-')[1]));
            state.currentSessionId = remainingKeys.length > 0 ? remainingKeys[0] : null;
        }
        
        if (!state.currentSessionId && Object.keys(state.sessions).length === 0) {
             initializeApp();
        } else {
            saveSessions();
            loadSession(state.currentSessionId);
        }
    }
}

function deleteAllSessions() {
    if (confirm('B·∫†N C√ì CH·∫ÆC CH·∫ÆN MU·ªêN X√ìA T·∫§T C·∫¢ C√ÅC PHI√äN KH√îNG?\n\nH√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.')) {
        state.sessions = {};
        state.currentSessionId = null;
        localStorage.removeItem('baccaratPatternSessions_v5');
        localStorage.removeItem('lastActiveSession_v5');
        initializeApp();
    }
}


function createNewSession() {

const newId = `session-${Date.now()}`;

state.currentSessionId = newId;

state.sessions[newId] = {

name: `Phi√™n ${new Date().toLocaleString('vi-VN')}`,

history: [],

predictions: [],

lengthPerformance: {},

optimalLength: null

};

saveSessions();

updateAllUI();

}

function loadSession(sessionId) {
    if (state.sessions[sessionId]) {
        state.currentSessionId = sessionId;
        state.currentPrediction = null;
        localStorage.setItem('lastActiveSession_v5', state.currentSessionId);
        updateAllUI();
    }
}


// --- SETTINGS ---

function saveSettings() {

const settings = {

minPatternLength: document.getElementById('minPatternLength').value,

maxPatternLength: document.getElementById('maxPatternLength').value,

minCertainOccurrences: document.getElementById('minCertainOccurrences').value

};

localStorage.setItem('baccaratSettings_v1', JSON.stringify(settings));

applySettings(settings);

alert('C√†i ƒë·∫∑t ƒë√£ ƒë∆∞·ª£c l∆∞u!');

updateAnalysisUI(); // Re-run analysis with new settings

}



function applySettings(settings) {

if (settings.minPatternLength) {

state.matcher.MIN_PATTERN_LENGTH = parseInt(settings.minPatternLength, 10);

}

if (settings.maxPatternLength) {

state.matcher.MAX_PATTERN_LENGTH = parseInt(settings.maxPatternLength, 10);

}

if (settings.minCertainOccurrences) {

state.matcher.MIN_CERTAIN_OCCURRENCES = parseInt(settings.minCertainOccurrences, 10);

}

}



function loadSettings() {

const settingsStr = localStorage.getItem('baccaratSettings_v1');

const settings = settingsStr ? JSON.parse(settingsStr) : {};


applySettings(settings);



document.getElementById('minPatternLength').value = state.matcher.MIN_PATTERN_LENGTH;

document.getElementById('maxPatternLength').value = state.matcher.MAX_PATTERN_LENGTH;

document.getElementById('minCertainOccurrences').value = state.matcher.MIN_CERTAIN_OCCURRENCES;

}



// --- IMPORT / EXPORT ---

function exportData() {

if (Object.keys(state.sessions).length === 0) {

alert("Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t.");

return;

}

const dataStr = JSON.stringify(state.sessions, null, 2);

const dataBlob = new Blob([dataStr], {type: "application/json"});

const url = URL.createObjectURL(dataBlob);

const link = document.createElement('a');

link.download = `baccarat_backup_${new Date().toISOString().slice(0,10)}.json`;

link.href = url;

link.click();

URL.revokeObjectURL(url);

}



function importData(event) {

const file = event.target.files[0];

if (!file) return;

const reader = new FileReader();

reader.onload = function(e) {

try {

const importedSessions = JSON.parse(e.target.result);

if (typeof importedSessions !== 'object' || importedSessions === null) throw new Error("Invalid format");


for(const key in importedSessions) {

const session = importedSessions[key];

if(!session.name || !Array.isArray(session.history)) {

throw new Error("Invalid session data");

}

// Add new fields if they don't exist in the imported file

if (!session.predictions) session.predictions = [];

if (!session.lengthPerformance) session.lengthPerformance = {};

if (session.optimalLength === undefined) session.optimalLength = null;

}



if (confirm('D·ªØ li·ªáu hi·ªán t·∫°i s·∫Ω b·ªã ghi ƒë√®. B·∫°n c√≥ ch·∫Øc mu·ªën ti·∫øp t·ª•c?')) {

state.sessions = importedSessions;

state.currentSessionId = null;

localStorage.removeItem('lastActiveSession_v5');

saveSessions();

initializeApp();

alert('Nh·∫≠p d·ªØ li·ªáu th√†nh c√¥ng!');

}

} catch (error) {

alert('L·ªói: File d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i file.');

console.error("Import error:", error);

} finally {

event.target.value = '';

}

};

reader.readAsText(file);

}


function setupEventListeners() {
    const container = document.getElementById('sessionListContainer');
    container.addEventListener('click', (e) => {
        const item = e.target.closest('.session-item');
        if (!item) return;

        const sessionId = item.dataset.sessionId;
        const checkbox = item.querySelector('.session-checkbox');

        // Check if the click was on the checkbox itself
        if (e.target.matches('.session-checkbox')) {
             if (e.shiftKey && lastCheckedSessionBox) {
                const allCheckboxes = [...container.querySelectorAll('.session-checkbox')];
                const start = allCheckboxes.indexOf(lastCheckedSessionBox);
                const end = allCheckboxes.indexOf(checkbox);
                const range = allCheckboxes.slice(Math.min(start, end), Math.max(start, end) + 1);
                range.forEach(box => box.checked = checkbox.checked);
            }
            lastCheckedSessionBox = checkbox;
        } else {
            // If clicked anywhere else, load the session
            loadSession(sessionId);
        }
    });

    document.getElementById('selectAllCheckbox').addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        document.querySelectorAll('.session-checkbox').forEach(box => {
            if (box.checked !== isChecked) {
                 box.checked = isChecked;
            }
        });
    });
}


function initializeApp() {

loadSettings();

state.sessions = getSessions();


// Ensure all loaded sessions have the new properties

Object.values(state.sessions).forEach(session => {

if (!session.lengthPerformance) session.lengthPerformance = {};

if (session.optimalLength === undefined) session.optimalLength = null;
if (!session.predictions) session.predictions = [];


});

setupEventListeners();


const lastActiveId = localStorage.getItem('lastActiveSession_v5');



if (Object.keys(state.sessions).length === 0) {

createNewSession();

} else {

const sortedKeys = Object.keys(state.sessions).sort((a, b) => parseInt(b.split('-')[1]) - parseInt(a.split('-')[1]));

const idToLoad = (lastActiveId && state.sessions[lastActiveId]) ? lastActiveId : sortedKeys[0];

loadSession(idToLoad);

}

}



// --- INITIALIZATION ---

document.addEventListener('DOMContentLoaded', initializeApp);

</script>

</body>

</html>

