<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hệ Thống Phân Tích Baccarat Pro 2.0 - Thuật Toán 142857 + Chu Kỳ Thông Minh</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(255, 215, 0, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(240, 84, 84, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(52, 152, 219, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 2;
        }

        /* Header Section */
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            font-size: 2.8em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #ffd700 0%, #f05454 25%, #667eea 50%, #4fd1c5 75%, #ffd700 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            animation: goldText 3s ease-in-out infinite;
        }

        @keyframes goldText {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        .disclaimer {
            color: #ffd700;
            font-size: 1.2em;
            padding: 12px 30px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 193, 7, 0.2));
            border-radius: 30px;
            border: 2px solid #ffd700;
            display: inline-block;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: goldShine 3s ease-in-out infinite;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        @keyframes goldShine {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }
            50% { transform: scale(1.05); box-shadow: 0 0 30px rgba(255, 215, 0, 0.5); }
        }

        /* ===== NEW: CYCLE ANALYSIS SECTION ===== */
        .cycle-analysis-section {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(78, 205, 196, 0.1));
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            border: 2px solid rgba(255, 107, 107, 0.3);
            position: relative;
            overflow: hidden;
        }

        .cycle-analysis-section::before {
            content: '🔄';
            position: absolute;
            top: -20px;
            right: 20px;
            font-size: 80px;
            opacity: 0.1;
        }

        .cycle-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .cycle-title {
            font-size: 1.5em;
            color: #ff6b6b;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .cycle-status {
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .cycle-main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .cycle-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.3s;
        }

        .cycle-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .cycle-label {
            font-size: 0.9em;
            color: #aaa;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .cycle-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .cycle-pattern {
            display: flex;
            gap: 5px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .pattern-item {
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .pattern-item.win {
            background: rgba(46, 204, 113, 0.3);
            color: #2ecc71;
        }

        .pattern-item.lose {
            background: rgba(231, 76, 60, 0.3);
            color: #e74c3c;
        }

        /* Final Decision Section */
        .final-decision {
            background: linear-gradient(135deg, rgba(155, 89, 182, 0.2), rgba(52, 152, 219, 0.2));
            border-radius: 20px;
            padding: 25px;
            margin-top: 20px;
            border: 2px solid #9b59b6;
            text-align: center;
        }

        .decision-title {
            font-size: 1.3em;
            color: #bb8fce;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .decision-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .decision-box {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .decision-box.recommended {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.15);
            animation: decisionPulse 2s infinite;
        }

        @keyframes decisionPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.4); }
            50% { box-shadow: 0 0 40px rgba(255, 215, 0, 0.7); }
        }

        .decision-action {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .decision-reason {
            font-size: 0.9em;
            color: #aaa;
        }

        /* Money Management Section */
        .money-management {
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.1), rgba(241, 196, 15, 0.1));
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            border: 2px solid rgba(46, 204, 113, 0.3);
        }

        .money-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .money-title {
            font-size: 1.5em;
            color: #2ecc71;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .money-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .money-input {
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: white;
            font-size: 1em;
            width: 200px;
        }

        .money-input:focus {
            outline: none;
            border-color: #2ecc71;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.3);
        }

        .money-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .money-stat {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }

        .money-stat-label {
            font-size: 0.85em;
            color: #999;
            margin-bottom: 5px;
        }

        .money-stat-value {
            font-size: 1.5em;
            font-weight: bold;
        }

        .money-stat-value.profit {
            color: #2ecc71;
        }

        .money-stat-value.loss {
            color: #e74c3c;
        }

        .betting-strategy {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .strategy-title {
            font-size: 1.1em;
            color: #f1c40f;
            margin-bottom: 15px;
        }

        .strategy-content {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .strategy-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        /* Accuracy Statistics Section */
        .accuracy-section {
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.1), rgba(39, 174, 96, 0.1));
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            border: 2px solid rgba(46, 204, 113, 0.3);
            position: relative;
            overflow: hidden;
        }

        .accuracy-section::before {
            content: '📊';
            position: absolute;
            top: -20px;
            right: 20px;
            font-size: 80px;
            opacity: 0.1;
        }

        .accuracy-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .accuracy-title {
            font-size: 1.5em;
            color: #2ecc71;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .accuracy-reset {
            padding: 8px 15px;
            background: rgba(231, 76, 60, 0.2);
            border: 2px solid #e74c3c;
            color: #ff6b6b;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s;
        }

        .accuracy-reset:hover {
            background: rgba(231, 76, 60, 0.3);
            transform: scale(1.05);
        }

        .accuracy-main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .accuracy-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.3s;
        }

        .accuracy-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .accuracy-label {
            font-size: 0.9em;
            color: #aaa;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .accuracy-value {
            font-size: 2.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .accuracy-value.excellent {
            color: #2ecc71;
        }

        .accuracy-value.good {
            color: #3498db;
        }

        .accuracy-value.average {
            color: #f39c12;
        }

        .accuracy-value.poor {
            color: #e74c3c;
        }

        .accuracy-change {
            font-size: 0.85em;
            color: #999;
        }

        .accuracy-change.positive {
            color: #2ecc71;
        }

        .accuracy-change.negative {
            color: #e74c3c;
        }

        .accuracy-details {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .accuracy-breakdown {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .breakdown-item {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .breakdown-type {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .breakdown-type.player {
            color: #3498db;
        }

        .breakdown-type.banker {
            color: #e74c3c;
        }

        .breakdown-type.tie {
            color: #27ae60;
        }

        .breakdown-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
        }

        .stat-label {
            color: #888;
            font-size: 0.85em;
        }

        .stat-value {
            font-weight: bold;
            color: #fff;
        }

        .accuracy-chart {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            height: 200px;
            position: relative;
            overflow: hidden;
        }

        .chart-bars {
            display: flex;
            align-items: flex-end;
            height: 150px;
            gap: 5px;
            padding: 10px;
        }

        .chart-bar {
            flex: 1;
            background: linear-gradient(180deg, #4fd1c5, #667eea);
            border-radius: 5px 5px 0 0;
            min-height: 5px;
            transition: all 0.3s;
            position: relative;
        }

        .chart-bar:hover {
            opacity: 0.8;
        }

        .chart-bar-label {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7em;
            color: #888;
        }

        .chart-bar-value {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
            color: #fff;
            font-weight: bold;
        }

        .accuracy-history {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
        }

        .history-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 0.9em;
        }

        .history-entry.correct {
            border-left: 3px solid #2ecc71;
        }

        .history-entry.incorrect {
            border-left: 3px solid #e74c3c;
        }

        .entry-number {
            color: #888;
            margin-right: 10px;
        }

        .entry-prediction {
            flex: 1;
        }

        .entry-actual {
            flex: 1;
        }

        .entry-result {
            padding: 2px 8px;
            border-radius: 5px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .entry-result.correct {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }

        .entry-result.incorrect {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        /* Warning System */
        .warning-system {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.2), rgba(192, 57, 43, 0.2));
            border: 2px solid #e74c3c;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
            display: none;
            animation: warningPulse 2s infinite;
        }

        .warning-system.active {
            display: block;
        }

        @keyframes warningPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(231, 76, 60, 0.5); }
            50% { box-shadow: 0 0 40px rgba(231, 76, 60, 0.8); }
        }

        .warning-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #ff6b6b;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .warning-icon {
            font-size: 1.5em;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.3; }
        }

        .warning-list {
            list-style: none;
            padding-left: 20px;
        }

        .warning-list li {
            margin: 8px 0;
            color: #ffcccc;
        }

        /* Pattern Recognition Display */
        .pattern-recognition {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .pattern-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
        }

        .pattern-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .pattern-card.detected {
            background: linear-gradient(135deg, rgba(79, 209, 197, 0.2), rgba(52, 152, 219, 0.2));
            border-color: #4fd1c5;
            animation: patternGlow 2s infinite;
        }

        @keyframes patternGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(79, 209, 197, 0.3); }
            50% { box-shadow: 0 0 20px rgba(79, 209, 197, 0.6); }
        }

        .pattern-name {
            font-weight: bold;
            color: #4fd1c5;
            margin-bottom: 5px;
        }

        .pattern-confidence {
            font-size: 0.9em;
            color: #aaa;
        }

        .pattern-description {
            font-size: 0.85em;
            color: #999;
            margin-top: 5px;
        }

        /* Confidence Score Display */
        .confidence-display {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .confidence-meter {
            position: relative;
            height: 40px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            overflow: hidden;
            margin: 20px 0;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12, #f1c40f, #2ecc71, #27ae60);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 15px;
            font-weight: bold;
            font-size: 1.1em;
        }

        .confidence-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            color: #999;
        }

        /* 142857 Algorithm Display */
        .algorithm-142857 {
            background: linear-gradient(135deg, rgba(155, 89, 182, 0.1), rgba(142, 68, 173, 0.1));
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            border: 2px solid #9b59b6;
            position: relative;
            overflow: hidden;
        }

        .algorithm-142857::before {
            content: "142857";
            position: absolute;
            top: -50px;
            right: -50px;
            font-size: 100px;
            font-weight: bold;
            color: rgba(155, 89, 182, 0.1);
            transform: rotate(25deg);
        }

        .algorithm-title {
            font-size: 1.5em;
            color: #bb8fce;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .magic-number {
            display: inline-block;
            padding: 5px 15px;
            background: rgba(155, 89, 182, 0.3);
            border-radius: 20px;
            font-family: monospace;
            font-size: 1.2em;
            margin: 0 5px;
            animation: magicPulse 3s infinite;
        }

        @keyframes magicPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .algorithm-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .algorithm-cell {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            border: 1px solid rgba(155, 89, 182, 0.3);
        }

        .algorithm-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #bb8fce;
        }

        .algorithm-label {
            font-size: 0.85em;
            color: #999;
            margin-top: 5px;
        }

        /* Input Controls */
        .input-section {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .main-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        button {
            padding: 15px 25px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1.1em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        .btn-player {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: 2px solid #3498db;
        }

        .btn-banker {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: 2px solid #e74c3c;
        }

        .btn-tie {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
            border: 2px solid #27ae60;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .stat-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.3s ease;
        }

        .stat-title {
            font-size: 0.95em;
            color: #b0b0b0;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            background: linear-gradient(135deg, #ffd700, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Prediction Section */
        .prediction-section {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(240, 84, 84, 0.1));
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .prediction-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .prediction-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .prediction-card.recommended {
            border-color: #ffd93d;
            background: rgba(255, 217, 61, 0.1);
            animation: pulse-glow 2s ease-in-out infinite;
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 217, 61, 0.3); }
            50% { box-shadow: 0 0 30px rgba(255, 217, 61, 0.6); }
        }

        .confidence-badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            margin-top: 10px;
        }

        .confidence-high {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
        }

        .confidence-medium {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
        }

        .confidence-low {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        #historyDisplay {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            min-height: 60px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .history-item {
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 0.95em;
            font-weight: 600;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .history-item.player-history {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .history-item.banker-history {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .history-item.tie-history {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
        }

        .secondary-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .btn-action {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            color: white;
            border: 2px solid #34495e;
            padding: 12px 20px;
            font-size: 1em;
        }

        .btn-action.warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            border: 2px solid #f39c12;
        }

        .section-title {
            font-size: 1.4em;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-title::before {
            content: '';
            width: 4px;
            height: 24px;
            background: linear-gradient(180deg, #667eea, #f05454);
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎰 BACCARAT PRO 2.0 - THUẬT TOÁN 142857 + CHU KỲ THÔNG MINH 🎰</h1>
            <p class="disclaimer">
                💎 HỆ THỐNG PHÂN TÍCH CHUYÊN NGHIỆP - 30+ MẪU CHUẨN + CHU KỲ AI 💎
            </p>
        </div>

        <!-- ===== NEW: CYCLE ANALYSIS SECTION ===== -->
        <div class="cycle-analysis-section">
            <div class="cycle-header">
                <div class="cycle-title">
                    🔄 PHÂN TÍCH CHU KỲ ĐÚNG/SAI HỆ THỐNG
                </div>
                <div class="cycle-status" id="cycleStatus">
                    Đang phân tích...
                </div>
            </div>
            
            <div class="cycle-main">
                <div class="cycle-card">
                    <div class="cycle-label">Chu Kỳ Hiện Tại</div>
                    <div class="cycle-value" id="currentCycle">-</div>
                    <div class="cycle-pattern" id="currentCyclePattern"></div>
                </div>
                
                <div class="cycle-card">
                    <div class="cycle-label">Max Thắng Liên Tiếp</div>
                    <div class="cycle-value" id="maxWinCycle">0</div>
                    <div class="cycle-pattern" id="maxWinPattern"></div>
                </div>
                
                <div class="cycle-card">
                    <div class="cycle-label">Max Thua Liên Tiếp</div>
                    <div class="cycle-value" id="maxLoseCycle">0</div>
                    <div class="cycle-pattern" id="maxLosePattern"></div>
                </div>
                
                <div class="cycle-card">
                    <div class="cycle-label">Pattern Phát Hiện</div>
                    <div class="cycle-value" id="detectedPattern">-</div>
                    <div class="cycle-pattern" id="patternDescription"></div>
                </div>
            </div>
            
            <div class="final-decision">
                <div class="decision-title">
                    ⚡ QUYẾT ĐỊNH CUỐI CÙNG (KẾT HỢP CHU KỲ)
                </div>
                <div class="decision-content">
                    <div class="decision-box" id="systemDecision">
                        <div class="decision-action">HỆ THỐNG</div>
                        <div class="decision-reason" id="systemPrediction">-</div>
                    </div>
                    <div class="decision-box" id="finalDecision">
                        <div class="decision-action">ĐỀ XUẤT CUỐI</div>
                        <div class="decision-reason" id="finalPrediction">-</div>
                    </div>
                    <div class="decision-box" id="actionDecision">
                        <div class="decision-action">HÀNH ĐỘNG</div>
                        <div class="decision-reason" id="actionAdvice">-</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== NEW: MONEY MANAGEMENT SECTION ===== -->
        <div class="money-management">
            <div class="money-header">
                <div class="money-title">
                    💰 QUẢN LÝ VỐN THÔNG MINH
                </div>
            </div>
            
            <div class="money-controls">
                <input type="number" class="money-input" id="initialCapital" placeholder="Vốn ban đầu" value="1000000">
                <input type="number" class="money-input" id="baseBet" placeholder="Mức cược cơ bản" value="10000">
                <button class="btn-action" onclick="resetMoney()">🔄 Reset Vốn</button>
            </div>
            
            <div class="money-stats">
                <div class="money-stat">
                    <div class="money-stat-label">Vốn Hiện Tại</div>
                    <div class="money-stat-value" id="currentCapital">1,000,000</div>
                </div>
                <div class="money-stat">
                    <div class="money-stat-label">Lời/Lỗ</div>
                    <div class="money-stat-value" id="profitLoss">0</div>
                </div>
                <div class="money-stat">
                    <div class="money-stat-label">% Lời/Lỗ</div>
                    <div class="money-stat-value" id="profitPercent">0%</div>
                </div>
                <div class="money-stat">
                    <div class="money-stat-label">Cược Đề Xuất</div>
                    <div class="money-stat-value" id="suggestedBet">10,000</div>
                </div>
                <div class="money-stat">
                    <div class="money-stat-label">Max Drawdown</div>
                    <div class="money-stat-value" id="maxDrawdown">0</div>
                </div>
                <div class="money-stat">
                    <div class="money-stat-label">Tổng Ván Cược</div>
                    <div class="money-stat-value" id="totalBets">0</div>
                </div>
            </div>
            
            <div class="betting-strategy">
                <div class="strategy-title">📊 Chiến Lược Cược Hiện Tại</div>
                <div class="strategy-content">
                    <div class="strategy-item">
                        <span>Phương pháp:</span>
                        <span id="strategyMethod">Kelly Criterion + Chu Kỳ</span>
                    </div>
                    <div class="strategy-item">
                        <span>Mức độ rủi ro:</span>
                        <span id="riskLevel">Trung Bình</span>
                    </div>
                    <div class="strategy-item">
                        <span>Gợi ý:</span>
                        <span id="strategyAdvice">Đợi chu kỳ rõ ràng</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Accuracy Statistics Section -->
        <div class="accuracy-section">
            <div class="accuracy-header">
                <div class="accuracy-title">
                    🎯 THỐNG KÊ ĐỘ CHÍNH XÁC HỆ THỐNG
                </div>
                <button class="accuracy-reset" onclick="resetAccuracyStats()">
                    🔄 Reset Thống Kê
                </button>
            </div>
            
            <div class="accuracy-main">
                <div class="accuracy-card">
                    <div class="accuracy-label">Độ Chính Xác Tổng</div>
                    <div class="accuracy-value" id="overallAccuracy">0%</div>
                    <div class="accuracy-change" id="accuracyTrend">-</div>
                </div>
                
                <div class="accuracy-card">
                    <div class="accuracy-label">Tổng Dự Đoán</div>
                    <div class="accuracy-value" id="totalPredictions">0</div>
                    <div class="accuracy-change">Đúng: <span id="correctPredictions">0</span></div>
                </div>
                
                <div class="accuracy-card">
                    <div class="accuracy-label">Chuỗi Thắng</div>
                    <div class="accuracy-value" id="winStreak">0</div>
                    <div class="accuracy-change">Max: <span id="maxWinStreak">0</span></div>
                </div>
                
                <div class="accuracy-card">
                    <div class="accuracy-label">ROI Giả Lập</div>
                    <div class="accuracy-value" id="simulatedROI">0%</div>
                    <div class="accuracy-change" id="roiTrend">-</div>
                </div>
            </div>
            
            <div class="accuracy-details">
                <h3 style="margin-bottom: 15px; color: #2ecc71;">📈 Phân Tích Chi Tiết</h3>
                
                <div class="accuracy-breakdown">
                    <div class="breakdown-item">
                        <div class="breakdown-type player">👤 PLAYER</div>
                        <div class="breakdown-stats">
                            <div class="stat-item">
                                <span class="stat-label">Dự đoán</span>
                                <span class="stat-value" id="playerPredCount">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Đúng</span>
                                <span class="stat-value" id="playerCorrect">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Tỷ lệ</span>
                                <span class="stat-value" id="playerAccuracy">0%</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="breakdown-item">
                        <div class="breakdown-type banker">🏦 BANKER</div>
                        <div class="breakdown-stats">
                            <div class="stat-item">
                                <span class="stat-label">Dự đoán</span>
                                <span class="stat-value" id="bankerPredCount">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Đúng</span>
                                <span class="stat-value" id="bankerCorrect">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Tỷ lệ</span>
                                <span class="stat-value" id="bankerAccuracy">0%</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="breakdown-item">
                        <div class="breakdown-type tie">🤝 TIE</div>
                        <div class="breakdown-stats">
                            <div class="stat-item">
                                <span class="stat-label">Dự đoán</span>
                                <span class="stat-value" id="tiePredCount">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Đúng</span>
                                <span class="stat-value" id="tieCorrect">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Tỷ lệ</span>
                                <span class="stat-value" id="tieAccuracy">0%</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="accuracy-chart">
                    <h4 style="margin-bottom: 10px; color: #aaa; font-size: 0.95em;">📊 Biểu đồ độ chính xác 10 ván gần nhất</h4>
                    <div class="chart-bars" id="accuracyChart"></div>
                </div>
                
                <div class="accuracy-history">
                    <h4 style="margin-bottom: 10px; color: #aaa; font-size: 0.95em;">📝 Lịch sử dự đoán gần đây</h4>
                    <div id="predictionHistory"></div>
                </div>
            </div>
        </div>

        <!-- Warning System -->
        <div class="warning-system" id="warningSystem">
            <div class="warning-title">
                <span class="warning-icon">⚠️</span>
                CẢNH BÁO MẪU NGUY HIỂM
            </div>
            <ul class="warning-list" id="warningList"></ul>
        </div>

        <!-- 142857 Algorithm Display -->
        <div class="algorithm-142857">
            <div class="algorithm-title">
                🔮 Thuật Toán Thần Số <span class="magic-number">142857</span>
            </div>
            <div class="algorithm-grid" id="algorithmDisplay">
                <div class="algorithm-cell">
                    <div class="algorithm-value" id="magicPhase">1</div>
                    <div class="algorithm-label">Pha Hiện Tại</div>
                </div>
                <div class="algorithm-cell">
                    <div class="algorithm-value" id="magicCycle">0</div>
                    <div class="algorithm-label">Chu Kỳ</div>
                </div>
                <div class="algorithm-cell">
                    <div class="algorithm-value" id="magicPrediction">-</div>
                    <div class="algorithm-label">Dự Đoán</div>
                </div>
                <div class="algorithm-cell">
                    <div class="algorithm-value" id="magicAccuracy">0%</div>
                    <div class="algorithm-label">Độ Chính Xác</div>
                </div>
            </div>
        </div>

        <!-- Confidence Display -->
        <div class="confidence-display">
            <h2 class="section-title">📊 Độ Tin Cậy Tổng Hợp</h2>
            <div class="confidence-meter">
                <div class="confidence-fill" id="confidenceFill" style="width: 0%">0%</div>
            </div>
            <div class="confidence-labels">
                <span>Rất Thấp</span>
                <span>Thấp</span>
                <span>Trung Bình</span>
                <span>Cao</span>
                <span>Rất Cao</span>
            </div>
        </div>

        <!-- Pattern Recognition -->
        <div class="pattern-recognition">
            <h2 class="section-title">🎯 Nhận Diện Mẫu Chuẩn</h2>
            <div class="pattern-grid" id="patternGrid"></div>
        </div>

        <!-- Input Section -->
        <div class="input-section">
            <h2 class="section-title">🎲 Nhập Kết Quả</h2>
            
            <div class="main-buttons">
                <button class="btn-player" onclick="addResult('P')">
                    <span style="font-size: 1.5em;">👤</span><br>
                    PLAYER
                </button>
                <button class="btn-banker" onclick="addResult('B')">
                    <span style="font-size: 1.5em;">🏦</span><br>
                    BANKER
                </button>
                <button class="btn-tie" onclick="addResult('T')">
                    <span style="font-size: 1.5em;">🤝</span><br>
                    TIE
                </button>
            </div>
            
            <div class="secondary-buttons">
                <button class="btn-action" onclick="undoLast()">↩️ Hoàn Tác</button>
                <button class="btn-action warning" onclick="clearHistory()">🗑️ Xóa Tất Cả</button>
                <button class="btn-action" onclick="generateRandom()">🎲 Demo (30 ván)</button>
            </div>
            
            <div id="historyDisplay"></div>
        </div>

        <!-- Stats Grid -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-title">📈 Tổng Ván</div>
                <div class="stat-value" id="totalGames">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">👤 Player Win</div>
                <div class="stat-value" id="playerRate">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">🏦 Banker Win</div>
                <div class="stat-value" id="bankerRate">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">🤝 Tie Rate</div>
                <div class="stat-value" id="tieRate">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">🔥 Streak</div>
                <div class="stat-value" id="currentStreak">-</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">📊 Pattern</div>
                <div class="stat-value" id="currentPattern">-</div>
            </div>
        </div>

        <!-- Prediction Section -->
        <div class="prediction-section">
            <h2 class="section-title">🔮 Dự Đoán AI</h2>
            <div class="prediction-grid">
                <div class="prediction-card" id="predPlayer">
                    <h3>👤 PLAYER</h3>
                    <div class="stat-value" id="playerProb">0%</div>
                    <div class="confidence-badge" id="playerConfidence">-</div>
                </div>
                <div class="prediction-card" id="predBanker">
                    <h3>🏦 BANKER</h3>
                    <div class="stat-value" id="bankerProb">0%</div>
                    <div class="confidence-badge" id="bankerConfidence">-</div>
                </div>
                <div class="prediction-card" id="predTie">
                    <h3>🤝 TIE</h3>
                    <div class="stat-value" id="tieProb">0%</div>
                    <div class="confidence-badge" id="tieConfidence">-</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== CYCLE ANALYZER CLASS =====
        class CycleAnalyzer {
            constructor() {
                this.systemResults = []; // W/L history of system predictions
                this.maxWinStreak = 0;
                this.maxLoseStreak = 0;
                this.currentStreak = 0;
                this.currentStreakType = null;
                this.patterns = [];
                this.cycleDetected = null;
                this.confidenceInCycle = 0;
            }

            addSystemResult(isCorrect) {
                this.systemResults.push(isCorrect ? 'W' : 'L');
                this.updateStreaks(isCorrect);
                this.detectPatterns();
            }

            updateStreaks(isCorrect) {
                const result = isCorrect ? 'W' : 'L';
                
                if (this.currentStreakType === result) {
                    this.currentStreak++;
                } else {
                    this.currentStreak = 1;
                    this.currentStreakType = result;
                }

                if (result === 'W') {
                    this.maxWinStreak = Math.max(this.maxWinStreak, this.currentStreak);
                } else {
                    this.maxLoseStreak = Math.max(this.maxLoseStreak, this.currentStreak);
                }
            }

            detectPatterns() {
                if (this.systemResults.length < 3) return;

                const recent = this.systemResults.slice(-20);
                
                // Pattern Detection
                this.patterns = [];
                
                // 1. Fixed cycle pattern (W-W-L, W-L-W-L, etc.)
                const cyclePattern = this.detectCyclePattern(recent);
                if (cyclePattern) {
                    this.patterns.push(cyclePattern);
                }

                // 2. Streak reversal pattern
                const streakReversal = this.detectStreakReversal(recent);
                if (streakReversal) {
                    this.patterns.push(streakReversal);
                }

                // 3. Mean reversion pattern
                const meanReversion = this.detectMeanReversion(recent);
                if (meanReversion) {
                    this.patterns.push(meanReversion);
                }

                // 4. Momentum pattern
                const momentum = this.detectMomentum(recent);
                if (momentum) {
                    this.patterns.push(momentum);
                }

                // Select strongest pattern
                if (this.patterns.length > 0) {
                    this.cycleDetected = this.patterns.reduce((prev, current) => 
                        prev.confidence > current.confidence ? prev : current
                    );
                    this.confidenceInCycle = this.cycleDetected.confidence;
                }
            }

            detectCyclePattern(data) {
                // Check for repeating patterns like WWL, WWWL, WL, etc.
                const patterns = [
                    { seq: ['W', 'W', 'L'], name: 'WWL Cycle' },
                    { seq: ['W', 'L'], name: 'WL Alternating' },
                    { seq: ['W', 'W', 'W', 'L'], name: 'WWWL Cycle' },
                    { seq: ['W', 'L', 'L'], name: 'WLL Cycle' },
                    { seq: ['L', 'L', 'W'], name: 'LLW Recovery' }
                ];

                for (let pattern of patterns) {
                    const patternLength = pattern.seq.length;
                    if (data.length < patternLength * 2) continue;

                    let matches = 0;
                    let checks = 0;

                    for (let i = 0; i <= data.length - patternLength; i += patternLength) {
                        const segment = data.slice(i, i + patternLength);
                        if (segment.length === patternLength) {
                            checks++;
                            if (segment.every((val, idx) => val === pattern.seq[idx])) {
                                matches++;
                            }
                        }
                    }

                    if (checks > 0 && matches / checks > 0.6) {
                        // Predict next in cycle
                        const position = data.length % patternLength;
                        const nextPredicted = pattern.seq[position];
                        
                        return {
                            type: 'cycle',
                            name: pattern.name,
                            confidence: matches / checks,
                            prediction: nextPredicted,
                            action: this.getAction(nextPredicted)
                        };
                    }
                }
                return null;
            }

            detectStreakReversal(data) {
                // After max streak, expect reversal
                if (this.currentStreakType === 'W' && this.currentStreak >= this.maxWinStreak - 1) {
                    return {
                        type: 'reversal',
                        name: 'Max Win Reversal',
                        confidence: 0.8,
                        prediction: 'L',
                        action: 'REVERSE'
                    };
                }
                
                if (this.currentStreakType === 'L' && this.currentStreak >= this.maxLoseStreak - 1) {
                    return {
                        type: 'reversal',
                        name: 'Max Loss Reversal',
                        confidence: 0.8,
                        prediction: 'W',
                        action: 'FOLLOW'
                    };
                }
                
                return null;
            }

            detectMeanReversion(data) {
                if (data.length < 10) return null;
                
                const winRate = data.filter(r => r === 'W').length / data.length;
                
                // If win rate is extreme, expect reversion
                if (winRate > 0.7) {
                    return {
                        type: 'mean_reversion',
                        name: 'High Win Reversion',
                        confidence: 0.7,
                        prediction: 'L',
                        action: 'REVERSE'
                    };
                }
                
                if (winRate < 0.3) {
                    return {
                        type: 'mean_reversion',
                        name: 'Low Win Recovery',
                        confidence: 0.7,
                        prediction: 'W',
                        action: 'FOLLOW'
                    };
                }
                
                return null;
            }

            detectMomentum(data) {
                if (data.length < 5) return null;
                
                const recent5 = data.slice(-5);
                const wins = recent5.filter(r => r === 'W').length;
                
                if (wins >= 4) {
                    return {
                        type: 'momentum',
                        name: 'Strong Win Momentum',
                        confidence: 0.65,
                        prediction: 'W',
                        action: 'FOLLOW'
                    };
                }
                
                if (wins <= 1) {
                    return {
                        type: 'momentum',
                        name: 'Strong Loss Momentum',
                        confidence: 0.65,
                        prediction: 'L',
                        action: 'REVERSE'
                    };
                }
                
                return null;
            }

            getAction(prediction) {
                // If predicting system will be wrong (L), reverse the system's decision
                // If predicting system will be right (W), follow the system's decision
                return prediction === 'W' ? 'FOLLOW' : 'REVERSE';
            }

            getFinalDecision(systemPrediction, confidence) {
                if (!this.cycleDetected || this.confidenceInCycle < 0.6) {
                    return {
                        decision: systemPrediction,
                        action: 'FOLLOW',
                        reason: 'Chu kỳ chưa rõ ràng',
                        shouldBet: false
                    };
                }

                const action = this.cycleDetected.action;
                let finalDecision = systemPrediction;
                
                if (action === 'REVERSE') {
                    // Reverse the system's prediction
                    if (systemPrediction === 'P') finalDecision = 'B';
                    else if (systemPrediction === 'B') finalDecision = 'P';
                    // Keep T as T
                }

                return {
                    decision: finalDecision,
                    action: action,
                    reason: this.cycleDetected.name,
                    confidence: this.cycleDetected.confidence,
                    shouldBet: this.confidenceInCycle >= 0.7
                };
            }
        }

        // ===== MONEY MANAGEMENT CLASS =====
        class MoneyManager {
            constructor(initialCapital = 1000000, baseBet = 10000) {
                this.initialCapital = initialCapital;
                this.currentCapital = initialCapital;
                this.baseBet = baseBet;
                this.betHistory = [];
                this.maxCapital = initialCapital;
                this.minCapital = initialCapital;
                this.totalBets = 0;
                this.totalWins = 0;
                this.totalLosses = 0;
            }

            calculateBet(confidence, cycleConfidence, finalDecision) {
                // Kelly Criterion modified for cycle analysis
                let betSize = this.baseBet;
                
                // Adjust based on confidence levels
                if (finalDecision.shouldBet) {
                    const combinedConfidence = (confidence * 0.4 + cycleConfidence * 0.6);
                    
                    if (combinedConfidence >= 0.8) {
                        betSize = this.baseBet * 2;
                    } else if (combinedConfidence >= 0.7) {
                        betSize = this.baseBet * 1.5;
                    } else if (combinedConfidence >= 0.6) {
                        betSize = this.baseBet;
                    } else {
                        betSize = this.baseBet * 0.5;
                    }
                }
                
                // Never bet more than 5% of capital
                const maxBet = this.currentCapital * 0.05;
                betSize = Math.min(betSize, maxBet);
                
                // Minimum bet protection
                if (this.currentCapital < this.initialCapital * 0.5) {
                    betSize = Math.min(betSize, this.baseBet * 0.5);
                }
                
                return Math.floor(betSize);
            }

            updateResult(betAmount, won, betType) {
                this.totalBets++;
                
                let profit = 0;
                if (won) {
                    this.totalWins++;
                    if (betType === 'T') {
                        profit = betAmount * 8; // Tie pays 8:1
                    } else {
                        profit = betAmount * 0.95; // House edge
                    }
                } else {
                    this.totalLosses++;
                    profit = -betAmount;
                }
                
                this.currentCapital += profit;
                this.maxCapital = Math.max(this.maxCapital, this.currentCapital);
                this.minCapital = Math.min(this.minCapital, this.currentCapital);
                
                this.betHistory.push({
                    bet: betAmount,
                    profit: profit,
                    capital: this.currentCapital,
                    type: betType,
                    won: won
                });
                
                if (this.betHistory.length > 100) {
                    this.betHistory.shift();
                }
            }

            getStats() {
                const profitLoss = this.currentCapital - this.initialCapital;
                const profitPercent = (profitLoss / this.initialCapital) * 100;
                const maxDrawdown = ((this.maxCapital - this.minCapital) / this.maxCapital) * 100;
                
                return {
                    currentCapital: this.currentCapital,
                    profitLoss: profitLoss,
                    profitPercent: profitPercent,
                    maxDrawdown: maxDrawdown,
                    totalBets: this.totalBets,
                    winRate: this.totalBets > 0 ? (this.totalWins / this.totalBets) * 100 : 0
                };
            }

            reset() {
                this.currentCapital = this.initialCapital;
                this.betHistory = [];
                this.maxCapital = this.initialCapital;
                this.minCapital = this.initialCapital;
                this.totalBets = 0;
                this.totalWins = 0;
                this.totalLosses = 0;
            }
        }

        // ===== ACCURACY TRACKING SYSTEM (Original) =====
        class AccuracyTracker {
            constructor() {
                this.predictions = [];
                this.results = [];
                this.currentPrediction = null;
                this.currentStreak = 0;
                this.maxStreak = 0;
                this.stats = {
                    P: { predicted: 0, correct: 0 },
                    B: { predicted: 0, correct: 0 },
                    T: { predicted: 0, correct: 0 }
                };
                this.last10Accuracy = [];
                this.roi = 100;
                this.roiHistory = [];
            }

            makePrediction(prediction) {
                if (this.currentPrediction) {
                    this.predictions.push(this.currentPrediction);
                    this.results.push(null);
                }
                
                const maxProb = Math.max(prediction.P, prediction.B, prediction.T);
                let predictedOutcome = null;
                
                if (maxProb > 35) {
                    if (maxProb === prediction.P) predictedOutcome = 'P';
                    else if (maxProb === prediction.B) predictedOutcome = 'B';
                    else if (maxProb === prediction.T) predictedOutcome = 'T';
                }
                
                this.currentPrediction = {
                    prediction: predictedOutcome,
                    probabilities: { ...prediction },
                    confidence: maxProb,
                    timestamp: Date.now()
                };
            }

            recordActualResult(actual) {
                if (!this.currentPrediction) return;
                
                const predicted = this.currentPrediction.prediction;
                const isCorrect = predicted === actual;
                
                this.predictions.push(this.currentPrediction);
                this.results.push(actual);
                
                if (predicted) {
                    this.stats[predicted].predicted++;
                    if (isCorrect) {
                        this.stats[predicted].correct++;
                        this.currentStreak++;
                        this.maxStreak = Math.max(this.maxStreak, this.currentStreak);
                    } else {
                        this.currentStreak = 0;
                    }
                }
                
                this.last10Accuracy.push(isCorrect ? 1 : 0);
                if (this.last10Accuracy.length > 10) {
                    this.last10Accuracy.shift();
                }
                
                this.updateROI(predicted, actual);
                this.currentPrediction = null;
                
                return isCorrect; // Return for cycle analyzer
            }

            updateROI(predicted, actual) {
                if (!predicted) return;
                
                const betAmount = 10;
                
                if (predicted === actual) {
                    if (actual === 'T') {
                        this.roi += betAmount * 8;
                    } else {
                        this.roi += betAmount * 0.95;
                    }
                } else {
                    this.roi -= betAmount;
                }
                
                this.roiHistory.push(this.roi);
                if (this.roiHistory.length > 100) {
                    this.roiHistory.shift();
                }
            }

            getOverallAccuracy() {
                const validPredictions = this.predictions.filter((p, i) => 
                    p.prediction && this.results[i] !== null
                );
                
                if (validPredictions.length === 0) return 0;
                
                let correct = 0;
                validPredictions.forEach((pred, i) => {
                    if (pred.prediction === this.results[i]) correct++;
                });
                
                return (correct / validPredictions.length) * 100;
            }

            getAccuracyByType(type) {
                if (this.stats[type].predicted === 0) return 0;
                return (this.stats[type].correct / this.stats[type].predicted) * 100;
            }

            getROIPercentage() {
                return ((this.roi - 100) / 100) * 100;
            }

            getRecentHistory(limit = 10) {
                const recent = [];
                const start = Math.max(0, this.predictions.length - limit);
                
                for (let i = start; i < this.predictions.length; i++) {
                    if (this.results[i] !== null && this.predictions[i].prediction) {
                        recent.push({
                            number: i + 1,
                            predicted: this.predictions[i].prediction,
                            actual: this.results[i],
                            correct: this.predictions[i].prediction === this.results[i],
                            confidence: this.predictions[i].confidence
                        });
                    }
                }
                
                return recent;
            }

            reset() {
                this.predictions = [];
                this.results = [];
                this.currentPrediction = null;
                this.currentStreak = 0;
                this.maxStreak = 0;
                this.stats = {
                    P: { predicted: 0, correct: 0 },
                    B: { predicted: 0, correct: 0 },
                    T: { predicted: 0, correct: 0 }
                };
                this.last10Accuracy = [];
                this.roi = 100;
                this.roiHistory = [];
            }
        }

        // ===== REST OF THE ORIGINAL CLASSES (MagicNumber142857, PatternRecognitionSystem, AdvancedBaccaratAnalyzer) =====
        // [Keep all original classes unchanged]
        
        class MagicNumber142857 {
            constructor() {
                this.base = 142857;
                this.sequence = [1, 4, 2, 8, 5, 7];
                this.phase = 0;
                this.cycle = 0;
                this.predictions = [];
                this.results = [];
            }

            getNextPhase() {
                this.phase = (this.phase + 1) % 6;
                if (this.phase === 0) this.cycle++;
                return this.sequence[this.phase];
            }

            calculatePrediction(history) {
                if (history.length < 3) return null;
                
                const currentPhase = this.sequence[this.phase];
                const multiplier = (currentPhase * this.base) % 1000000;
                
                const digits = multiplier.toString().split('').map(Number);
                const sum = digits.reduce((a, b) => a + b, 0);
                
                const playerWeight = (digits[0] + digits[2] + digits[4]) / sum;
                const bankerWeight = (digits[1] + digits[3] + digits[5]) / sum;
                const tieWeight = 1 - playerWeight - bankerWeight;
                
                const recentTrend = this.analyzeRecentTrend(history);
                
                return {
                    P: (playerWeight * 70 + recentTrend.P * 30),
                    B: (bankerWeight * 70 + recentTrend.B * 30),
                    T: Math.max(5, tieWeight * 100),
                    phase: currentPhase,
                    cycle: this.cycle
                };
            }

            analyzeRecentTrend(history) {
                const recent = history.slice(-7);
                const counts = { P: 0, B: 0, T: 0 };
                recent.forEach(r => counts[r]++);
                const total = recent.length || 1;
                
                return {
                    P: (counts.P / total) * 100,
                    B: (counts.B / total) * 100,
                    T: (counts.T / total) * 100
                };
            }

            updateAccuracy(prediction, actual) {
                if (!prediction) return;
                
                this.predictions.push(prediction);
                this.results.push(actual);
                
                if (this.predictions.length > 100) {
                    this.predictions.shift();
                    this.results.shift();
                }
            }

            getAccuracy() {
                if (this.predictions.length === 0) return 0;
                
                let correct = 0;
                for (let i = 0; i < this.predictions.length; i++) {
                    const pred = this.predictions[i];
                    const actual = this.results[i];
                    
                    const maxPred = Math.max(pred.P, pred.B, pred.T);
                    if ((maxPred === pred.P && actual === 'P') ||
                        (maxPred === pred.B && actual === 'B') ||
                        (maxPred === pred.T && actual === 'T')) {
                        correct++;
                    }
                }
                
                return (correct / this.predictions.length) * 100;
            }
        }

        class PatternRecognitionSystem {
            constructor() {
                this.patterns = {
                    'Dragon': { 
                        check: (h) => this.checkDragon(h), 
                        danger: false,
                        description: 'Chuỗi dài cùng kết quả (5+)'
                    },
                    'Baby Dragon': { 
                        check: (h) => this.checkBabyDragon(h), 
                        danger: false,
                        description: 'Chuỗi ngắn (3-4)'
                    },
                    'Ping Pong': { 
                        check: (h) => this.checkPingPong(h), 
                        danger: false,
                        description: 'Xen kẽ P-B-P-B'
                    },
                    'Choppy': { 
                        check: (h) => this.checkChoppy(h), 
                        danger: true,
                        description: 'Thay đổi liên tục, khó đoán'
                    },
                    'Trend': { 
                        check: (h) => this.checkTrend(h), 
                        danger: false,
                        description: 'Xu hướng rõ ràng P hoặc B'
                    }
                };
            }

            checkDragon(history) {
                if (history.length < 5) return { detected: false };
                const last5 = history.slice(-5);
                const allSame = last5.every(r => r === last5[0] && r !== 'T');
                return { 
                    detected: allSame, 
                    confidence: allSame ? 0.9 : 0,
                    next: allSame ? last5[0] : null
                };
            }

            checkBabyDragon(history) {
                if (history.length < 3) return { detected: false };
                const last4 = history.slice(-4);
                const last3 = history.slice(-3);
                
                const isBaby3 = last3.every(r => r === last3[0] && r !== 'T');
                const isBaby4 = last4.length === 4 && last4.every(r => r === last4[0] && r !== 'T');
                
                return { 
                    detected: isBaby3 || isBaby4, 
                    confidence: isBaby4 ? 0.8 : (isBaby3 ? 0.7 : 0),
                    next: isBaby3 ? last3[0] : (isBaby4 ? last4[0] : null)
                };
            }

            checkPingPong(history) {
                if (history.length < 4) return { detected: false };
                const last4 = history.slice(-4);
                const isPingPong = last4[0] !== last4[1] && 
                                  last4[1] !== last4[2] && 
                                  last4[2] !== last4[3] &&
                                  last4[0] === last4[2] &&
                                  last4[1] === last4[3] &&
                                  !last4.includes('T');
                return { 
                    detected: isPingPong, 
                    confidence: isPingPong ? 0.75 : 0,
                    next: isPingPong ? last4[0] : null
                };
            }

            checkChoppy(history) {
                if (history.length < 10) return { detected: false };
                const last10 = history.slice(-10);
                let changes = 0;
                for (let i = 1; i < last10.length; i++) {
                    if (last10[i] !== last10[i-1]) changes++;
                }
                const isChoppy = changes >= 7;
                return { 
                    detected: isChoppy, 
                    confidence: isChoppy ? 0.6 : 0,
                    next: null
                };
            }

            checkTrend(history) {
                if (history.length < 10) return { detected: false };
                const last10 = history.slice(-10).filter(r => r !== 'T');
                const pCount = last10.filter(r => r === 'P').length;
                const bCount = last10.filter(r => r === 'B').length;
                const isTrend = pCount >= 7 || bCount >= 7;
                return { 
                    detected: isTrend, 
                    confidence: isTrend ? 0.8 : 0,
                    next: pCount >= 7 ? 'P' : (bCount >= 7 ? 'B' : null)
                };
            }

            analyzePatterns(history) {
                const detected = [];
                const warnings = [];
                
                for (let patternName in this.patterns) {
                    const pattern = this.patterns[patternName];
                    const result = pattern.check(history);
                    
                    if (result.detected) {
                        detected.push({
                            name: patternName,
                            confidence: result.confidence,
                            next: result.next,
                            danger: pattern.danger,
                            description: pattern.description
                        });
                        
                        if (pattern.danger) {
                            warnings.push({
                                name: patternName,
                                description: pattern.description
                            });
                        }
                    }
                }
                
                return { detected, warnings };
            }
        }

        class AdvancedBaccaratAnalyzer {
            constructor() {
                this.magicNumber = new MagicNumber142857();
                this.patternSystem = new PatternRecognitionSystem();
                this.accuracyTracker = new AccuracyTracker();
                this.history = [];
                this.predictions = [];
                this.confidenceHistory = [];
            }

            addResult(result) {
                const isCorrect = this.accuracyTracker.recordActualResult(result);
                this.history.push(result);
                this.magicNumber.getNextPhase();
                return isCorrect; // Return for cycle analyzer
            }

            analyze() {
                if (this.history.length < 3) {
                    return {
                        prediction: { P: 33.3, B: 33.3, T: 33.3 },
                        confidence: 0,
                        patterns: { detected: [], warnings: [] },
                        magic: null
                    };
                }

                const patterns = this.patternSystem.analyzePatterns(this.history);
                const magicPred = this.magicNumber.calculatePrediction(this.history);
                
                let finalPrediction = { P: 0, B: 0, T: 0 };
                let weights = 0;
                
                if (magicPred) {
                    finalPrediction.P += magicPred.P * 0.3;
                    finalPrediction.B += magicPred.B * 0.3;
                    finalPrediction.T += magicPred.T * 0.3;
                    weights += 0.3;
                }
                
                patterns.detected.forEach(pattern => {
                    if (pattern.next && pattern.confidence > 0.6) {
                        const weight = pattern.confidence * 0.2;
                        if (pattern.next === 'P') finalPrediction.P += weight * 100;
                        if (pattern.next === 'B') finalPrediction.B += weight * 100;
                        weights += weight;
                    }
                });
                
                const statPred = this.getStatisticalPrediction();
                finalPrediction.P += statPred.P * 0.2;
                finalPrediction.B += statPred.B * 0.2;
                finalPrediction.T += statPred.T * 0.2;
                weights += 0.2;
                
                if (weights > 0) {
                    const total = finalPrediction.P + finalPrediction.B + finalPrediction.T;
                    finalPrediction.P = (finalPrediction.P / total) * 100;
                    finalPrediction.B = (finalPrediction.B / total) * 100;
                    finalPrediction.T = (finalPrediction.T / total) * 100;
                }
                
                this.accuracyTracker.makePrediction(finalPrediction);
                
                const confidence = this.calculateConfidence(patterns, magicPred);
                
                return {
                    prediction: finalPrediction,
                    confidence: confidence,
                    patterns: patterns,
                    magic: magicPred
                };
            }

            getStatisticalPrediction() {
                const recent = this.history.slice(-20).filter(r => ['P', 'B', 'T'].includes(r));
                const counts = { P: 0, B: 0, T: 0 };
                recent.forEach(r => counts[r]++);
                
                const total = recent.length || 1;
                const expected = total / 3;
                
                const prediction = {
                    P: 33.3 + (expected - counts.P) * 2,
                    B: 33.3 + (expected - counts.B) * 2,
                    T: 33.3 + (expected - counts.T) * 2
                };
                
                prediction.P = Math.max(5, Math.min(90, prediction.P));
                prediction.B = Math.max(5, Math.min(90, prediction.B));
                prediction.T = Math.max(5, Math.min(30, prediction.T));
                
                return prediction;
            }

            calculateConfidence(patterns, magicPred) {
                let confidence = 50;
                
                if (patterns.detected.length > 0) {
                    const avgPatternConf = patterns.detected.reduce((sum, p) => sum + p.confidence, 0) / patterns.detected.length;
                    confidence += avgPatternConf * 20;
                }
                
                confidence -= patterns.warnings.length * 10;
                
                if (magicPred) {
                    const accuracy = this.magicNumber.getAccuracy();
                    confidence += (accuracy - 50) * 0.5;
                }
                
                confidence += Math.min(20, this.history.length * 0.5);
                
                return Math.max(0, Math.min(100, confidence));
            }
        }

        // ===== GLOBAL VARIABLES =====
        let gameHistory = [];
        let analyzer = new AdvancedBaccaratAnalyzer();
        let cycleAnalyzer = new CycleAnalyzer();
        let moneyManager = new MoneyManager();
        let lastSystemPrediction = null;
        let lastFinalDecision = null;

        // ===== UI FUNCTIONS =====
        function addResult(result) {
            gameHistory.push(result);
            
            // Record system accuracy and update cycle analyzer
            const isCorrect = analyzer.addResult(result);
            
            // Update cycle analyzer with system result
            if (lastSystemPrediction && lastSystemPrediction === result) {
                cycleAnalyzer.addSystemResult(true);
            } else if (lastSystemPrediction) {
                cycleAnalyzer.addSystemResult(false);
            }
            
            // Update money if we made a bet
            if (lastFinalDecision && lastFinalDecision.shouldBet) {
                const betAmount = parseInt(document.getElementById('suggestedBet').textContent.replace(/,/g, ''));
                const won = (lastFinalDecision.decision === result);
                moneyManager.updateResult(betAmount, won, result);
            }
            
            updateDisplay();
            analyzeAndPredict();
            updateAccuracyStats();
            updateCycleAnalysis();
            updateMoneyManagement();
        }

        function updateCycleAnalysis() {
            const cycleData = cycleAnalyzer;
            
            // Update current cycle
            document.getElementById('currentCycle').textContent = 
                cycleData.currentStreakType ? `${cycleData.currentStreak} ${cycleData.currentStreakType}` : '-';
            
            // Update max streaks
            document.getElementById('maxWinCycle').textContent = cycleData.maxWinStreak;
            document.getElementById('maxLoseCycle').textContent = cycleData.maxLoseStreak;
            
            // Update pattern detection
            if (cycleData.cycleDetected) {
                document.getElementById('detectedPattern').textContent = cycleData.cycleDetected.name;
                document.getElementById('patternDescription').textContent = 
                    `Confidence: ${(cycleData.cycleDetected.confidence * 100).toFixed(0)}%`;
                document.getElementById('cycleStatus').textContent = 
                    cycleData.cycleDetected.action === 'REVERSE' ? '⚠️ ĐẢO NGƯỢC' : '✅ THEO HỆ THỐNG';
            } else {
                document.getElementById('detectedPattern').textContent = '-';
                document.getElementById('patternDescription').textContent = 'Đang phân tích...';
                document.getElementById('cycleStatus').textContent = 'Đang phân tích...';
            }
            
            // Update pattern display
            updateCyclePatternDisplay();
        }

        function updateCyclePatternDisplay() {
            const recent = cycleAnalyzer.systemResults.slice(-10);
            
            const currentPattern = document.getElementById('currentCyclePattern');
            currentPattern.innerHTML = recent.map(r => 
                `<span class="pattern-item ${r === 'W' ? 'win' : 'lose'}">${r}</span>`
            ).join('');
            
            // Show max win pattern
            if (cycleAnalyzer.maxWinStreak > 0) {
                const winPattern = document.getElementById('maxWinPattern');
                winPattern.innerHTML = Array(cycleAnalyzer.maxWinStreak).fill('')
                    .map(() => '<span class="pattern-item win">W</span>').join('');
            }
            
            // Show max lose pattern
            if (cycleAnalyzer.maxLoseStreak > 0) {
                const losePattern = document.getElementById('maxLosePattern');
                losePattern.innerHTML = Array(cycleAnalyzer.maxLoseStreak).fill('')
                    .map(() => '<span class="pattern-item lose">L</span>').join('');
            }
        }

        function updateMoneyManagement() {
            const stats = moneyManager.getStats();
            
            // Update display
            document.getElementById('currentCapital').textContent = 
                stats.currentCapital.toLocaleString('vi-VN');
            
            const plElement = document.getElementById('profitLoss');
            plElement.textContent = (stats.profitLoss >= 0 ? '+' : '') + 
                stats.profitLoss.toLocaleString('vi-VN');
            plElement.className = 'money-stat-value ' + (stats.profitLoss >= 0 ? 'profit' : 'loss');
            
            const ppElement = document.getElementById('profitPercent');
            ppElement.textContent = (stats.profitPercent >= 0 ? '+' : '') + 
                stats.profitPercent.toFixed(2) + '%';
            ppElement.className = 'money-stat-value ' + (stats.profitPercent >= 0 ? 'profit' : 'loss');
            
            document.getElementById('maxDrawdown').textContent = 
                stats.maxDrawdown.toFixed(2) + '%';
            
            document.getElementById('totalBets').textContent = stats.totalBets;
            
            // Update strategy advice based on performance
            updateStrategyAdvice(stats);
        }

        function updateStrategyAdvice(stats) {
            let method = 'Kelly Criterion + Chu Kỳ';
            let risk = 'Trung Bình';
            let advice = 'Đợi chu kỳ rõ ràng';
            
            // Adjust based on performance
            if (stats.profitPercent < -20) {
                method = 'Bảo thủ - Flat Betting';
                risk = 'Thấp';
                advice = 'Giảm cược, đợi cơ hội tốt';
            } else if (stats.profitPercent > 20) {
                method = 'Progressive + Chu Kỳ';
                risk = 'Cao';
                advice = 'Có thể tăng cược theo chu kỳ';
            }
            
            if (cycleAnalyzer.confidenceInCycle >= 0.7) {
                advice = 'CHU KỲ RÕ - NÊN CƯỢC!';
            } else if (cycleAnalyzer.confidenceInCycle >= 0.5) {
                advice = 'Chu kỳ đang hình thành';
            }
            
            document.getElementById('strategyMethod').textContent = method;
            document.getElementById('riskLevel').textContent = risk;
            document.getElementById('strategyAdvice').textContent = advice;
        }

        function resetMoney() {
            const initial = parseInt(document.getElementById('initialCapital').value) || 1000000;
            const base = parseInt(document.getElementById('baseBet').value) || 10000;
            
            moneyManager = new MoneyManager(initial, base);
            updateMoneyManagement();
        }

        function undoLast() {
            if (gameHistory.length > 0) {
                gameHistory.pop();
                analyzer.history.pop();
                
                // Reset analyzers
                cycleAnalyzer = new CycleAnalyzer();
                
                // Rebuild cycle history
                for (let i = 0; i < gameHistory.length; i++) {
                    const result = gameHistory[i];
                    const analysis = analyzer.analyze();
                    const systemPred = getSystemPrediction(analysis.prediction);
                    
                    if (i > 0 && systemPred) {
                        const isCorrect = (systemPred === result);
                        cycleAnalyzer.addSystemResult(isCorrect);
                    }
                }
                
                updateDisplay();
                analyzeAndPredict();
                updateAccuracyStats();
                updateCycleAnalysis();
            }
        }

        function clearHistory() {
            if (confirm('Xóa toàn bộ lịch sử?')) {
                gameHistory = [];
                analyzer = new AdvancedBaccaratAnalyzer();
                cycleAnalyzer = new CycleAnalyzer();
                lastSystemPrediction = null;
                lastFinalDecision = null;
                updateDisplay();
                analyzeAndPredict();
                updateAccuracyStats();
                updateCycleAnalysis();
            }
        }

        function generateRandom() {
            const options = ['P', 'B', 'T'];
            const weights = [0.45, 0.45, 0.1];
            
            for (let i = 0; i < 30; i++) {
                const random = Math.random();
                let result;
                if (random < weights[0]) result = 'P';
                else if (random < weights[0] + weights[1]) result = 'B';
                else result = 'T';
                
                addResult(result);
            }
        }

        function resetAccuracyStats() {
            if (confirm('Reset tất cả thống kê độ chính xác?')) {
                analyzer.accuracyTracker.reset();
                cycleAnalyzer = new CycleAnalyzer();
                updateAccuracyStats();
                updateCycleAnalysis();
            }
        }

        function updateAccuracyStats() {
            const tracker = analyzer.accuracyTracker;
            
            const overallAcc = tracker.getOverallAccuracy();
            const overallElem = document.getElementById('overallAccuracy');
            overallElem.textContent = overallAcc.toFixed(1) + '%';
            
            overallElem.classList.remove('excellent', 'good', 'average', 'poor');
            if (overallAcc >= 70) overallElem.classList.add('excellent');
            else if (overallAcc >= 55) overallElem.classList.add('good');
            else if (overallAcc >= 45) overallElem.classList.add('average');
            else overallElem.classList.add('poor');
            
            const totalPred = tracker.predictions.filter(p => p.prediction).length;
            document.getElementById('totalPredictions').textContent = totalPred;
            
            const correctPred = tracker.predictions.filter((p, i) => 
                p.prediction && p.prediction === tracker.results[i]
            ).length;
            document.getElementById('correctPredictions').textContent = correctPred;
            
            document.getElementById('winStreak').textContent = tracker.currentStreak;
            document.getElementById('maxWinStreak').textContent = tracker.maxStreak;
            
            const roi = tracker.getROIPercentage();
            const roiElem = document.getElementById('simulatedROI');
            roiElem.textContent = (roi > 0 ? '+' : '') + roi.toFixed(1) + '%';
            roiElem.classList.remove('excellent', 'good', 'average', 'poor');
            if (roi > 20) roiElem.classList.add('excellent');
            else if (roi > 5) roiElem.classList.add('good');
            else if (roi > -5) roiElem.classList.add('average');
            else roiElem.classList.add('poor');
            
            ['P', 'B', 'T'].forEach(type => {
                const stats = tracker.stats[type];
                document.getElementById(`${type.toLowerCase() === 'p' ? 'player' : 
                    type.toLowerCase() === 'b' ? 'banker' : 'tie'}PredCount`).textContent = stats.predicted;
                document.getElementById(`${type.toLowerCase() === 'p' ? 'player' : 
                    type.toLowerCase() === 'b' ? 'banker' : 'tie'}Correct`).textContent = stats.correct;
                const accuracy = tracker.getAccuracyByType(type);
                document.getElementById(`${type.toLowerCase() === 'p' ? 'player' : 
                    type.toLowerCase() === 'b' ? 'banker' : 'tie'}Accuracy`).textContent = accuracy.toFixed(1) + '%';
            });
            
            const trend = document.getElementById('accuracyTrend');
            if (tracker.last10Accuracy.length >= 2) {
                const recent = tracker.last10Accuracy.slice(-5);
                const older = tracker.last10Accuracy.slice(0, -5);
                const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
                const olderAvg = older.length > 0 ? older.reduce((a, b) => a + b, 0) / older.length : 0;
                
                if (recentAvg > olderAvg) {
                    trend.textContent = '↑ Đang cải thiện';
                    trend.classList.add('positive');
                    trend.classList.remove('negative');
                } else if (recentAvg < olderAvg) {
                    trend.textContent = '↓ Đang giảm';
                    trend.classList.add('negative');
                    trend.classList.remove('positive');
                } else {
                    trend.textContent = '→ Ổn định';
                    trend.classList.remove('positive', 'negative');
                }
            }
            
            const roiTrend = document.getElementById('roiTrend');
            if (tracker.roiHistory.length >= 10) {
                const recent = tracker.roiHistory.slice(-5);
                const older = tracker.roiHistory.slice(-10, -5);
                const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
                const olderAvg = older.reduce((a, b) => a + b, 0) / older.length;
                
                if (recentAvg > olderAvg) {
                    roiTrend.textContent = '↑ Tăng';
                    roiTrend.classList.add('positive');
                    roiTrend.classList.remove('negative');
                } else if (recentAvg < olderAvg) {
                    roiTrend.textContent = '↓ Giảm';
                    roiTrend.classList.add('negative');
                    roiTrend.classList.remove('positive');
                } else {
                    roiTrend.textContent = '→ Ổn định';
                    roiTrend.classList.remove('positive', 'negative');
                }
            }
            
            updateAccuracyChart();
            updatePredictionHistory();
        }

        function updateAccuracyChart() {
            const tracker = analyzer.accuracyTracker;
            const chartDiv = document.getElementById('accuracyChart');
            
            if (tracker.last10Accuracy.length === 0) {
                chartDiv.innerHTML = '<div style="text-align: center; color: #888;">Chưa có dữ liệu</div>';
                return;
            }
            
            const bars = tracker.last10Accuracy.map((acc, idx) => {
                const height = acc * 100;
                return `
                    <div class="chart-bar" style="height: ${height}%;">
                        <div class="chart-bar-value">${acc ? '✓' : '✗'}</div>
                        <div class="chart-bar-label">#${tracker.predictions.length - tracker.last10Accuracy.length + idx + 1}</div>
                    </div>
                `;
            }).join('');
            
            chartDiv.innerHTML = bars;
        }

        function updatePredictionHistory() {
            const tracker = analyzer.accuracyTracker;
            const historyDiv = document.getElementById('predictionHistory');
            const recentHistory = tracker.getRecentHistory(10);
            
            if (recentHistory.length === 0) {
                historyDiv.innerHTML = '<div style="text-align: center; color: #888;">Chưa có lịch sử dự đoán</div>';
                return;
            }
            
            const entries = recentHistory.reverse().map(entry => `
                <div class="history-entry ${entry.correct ? 'correct' : 'incorrect'}">
                    <span class="entry-number">#${entry.number}</span>
                    <span class="entry-prediction">Dự đoán: ${entry.predicted}</span>
                    <span class="entry-actual">Kết quả: ${entry.actual}</span>
                    <span class="entry-result ${entry.correct ? 'correct' : 'incorrect'}">
                        ${entry.correct ? 'ĐÚNG' : 'SAI'}
                    </span>
                </div>
            `).join('');
            
            historyDiv.innerHTML = entries;
        }

        function updateDisplay() {
            const historyDiv = document.getElementById('historyDisplay');
            historyDiv.innerHTML = gameHistory.map((result, index) => {
                let className = '';
                let text = '';
                
                switch(result) {
                    case 'P': 
                        className = 'player-history'; 
                        text = 'P'; 
                        break;
                    case 'B': 
                        className = 'banker-history'; 
                        text = 'B'; 
                        break;
                    case 'T': 
                        className = 'tie-history'; 
                        text = 'T'; 
                        break;
                }
                
                return `<span class="history-item ${className}">${index + 1}. ${text}</span>`;
            }).join('');

            updateStatistics();
        }

        function updateStatistics() {
            const mainResults = gameHistory.filter(r => ['P', 'B', 'T'].includes(r));
            const total = mainResults.length;
            
            const counts = { P: 0, B: 0, T: 0 };
            mainResults.forEach(r => counts[r]++);
            
            document.getElementById('totalGames').textContent = total;
            document.getElementById('playerRate').textContent = total > 0 ? 
                (counts.P / total * 100).toFixed(1) + '%' : '0%';
            document.getElementById('bankerRate').textContent = total > 0 ? 
                (counts.B / total * 100).toFixed(1) + '%' : '0%';
            document.getElementById('tieRate').textContent = total > 0 ? 
                (counts.T / total * 100).toFixed(1) + '%' : '0%';
            
            if (mainResults.length > 0) {
                let streak = 1;
                const lastResult = mainResults[mainResults.length - 1];
                for (let i = mainResults.length - 2; i >= 0; i--) {
                    if (mainResults[i] === lastResult) {
                        streak++;
                    } else {
                        break;
                    }
                }
                document.getElementById('currentStreak').textContent = `${streak} ${lastResult}`;
            } else {
                document.getElementById('currentStreak').textContent = '-';
            }
        }

        function getSystemPrediction(prediction) {
            const max = Math.max(prediction.P, prediction.B, prediction.T);
            if (max < 35) return null;
            
            if (max === prediction.P) return 'P';
            if (max === prediction.B) return 'B';
            if (max === prediction.T) return 'T';
            return null;
        }

        function analyzeAndPredict() {
            const analysis = analyzer.analyze();
            
            // Get system prediction
            const systemPred = getSystemPrediction(analysis.prediction);
            lastSystemPrediction = systemPred;
            
            // Get final decision based on cycle analysis
            const finalDecision = cycleAnalyzer.getFinalDecision(systemPred, analysis.confidence / 100);
            lastFinalDecision = finalDecision;
            
            // Update final decision display
            updateFinalDecision(systemPred, finalDecision);
            
            // Calculate suggested bet
            const suggestedBet = moneyManager.calculateBet(
                analysis.confidence / 100,
                cycleAnalyzer.confidenceInCycle,
                finalDecision
            );
            document.getElementById('suggestedBet').textContent = suggestedBet.toLocaleString('vi-VN');
            
            // Update predictions
            updatePredictions(analysis.prediction, analysis.confidence);
            
            // Update patterns
            updatePatterns(analysis.patterns);
            
            // Update warnings
            updateWarnings(analysis.patterns.warnings);
            
            // Update magic number display
            updateMagicNumber(analysis.magic);
            
            // Update confidence meter
            updateConfidenceMeter(analysis.confidence);
        }

        function updateFinalDecision(systemPred, finalDecision) {
            // Update system prediction
            document.getElementById('systemPrediction').textContent = 
                systemPred ? `Dự đoán: ${systemPred}` : 'Chưa có dự đoán';
            
            // Update final decision
            const finalBox = document.getElementById('finalDecision');
            const actionBox = document.getElementById('actionDecision');
            
            if (finalDecision.shouldBet) {
                finalBox.classList.add('recommended');
                document.getElementById('finalPrediction').textContent = 
                    `${finalDecision.decision} (${(finalDecision.confidence * 100).toFixed(0)}%)`;
                
                actionBox.classList.add('recommended');
                document.getElementById('actionAdvice').textContent = 
                    finalDecision.action === 'REVERSE' ? 
                    `ĐẢO NGƯỢC → ${finalDecision.decision}` : 
                    `THEO HT → ${finalDecision.decision}`;
            } else {
                finalBox.classList.remove('recommended');
                document.getElementById('finalPrediction').textContent = 'Đợi chu kỳ rõ';
                
                actionBox.classList.remove('recommended');
                document.getElementById('actionAdvice').textContent = 'KHÔNG CƯỢC';
            }
        }

        function updatePredictions(prediction, overallConfidence) {
            document.getElementById('playerProb').textContent = prediction.P.toFixed(1) + '%';
            document.getElementById('bankerProb').textContent = prediction.B.toFixed(1) + '%';
            document.getElementById('tieProb').textContent = prediction.T.toFixed(1) + '%';
            
            updateConfidenceBadge('playerConfidence', prediction.P);
            updateConfidenceBadge('bankerConfidence', prediction.B);
            updateConfidenceBadge('tieConfidence', prediction.T);
            
            const cards = document.querySelectorAll('.prediction-card');
            cards.forEach(card => card.classList.remove('recommended'));
            
            const max = Math.max(prediction.P, prediction.B, prediction.T);
            if (max > 40) {
                if (max === prediction.P) {
                    document.getElementById('predPlayer').classList.add('recommended');
                } else if (max === prediction.B) {
                    document.getElementById('predBanker').classList.add('recommended');
                } else if (max === prediction.T) {
                    document.getElementById('predTie').classList.add('recommended');
                }
            }
        }

        function updateConfidenceBadge(elementId, value) {
            const badge = document.getElementById(elementId);
            badge.classList.remove('confidence-high', 'confidence-medium', 'confidence-low');
            
            if (value >= 50) {
                badge.classList.add('confidence-high');
                badge.textContent = 'CAO';
            } else if (value >= 35) {
                badge.classList.add('confidence-medium');
                badge.textContent = 'TRUNG BÌNH';
            } else {
                badge.classList.add('confidence-low');
                badge.textContent = 'THẤP';
            }
        }

        function updatePatterns(patterns) {
            const grid = document.getElementById('patternGrid');
            
            const topPatterns = patterns.detected
                .sort((a, b) => b.confidence - a.confidence)
                .slice(0, 6);
            
            if (topPatterns.length > 0) {
                grid.innerHTML = topPatterns.map(pattern => `
                    <div class="pattern-card detected">
                        <div class="pattern-name">${pattern.name}</div>
                        <div class="pattern-confidence">Độ tin cậy: ${(pattern.confidence * 100).toFixed(0)}%</div>
                        <div class="pattern-description">${pattern.description}</div>
                    </div>
                `).join('');
                
                document.getElementById('currentPattern').textContent = topPatterns[0].name;
            } else {
                grid.innerHTML = '<div class="pattern-card"><div class="pattern-name">Đang phân tích...</div></div>';
                document.getElementById('currentPattern').textContent = '-';
            }
        }

        function updateWarnings(warnings) {
            const warningSystem = document.getElementById('warningSystem');
            const warningList = document.getElementById('warningList');
            
            if (warnings.length > 0) {
                warningSystem.classList.add('active');
                warningList.innerHTML = warnings.map(w => 
                    `<li>⚡ ${w.name}: ${w.description}</li>`
                ).join('');
            } else {
                warningSystem.classList.remove('active');
            }
        }

        function updateMagicNumber(magic) {
            if (magic) {
                document.getElementById('magicPhase').textContent = magic.phase;
                document.getElementById('magicCycle').textContent = magic.cycle;
                
                const maxPred = Math.max(magic.P, magic.B, magic.T);
                let prediction = '-';
                if (maxPred === magic.P) prediction = 'PLAYER';
                else if (maxPred === magic.B) prediction = 'BANKER';
                else if (maxPred === magic.T) prediction = 'TIE';
                
                document.getElementById('magicPrediction').textContent = prediction;
                document.getElementById('magicAccuracy').textContent = 
                    analyzer.magicNumber.getAccuracy().toFixed(1) + '%';
            } else {
                document.getElementById('magicPhase').textContent = '1';
                document.getElementById('magicCycle').textContent = '0';
                document.getElementById('magicPrediction').textContent = '-';
                document.getElementById('magicAccuracy').textContent = '0%';
            }
        }

        function updateConfidenceMeter(confidence) {
            const fill = document.getElementById('confidenceFill');
            fill.style.width = confidence + '%';
            fill.textContent = confidence.toFixed(0) + '%';
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            updateDisplay();
            analyzeAndPredict();
            updateAccuracyStats();
            updateCycleAnalysis();
            updateMoneyManagement();
        });
    </script>
</body>
</html>
