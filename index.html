<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> PH√öC ƒê·∫∏P TRAI- ƒê√ÅNH ƒê√ÇU TH·∫ÆNG ƒê√ì, MAY M·∫ÆN PH√ÅT T√ÄI.</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
            position: relative;
            overflow-x: hidden; /* Prevent horizontal scroll from decor */
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(255, 215, 0, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(240, 84, 84, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(52, 152, 219, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 1;
        }

        /* New Background Decor */
        .background-decor .han-char {
            position: fixed;
            font-size: 20vw;
            font-weight: bold;
            color: rgba(255, 215, 0, 0.04);
            z-index: 1;
            pointer-events: none;
            text-shadow: 0 0 40px rgba(255, 215, 0, 0.1);
            animation: floatChar 30s infinite linear alternate;
        }

        .background-decor .han-char:nth-child(1) {
            top: 5%;
            left: -5%;
        }

        .background-decor .han-char:nth-child(2) {
            bottom: 5%;
            right: -5%;
            animation-delay: -15s;
        }

        @keyframes floatChar {
            0% {
                transform: translateY(0px) rotate(0deg);
            }
            50% {
                transform: translateY(-30px) rotate(5deg);
            }
            100% {
                transform: translateY(0px) rotate(0deg);
            }
        }


        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 2;
        }

        /* Header Section */
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            font-size: 2.8em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #ffd700 0%, #f05454 25%, #667eea 50%, #4fd1c5 75%, #ffd700 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            animation: goldText 3s ease-in-out infinite;
        }

        @keyframes goldText {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        .disclaimer {
            color: #ffd700;
            font-size: 1.2em;
            padding: 12px 30px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 193, 7, 0.2));
            border-radius: 30px;
            border: 2px solid #ffd700;
            display: inline-block;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: goldShine 3s ease-in-out infinite;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        @keyframes goldShine {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }
            50% { transform: scale(1.05); box-shadow: 0 0 30px rgba(255, 215, 0, 0.5); }
        }
        
        /* New Lucky Phrases Styles */
        .lucky-phrases {
            margin-top: 25px;
            display: flex;
            justify-content: center;
            gap: 40px;
            flex-wrap: wrap;
        }

        .lucky-text {
            font-size: 1.3em;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: neonFlicker 5s infinite alternate;
        }

        .lucky-text-1 {
            color: #ffd700;
            text-shadow: 0 0 5px #ffd700, 0 0 10px #ffd700, 0 0 20px #ffd700, 0 0 30px #e74c3c;
        }

        .lucky-text-2 {
            color: #4fd1c5;
            text-shadow: 0 0 5px #4fd1c5, 0 0 10px #4fd1c5, 0 0 20px #4fd1c5, 0 0 30px #3498db;
            animation-delay: -2.5s;
        }

        @keyframes neonFlicker {
            0%, 100% {
                opacity: 1;
                filter: brightness(1.1);
            }
            50% {
                opacity: 0.8;
                filter: brightness(1);
            }
        }


        /* Accuracy Statistics Section */
        .accuracy-section {
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.1), rgba(39, 174, 96, 0.1));
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            border: 2px solid rgba(46, 204, 113, 0.3);
            position: relative;
            overflow: hidden;
        }

        .accuracy-section::before {
            content: 'üìä';
            position: absolute;
            top: -20px;
            right: 20px;
            font-size: 80px;
            opacity: 0.1;
        }

        .accuracy-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .accuracy-title {
            font-size: 1.5em;
            color: #2ecc71;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .accuracy-reset {
            padding: 8px 15px;
            background: rgba(231, 76, 60, 0.2);
            border: 2px solid #e74c3c;
            color: #ff6b6b;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s;
        }

        .accuracy-reset:hover {
            background: rgba(231, 76, 60, 0.3);
            transform: scale(1.05);
        }

        .accuracy-main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .accuracy-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.3s;
        }

        .accuracy-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .accuracy-label {
            font-size: 0.9em;
            color: #aaa;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .accuracy-value {
            font-size: 2.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .accuracy-value.excellent {
            color: #2ecc71;
        }

        .accuracy-value.good {
            color: #3498db;
        }

        .accuracy-value.average {
            color: #f39c12;
        }

        .accuracy-value.poor {
            color: #e74c3c;
        }

        .accuracy-change {
            font-size: 0.85em;
            color: #999;
        }

        .accuracy-change.positive {
            color: #2ecc71;
        }

        .accuracy-change.negative {
            color: #e74c3c;
        }

        .accuracy-details {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .accuracy-breakdown {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .breakdown-item {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .breakdown-type {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .breakdown-type.player {
            color: #3498db;
        }

        .breakdown-type.banker {
            color: #e74c3c;
        }

        .breakdown-type.tie {
            color: #27ae60;
        }

        .breakdown-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
        }

        .stat-label {
            color: #888;
            font-size: 0.85em;
        }

        .stat-value {
            font-weight: bold;
            color: #fff;
        }

        .accuracy-chart {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            height: 250px;
            position: relative;
            overflow-x: auto;
            overflow-y: hidden;
        }

        .chart-bars {
            display: flex;
            align-items: flex-end;
            height: 180px;
            gap: 4px;
            padding: 10px;
            min-width: 100%;
        }

        .chart-bar {
            flex: 0 0 25px; /* Reduced width for more bars */
            border-radius: 5px 5px 0 0;
            transition: all 0.3s;
            position: relative;
        }
        
        .chart-bar.bar-correct {
             background: linear-gradient(180deg, #3498db, #2980b9);
        }

        .chart-bar.bar-incorrect {
            background: linear-gradient(180deg, #e74c3c, #c0392b);
        }


        .chart-bar:hover {
            opacity: 0.8;
        }

        .chart-bar-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.65em;
            color: #888;
            white-space: nowrap;
        }

        .chart-bar-value {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75em;
            color: #fff;
            font-weight: bold;
        }
        
        .streak-sequence {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            min-height: 30px;
            align-items: center;
        }
        .streak-number {
            font-size: 1.2em;
            font-weight: bold;
        }
        .streak-number.correct {
            color: #3498db; /* Blue for correct streaks */
        }
        .streak-number.incorrect {
            color: #e74c3c; /* Red for incorrect streaks */
        }
        
        /* === MODIFIED: Styles for Streak Prediction === */
        .streak-prediction-result {
            padding: 15px 25px;
            border-radius: 15px;
            font-size: 1.5em; /* Adjusted size */
            font-weight: bold;
            display: inline-block;
            min-width: 250px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            color: #aaa;
        }
        .streak-prediction-result .prediction-value {
            font-size: 2em;
            color: #ffd700;
            margin: 0 10px;
        }
        .streak-prediction-reason {
            margin-top: 8px;
            font-size: 0.9em;
            color: #999;
            font-style: italic;
        }

        /* NEW: Styles for Streak Prediction Stats Chart */
        .stats-chart-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 10px;
        }
        .stats-chart-bar-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100px;
        }
        .stats-chart-bar {
            width: 50px;
            height: 100px;
            background-color: rgba(255,255,255,0.05);
            border-radius: 5px;
            display: flex;
            align-items: flex-end;
        }
        .stats-chart-fill {
            width: 100%;
            border-radius: 5px;
            transition: height 0.5s ease;
        }
        .stats-chart-fill.correct {
            background: linear-gradient(180deg, #3498db, #2980b9);
        }
        .stats-chart-fill.incorrect {
            background: linear-gradient(180deg, #e74c3c, #c0392b);
        }
        .stats-chart-label {
            margin-top: 8px;
            font-size: 0.9em;
            font-weight: bold;
        }
        .stats-chart-value {
            font-size: 0.8em;
            color: #aaa;
        }


        .accuracy-history {
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
        }

        .history-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 0.9em;
        }

        .history-entry.correct {
            border-left: 3px solid #3498db; /* Changed from green to blue */
        }

        .history-entry.incorrect {
            border-left: 3px solid #e74c3c;
        }

        .entry-number {
            color: #888;
            margin-right: 10px;
            min-width: 40px;
        }

        .entry-prediction {
            flex: 1;
        }

        .entry-actual {
            flex: 1;
        }

        .entry-result {
            padding: 2px 8px;
            border-radius: 5px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .entry-result.correct {
            background: rgba(52, 152, 219, 0.2); /* Changed from green to blue */
            color: #3498db;
        }

        .entry-result.incorrect {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        /* Warning System */
        .warning-system {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.2), rgba(192, 57, 43, 0.2));
            border: 2px solid #e74c3c;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
            display: none;
            animation: warningPulse 2s infinite;
        }

        .warning-system.active {
            display: block;
        }

        @keyframes warningPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(231, 76, 60, 0.5); }
            50% { box-shadow: 0 0 40px rgba(231, 76, 60, 0.8); }
        }

        .warning-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #ff6b6b;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .warning-icon {
            font-size: 1.5em;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.3; }
        }

        .warning-list {
            list-style: none;
            padding-left: 20px;
        }

        .warning-list li {
            margin: 8px 0;
            color: #ffcccc;
        }

        /* Pattern Recognition Display */
        .pattern-recognition {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .pattern-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
        }

        .pattern-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .pattern-card.detected {
            background: linear-gradient(135deg, rgba(79, 209, 197, 0.2), rgba(52, 152, 219, 0.2));
            border-color: #4fd1c5;
            animation: patternGlow 2s infinite;
        }

        @keyframes patternGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(79, 209, 197, 0.3); }
            50% { box-shadow: 0 0 20px rgba(79, 209, 197, 0.6); }
        }

        .pattern-name {
            font-weight: bold;
            color: #4fd1c5;
            margin-bottom: 5px;
        }

        .pattern-confidence {
            font-size: 0.9em;
            color: #aaa;
        }

        .pattern-description {
            font-size: 0.85em;
            color: #999;
            margin-top: 5px;
        }

        /* Confidence Score Display */
        .confidence-display {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .confidence-meter {
            position: relative;
            height: 40px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            overflow: hidden;
            margin: 20px 0;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12, #f1c40f, #2ecc71, #27ae60);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 15px;
            font-weight: bold;
            font-size: 1.1em;
        }

        .confidence-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            color: #999;
        }

        /* 142857 Algorithm Display */
        .algorithm-142857 {
            background: linear-gradient(135deg, rgba(155, 89, 182, 0.1), rgba(142, 68, 173, 0.1));
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            border: 2px solid #9b59b6;
            position: relative;
            overflow: hidden;
        }

        .algorithm-142857::before {
            content: "142857";
            position: absolute;
            top: -50px;
            right: -50px;
            font-size: 100px;
            font-weight: bold;
            color: rgba(155, 89, 182, 0.1);
            transform: rotate(25deg);
        }

        .algorithm-title {
            font-size: 1.5em;
            color: #bb8fce;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .magic-number {
            display: inline-block;
            padding: 5px 15px;
            background: rgba(155, 89, 182, 0.3);
            border-radius: 20px;
            font-family: monospace;
            font-size: 1.2em;
            margin: 0 5px;
            animation: magicPulse 3s infinite;
        }

        @keyframes magicPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .algorithm-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .algorithm-cell {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            border: 1px solid rgba(155, 89, 182, 0.3);
        }

        .algorithm-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #bb8fce;
        }

        .algorithm-label {
            font-size: 0.85em;
            color: #999;
            margin-top: 5px;
        }

        /* Input Controls */
        .input-section {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .main-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        button {
            padding: 15px 25px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1.1em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        .btn-player {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: 2px solid #3498db;
        }

        .btn-banker {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: 2px solid #e74c3c;
        }

        .btn-tie {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
            border: 2px solid #27ae60;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .stat-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.3s ease;
        }

        .stat-title {
            font-size: 0.95em;
            color: #b0b0b0;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            background: linear-gradient(135deg, #ffd700, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Prediction Section */
        .prediction-section {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(240, 84, 84, 0.1));
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .prediction-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .prediction-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .prediction-card.recommended {
            border-color: #ffd93d;
            background: rgba(255, 217, 61, 0.1);
            animation: pulse-glow 2s ease-in-out infinite;
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 217, 61, 0.3); }
            50% { box-shadow: 0 0 30px rgba(255, 217, 61, 0.6); }
        }

        .confidence-badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            margin-top: 10px;
        }

        .confidence-high {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
        }

        .confidence-medium {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
        }

        .confidence-low {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        #historyDisplay {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            min-height: 60px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .history-item {
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 0.95em;
            font-weight: 600;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .history-item.player-history {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .history-item.banker-history {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .history-item.tie-history {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
        }

        .secondary-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .btn-action {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            color: white;
            border: 2px solid #34495e;
            padding: 12px 20px;
            font-size: 1em;
        }

        .btn-action.warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            border: 2px solid #f39c12;
        }

        .section-title {
            font-size: 1.4em;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-title::before {
            content: '';
            width: 4px;
            height: 24px;
            background: linear-gradient(180deg, #667eea, #f05454);
            border-radius: 2px;
        }

        /* Scrollbar styles */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <!-- New Background Decor Elements -->
    <div class="background-decor">
        <div class="han-char">Á¶è</div>
        <div class="han-char">Á¶è</div>
    </div>

    <div class="container">
        <div class="header">
            <h1>üé∞ H·ªÜ TH·ªêNG BCR 6868 üé∞</h1>
            <p class="disclaimer">
                üíé PH√öC ƒê·∫∏P TRAI- ƒê√ÅNH ƒê√ÇU TH·∫ÆNG ƒê√ì, MAY M·∫ÆN PH√ÅT T√ÄI. Hihi üíé
            </p>
            <!-- New Lucky Phrases -->
            <div class="lucky-phrases">
                <span class="lucky-text lucky-text-1">MAY M·∫ÆN PH√ÅT T√ÄI</span>
                <span class="lucky-text lucky-text-2">ƒê√ÅNH ƒê√ÇU TR√öNG ƒê√ì</span>
            </div>
        </div>

        <!-- Accuracy Statistics Section -->
        <div class="accuracy-section">
            <div class="accuracy-header">
                <div class="accuracy-title">
                    üéØ TH·ªêNG K√ä ƒê·ªò CH√çNH X√ÅC H·ªÜ TH·ªêNG
                </div>
                <button class="accuracy-reset" onclick="resetAccuracyStats()">
                    üîÑ Reset Th·ªëng K√™
                </button>
            </div>
            
            <div class="accuracy-main">
                <div class="accuracy-card">
                    <div class="accuracy-label">ƒê·ªô Ch√≠nh X√°c T·ªïng</div>
                    <div class="accuracy-value" id="overallAccuracy">0%</div>
                    <div class="accuracy-change" id="accuracyTrend">-</div>
                </div>
                
                <div class="accuracy-card">
                    <div class="accuracy-label">T·ªïng D·ª± ƒêo√°n</div>
                    <div class="accuracy-value" id="totalPredictions">0</div>
                    <div class="accuracy-change">ƒê√∫ng: <span id="correctPredictions">0</span></div>
                </div>
                
                <div class="accuracy-card">
                    <div class="accuracy-label">Chu·ªói Th·∫Øng</div>
                    <div class="accuracy-value" id="winStreak">0</div>
                    <div class="accuracy-change">Max: <span id="maxWinStreak">0</span></div>
                </div>
                
                <div class="accuracy-card">
                    <div class="accuracy-label">ROI Gi·∫£ L·∫≠p</div>
                    <div class="accuracy-value" id="simulatedROI">0%</div>
                    <div class="accuracy-change" id="roiTrend">-</div>
                </div>
            </div>
            
            <div class="accuracy-details">
                <h3 style="margin-bottom: 15px; color: #3498db;">üìà Ph√¢n T√≠ch Chi Ti·∫øt</h3>
                
                <div class="accuracy-breakdown">
                    <div class="breakdown-item">
                        <div class="breakdown-type player">üë§ PLAYER</div>
                        <div class="breakdown-stats">
                            <div class="stat-item">
                                <span class="stat-label">D·ª± ƒëo√°n</span>
                                <span class="stat-value" id="playerPredCount">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">ƒê√∫ng</span>
                                <span class="stat-value" id="playerCorrect">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">T·ª∑ l·ªá</span>
                                <span class="stat-value" id="playerAccuracy">0%</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="breakdown-item">
                        <div class="breakdown-type banker">üè¶ BANKER</div>
                        <div class="breakdown-stats">
                            <div class="stat-item">
                                <span class="stat-label">D·ª± ƒëo√°n</span>
                                <span class="stat-value" id="bankerPredCount">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">ƒê√∫ng</span>
                                <span class="stat-value" id="bankerCorrect">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">T·ª∑ l·ªá</span>
                                <span class="stat-value" id="bankerAccuracy">0%</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="breakdown-item">
                        <div class="breakdown-type tie">ü§ù TIE</div>
                        <div class="breakdown-stats">
                            <div class="stat-item">
                                <span class="stat-label">D·ª± ƒëo√°n</span>
                                <span class="stat-value" id="tiePredCount">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">ƒê√∫ng</span>
                                <span class="stat-value" id="tieCorrect">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">T·ª∑ l·ªá</span>
                                <span class="stat-value" id="tieAccuracy">0%</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- === MODIFIED: Streak Pattern Analyzer === -->
                <div class="streak-prediction-display" style="margin-top: 20px; text-align: center; margin-bottom: 20px;">
                    <h4 style="margin-bottom: 10px; color: #aaa; font-size: 0.95em;">üîÆ PH√ÇN T√çCH QUY LU·∫¨T CHU·ªñI SAI</h4>
                    <div id="streakPrediction" class="streak-prediction-result">
                        <span>D·ª± ƒëo√°n chu·ªói sai ti·∫øp theo: </span>
                        <span id="streakPredictionValue" class="prediction-value">?</span>
                    </div>
                    <div id="streakPredictionReason" class="streak-prediction-reason">Ch·ªù d·ªØ li·ªáu...</div>
                </div>
                
                <div class="accuracy-streak-display" style="margin-top: 20px;">
                    <h4 style="margin-bottom: 10px; color: #aaa; font-size: 0.95em;">üîó Chu·ªói ƒê√∫ng/Sai (ƒê√∫ng / Sai)</h4>
                    <div id="accuracyStreakSequence" class="streak-sequence"></div>
                </div>
                
                <div class="accuracy-chart">
                    <h4 style="margin-bottom: 10px; color: #aaa; font-size: 0.95em;">üìä Bi·ªÉu ƒë·ªì ƒë·ªô ch√≠nh x√°c to√†n b·ªô</h4>
                    <div class="chart-bars" id="accuracyChart"></div>
                </div>
                
                <div class="accuracy-history">
                    <h4 style="margin-bottom: 10px; color: #aaa; font-size: 0.95em;">üìù L·ªãch s·ª≠ d·ª± ƒëo√°n 20 v√°n g·∫ßn ƒë√¢y</h4>
                    <div id="predictionHistory"></div>
                </div>
            </div>
        </div>

        <!-- Warning System -->
        <div class="warning-system" id="warningSystem">
            <div class="warning-title">
                <span class="warning-icon">‚ö†Ô∏è</span>
                C·∫¢NH B√ÅO M·∫™U NGUY HI·ªÇM
            </div>
            <ul class="warning-list" id="warningList"></ul>
        </div>

        <!-- 142857 Algorithm Display -->
        <div class="algorithm-142857">
            <div class="algorithm-title">
                üîÆ Thu·∫≠t To√°n Th·∫ßn S·ªë <span class="magic-number">142857</span>
            </div>
            <div class="algorithm-grid" id="algorithmDisplay">
                <div class="algorithm-cell">
                    <div class="algorithm-value" id="magicPhase">1</div>
                    <div class="algorithm-label">Pha Hi·ªán T·∫°i</div>
                </div>
                <div class="algorithm-cell">
                    <div class="algorithm-value" id="magicCycle">0</div>
                    <div class="algorithm-label">Chu K·ª≥</div>
                </div>
                <div class="algorithm-cell">
                    <div class="algorithm-value" id="magicPrediction">-</div>
                    <div class="algorithm-label">D·ª± ƒêo√°n</div>
                </div>
                <div class="algorithm-cell">
                    <div class="algorithm-value" id="magicAccuracy">0%</div>
                    <div class="algorithm-label">ƒê·ªô Ch√≠nh X√°c</div>
                </div>
            </div>
        </div>

        <!-- Confidence Display -->
        <div class="confidence-display">
            <h2 class="section-title">üìä ƒê·ªô Tin C·∫≠y T·ªïng H·ª£p</h2>
            <div class="confidence-meter">
                <div class="confidence-fill" id="confidenceFill" style="width: 0%">0%</div>
            </div>
            <div class="confidence-labels">
                <span>R·∫•t Th·∫•p</span>
                <span>Th·∫•p</span>
                <span>Trung B√¨nh</span>
                <span>Cao</span>
                <span>R·∫•t Cao</span>
            </div>
        </div>

        <!-- Pattern Recognition -->
        <div class="pattern-recognition">
            <h2 class="section-title">üéØ Nh·∫≠n Di·ªán M·∫´u Chu·∫©n</h2>
            <div class="pattern-grid" id="patternGrid"></div>
        </div>

        <!-- Input Section -->
        <div class="input-section">
            <h2 class="section-title">üé≤ Nh·∫≠p K·∫øt Qu·∫£</h2>
            
            <div class="main-buttons">
                <button class="btn-player" onclick="addResult('P')">
                    <span style="font-size: 1.5em;">üë§</span><br>
                    PLAYER
                </button>
                <button class="btn-banker" onclick="addResult('B')">
                    <span style="font-size: 1.5em;">üè¶</span><br>
                    BANKER
                </button>
                <button class="btn-tie" onclick="addResult('T')">
                    <span style="font-size: 1.5em;">ü§ù</span><br>
                    TIE
                </button>
            </div>
            
            <div class="secondary-buttons">
                <button class="btn-action" onclick="undoLast()">‚Ü©Ô∏è Ho√†n T√°c</button>
                <button class="btn-action warning" onclick="clearHistory()">üóëÔ∏è X√≥a T·∫•t C·∫£</button>
                <button class="btn-action" onclick="generateRandom()">üé≤ Demo (30 v√°n)</button>
            </div>
            
            <div id="historyDisplay"></div>
        </div>

        <!-- Stats Grid -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-title">üìà T·ªïng V√°n</div>
                <div class="stat-value" id="totalGames">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">üë§ Player Win</div>
                <div class="stat-value" id="playerRate">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">üè¶ Banker Win</div>
                <div class="stat-value" id="bankerRate">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">ü§ù Tie Rate</div>
                <div class="stat-value" id="tieRate">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">üî• Streak</div>
                <div class="stat-value" id="currentStreak">-</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">üìä Pattern</div>
                <div class="stat-value" id="currentPattern">-</div>
            </div>
        </div>

        <!-- Prediction Section -->
        <div class="prediction-section">
            <h2 class="section-title">üîÆ D·ª± ƒêo√°n AI</h2>
            <div class="prediction-grid">
                <div class="prediction-card" id="predPlayer">
                    <h3>üë§ PLAYER</h3>
                    <div class="stat-value" id="playerProb">0%</div>
                    <div class="confidence-badge" id="playerConfidence">-</div>
                </div>
                <div class="prediction-card" id="predBanker">
                    <h3>üè¶ BANKER</h3>
                    <div class="stat-value" id="bankerProb">0%</div>
                    <div class="confidence-badge" id="bankerConfidence">-</div>
                </div>
                <div class="prediction-card" id="predTie">
                    <h3>ü§ù TIE</h3>
                    <div class="stat-value" id="tieProb">0%</div>
                    <div class="confidence-badge" id="tieConfidence">-</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== ACCURACY TRACKING SYSTEM =====
        class AccuracyTracker {
            constructor() {
                this.predictions = [];
                this.results = [];
                this.currentPrediction = null;
                this.currentStreak = 0;
                this.maxStreak = 0;
                this.stats = {
                    P: { predicted: 0, correct: 0 },
                    B: { predicted: 0, correct: 0 },
                    T: { predicted: 0, correct: 0 }
                };
                this.accuracyHistory = []; // Store full accuracy history (1 for correct, 0 for incorrect)
                this.last20Accuracy = []; 
                this.roi = 100; // Starting with 100 units
                this.roiHistory = [];
            }

            makePrediction(prediction) {
                if (this.currentPrediction) {
                    this.predictions.push(this.currentPrediction);
                    this.results.push(null);
                }
                
                const maxProb = Math.max(prediction.P, prediction.B, prediction.T);
                let predictedOutcome = null;
                
                if (maxProb > 35) {
                    if (maxProb === prediction.P) predictedOutcome = 'P';
                    else if (maxProb === prediction.B) predictedOutcome = 'B';
                    else if (maxProb === prediction.T) predictedOutcome = 'T';
                }
                
                this.currentPrediction = {
                    prediction: predictedOutcome,
                    probabilities: { ...prediction },
                    confidence: maxProb,
                    timestamp: Date.now()
                };
            }

            recordActualResult(actual) {
                if (!this.currentPrediction) return;
                
                const predicted = this.currentPrediction.prediction;
                const isCorrect = predicted === actual;
                
                this.predictions.push(this.currentPrediction);
                this.results.push(actual);
                
                if (predicted) {
                    this.stats[predicted].predicted++;
                    if (isCorrect) {
                        this.stats[predicted].correct++;
                        this.currentStreak++;
                        this.maxStreak = Math.max(this.maxStreak, this.currentStreak);
                    } else {
                        this.currentStreak = 0;
                    }
                }
                
                // Only add to accuracy history if a prediction was actually made
                if (predicted) {
                    this.accuracyHistory.push(isCorrect ? 1 : 0);
                }

                this.last20Accuracy.push(isCorrect ? 1 : 0);
                if (this.last20Accuracy.length > 20) {
                    this.last20Accuracy.shift();
                }
                
                this.updateROI(predicted, actual);
                this.currentPrediction = null;
            }

            updateROI(predicted, actual) {
                if (!predicted) return;
                const betAmount = 10;
                if (predicted === actual) {
                    if (actual === 'T') {
                        this.roi += betAmount * 8;
                    } else {
                        this.roi += betAmount * 0.95;
                    }
                } else {
                    this.roi -= betAmount;
                }
                this.roiHistory.push(this.roi);
                if (this.roiHistory.length > 100) {
                    this.roiHistory.shift();
                }
            }

            getOverallAccuracy() {
                if (this.accuracyHistory.length === 0) return 0;
                const correct = this.accuracyHistory.filter(r => r === 1).length;
                return (correct / this.accuracyHistory.length) * 100;
            }

            getAccuracyByType(type) {
                if (this.stats[type].predicted === 0) return 0;
                return (this.stats[type].correct / this.stats[type].predicted) * 100;
            }

            getROIPercentage() {
                return ((this.roi - 100) / 100) * 100;
            }

            getRecentHistory(limit = 20) { 
                const recent = [];
                const start = Math.max(0, this.predictions.length - limit);
                for (let i = start; i < this.predictions.length; i++) {
                    if (this.results[i] !== null && this.predictions[i].prediction) {
                        recent.push({
                            number: i + 1,
                            predicted: this.predictions[i].prediction,
                            actual: this.results[i],
                            correct: this.predictions[i].prediction === this.results[i],
                            confidence: this.predictions[i].confidence
                        });
                    }
                }
                return recent;
            }

            reset() {
                this.predictions = [];
                this.results = [];
                this.currentPrediction = null;
                this.currentStreak = 0;
                this.maxStreak = 0;
                this.stats = {
                    P: { predicted: 0, correct: 0 },
                    B: { predicted: 0, correct: 0 },
                    T: { predicted: 0, correct: 0 }
                };
                this.accuracyHistory = [];
                this.last20Accuracy = [];
                this.roi = 100;
                this.roiHistory = [];
            }
        }
        
        // ===== V2: ADVANCED SEQUENCE PATTERN ANALYZER =====
        class StreakPatternAnalyzer {
            
            // This helper function converts the history of 1s and 0s into a sequence of incorrect streak lengths.
            // Example: [1, 0, 0, 0, 1, 0, 0, 1] -> [3, 2]
            generateIncorrectStreakSequence(accuracyHistory) {
                const sequence = [];
                let currentIncorrectStreak = 0;
                for (const result of accuracyHistory) {
                    if (result === 0) { // Incorrect prediction
                        currentIncorrectStreak++;
                    } else { // Correct prediction
                        if (currentIncorrectStreak > 0) {
                            sequence.push(currentIncorrectStreak);
                        }
                        currentIncorrectStreak = 0;
                    }
                }
                // If the sequence ends on an incorrect streak, add it.
                if (currentIncorrectStreak > 0) {
                    sequence.push(currentIncorrectStreak);
                }
                return sequence;
            }

            // Finds repeating sub-sequences (n-grams) and predicts the most common outcome.
            findNGramPatterns(sequence, n) {
                if (sequence.length <= n) return null;
                const ngrams = {};
                for (let i = 0; i < sequence.length - n; i++) {
                    const gram = sequence.slice(i, i + n).join(',');
                    const nextVal = sequence[i + n];
                    if (!ngrams[gram]) {
                        ngrams[gram] = {};
                    }
                    ngrams[gram][nextVal] = (ngrams[gram][nextVal] || 0) + 1;
                }

                const lastGram = sequence.slice(-n).join(',');
                if (ngrams[lastGram]) {
                    const outcomes = ngrams[lastGram];
                    let bestOutcome = null;
                    let maxCount = 0;
                    let totalCount = 0;
                    for (const outcome in outcomes) {
                        totalCount += outcomes[outcome];
                        if (outcomes[outcome] > maxCount) {
                            maxCount = outcomes[outcome];
                            bestOutcome = parseInt(outcome, 10);
                        }
                    }
                    return {
                        prediction: bestOutcome,
                        confidence: maxCount / totalCount,
                        reason: `Sau chu·ªói [${lastGram}], s·ªë ${bestOutcome} xu·∫•t hi·ªán ${maxCount}/${totalCount} l·∫ßn.`
                    };
                }
                return null;
            }

            // Looks for large-scale cycles in the sequence.
            findCycle(sequence) {
                if (sequence.length < 6) return null;
                for (let cycleLen = Math.floor(sequence.length / 2); cycleLen > 2; cycleLen--) {
                    const lastCycle = sequence.slice(-cycleLen);
                    const prevCycle = sequence.slice(-cycleLen * 2, -cycleLen);
                    if (JSON.stringify(lastCycle) === JSON.stringify(prevCycle)) {
                        const nextIndexInCycle = sequence.length % cycleLen;
                        return {
                            prediction: prevCycle[nextIndexInCycle],
                            confidence: 0.9, // High confidence for full cycle repetition
                            reason: `Ph√°t hi·ªán chu k·ª≥ l·∫∑p l·∫°i ƒë·ªô d√†i ${cycleLen}: [${prevCycle.join(',')}]`
                        };
                    }
                }
                return null;
            }

            // Main analysis function
            analyze(accuracyHistory) {
                const sequence = this.generateIncorrectStreakSequence(accuracyHistory);
                if (sequence.length < 3) {
                    return { prediction: null, confidence: 0, reason: "C·∫ßn √≠t nh·∫•t 3 chu·ªói sai ƒë·ªÉ ph√¢n t√≠ch." };
                }

                const predictions = [];

                // 1. Check for major cycles first (highest priority)
                const cyclePrediction = this.findCycle(sequence);
                if (cyclePrediction) predictions.push(cyclePrediction);

                // 2. Check for N-grams of different lengths (longer grams are more significant)
                for (let n = 4; n >= 2; n--) {
                    const ngramPrediction = this.findNGramPatterns(sequence, n);
                    if (ngramPrediction && ngramPrediction.confidence > 0.6) { // Only consider confident n-grams
                        // Add weight based on n-gram length
                        ngramPrediction.confidence += (n * 0.05); 
                        predictions.push(ngramPrediction);
                    }
                }

                if (predictions.length === 0) {
                    return { prediction: null, confidence: 0, reason: "Kh√¥ng t√¨m th·∫•y quy lu·∫≠t r√µ r√†ng trong chu·ªói sai." };
                }

                // Return the prediction with the highest confidence score
                const bestPrediction = predictions.reduce((best, current) => {
                    return current.confidence > best.confidence ? current : best;
                });
                
                return bestPrediction;
            }
        }

        // ===== THU·∫¨T TO√ÅN 142857 =====
        class MagicNumber142857 {
            constructor() {
                this.base = 142857;
                this.sequence = [1, 4, 2, 8, 5, 7];
                this.phase = 0;
                this.cycle = 0;
                this.predictions = [];
                this.results = [];
            }

            getNextPhase() {
                this.phase = (this.phase + 1) % 6;
                if (this.phase === 0) this.cycle++;
                return this.sequence[this.phase];
            }

            calculatePrediction(history) {
                if (history.length < 3) return null;
                const currentPhase = this.sequence[this.phase];
                const multiplier = (currentPhase * this.base) % 1000000;
                const digits = multiplier.toString().padStart(6, '0').split('').map(Number);
                const sum = digits.reduce((a, b) => a + b, 0);
                if (sum === 0) return { P: 33.3, B: 33.3, T: 1 };
                
                const playerWeight = (digits[0] + digits[2] + digits[4]) / sum;
                const bankerWeight = (digits[1] + digits[3] + digits[5]) / sum;
                const tieWeight = Math.abs(1 - playerWeight - bankerWeight);
                
                const recentTrend = this.analyzeRecentTrend(history);
                
                return {
                    P: (playerWeight * 70 + recentTrend.P * 30),
                    B: (bankerWeight * 70 + recentTrend.B * 30),
                    T: Math.max(5, tieWeight * 100),
                    phase: currentPhase,
                    cycle: this.cycle
                };
            }

            analyzeRecentTrend(history) {
                const recent = history.slice(-7);
                const counts = { P: 0, B: 0, T: 0 };
                recent.forEach(r => counts[r]++);
                const total = recent.length || 1;
                return {
                    P: (counts.P / total) * 100,
                    B: (counts.B / total) * 100,
                    T: (counts.T / total) * 100
                };
            }

            updateAccuracy(prediction, actual) {
                if (!prediction) return;
                this.predictions.push(prediction);
                this.results.push(actual);
                if (this.predictions.length > 100) {
                    this.predictions.shift();
                    this.results.shift();
                }
            }

            getAccuracy() {
                if (this.predictions.length === 0) return 0;
                let correct = 0;
                for (let i = 0; i < this.predictions.length; i++) {
                    const pred = this.predictions[i];
                    const actual = this.results[i];
                    const maxPred = Math.max(pred.P, pred.B, pred.T);
                    if ((maxPred === pred.P && actual === 'P') ||
                        (maxPred === pred.B && actual === 'B') ||
                        (maxPred === pred.T && actual === 'T')) {
                        correct++;
                    }
                }
                return (correct / this.predictions.length) * 100;
            }
        }

        // ===== PATTERN RECOGNITION SYSTEM =====
        class PatternRecognitionSystem {
            constructor() {
                this.patterns = {
                    'Dragon': { check: (h) => this.checkDragon(h), danger: false, description: 'Chu·ªói d√†i c√πng k·∫øt qu·∫£ (5+)'},
                    'Baby Dragon': { check: (h) => this.checkBabyDragon(h), danger: false, description: 'Chu·ªói ng·∫Øn (3-4)'},
                    'Ping Pong': { check: (h) => this.checkPingPong(h), danger: false, description: 'Xen k·∫Ω P-B-P-B'},
                    'Choppy': { check: (h) => this.checkChoppy(h), danger: true, description: 'Thay ƒë·ªïi li√™n t·ª•c, kh√≥ ƒëo√°n'},
                    'Trend': { check: (h) => this.checkTrend(h), danger: false, description: 'Xu h∆∞·ªõng r√µ r√†ng P ho·∫∑c B'},
                    'Anti-Trend': { check: (h) => this.checkAntiTrend(h), danger: true, description: 'ƒê·∫£o chi·ªÅu xu h∆∞·ªõng'},
                    'ZigZag': { check: (h) => this.checkZigZag(h), danger: false, description: 'M·∫´u 2-1-2-1'},
                    'Streaky': { check: (h) => this.checkStreaky(h), danger: false, description: 'Nhi·ªÅu chu·ªói ng·∫Øn'},
                    'TTT': { check: (h) => this.checkTripleTie(h), danger: true, description: '3 Tie li√™n ti·∫øp'},
                    'Sandwich': { check: (h) => this.checkSandwich(h), danger: false, description: 'P-B-P ho·∫∑c B-P-B'},
                    'Double Dragon': { check: (h) => this.checkDoubleDragon(h), danger: false, description: '2 chu·ªói d√†i li√™n ti·∫øp'},
                    'Mirror': { check: (h) => this.checkMirror(h), danger: false, description: 'M·∫´u ƒë·ªëi x·ª©ng'},
                    // C√ÅC THU·∫¨T TO√ÅN M·ªöI
                    'Repeating Streaks': { check: (h) => this.checkRepeatingStreaks(h), danger: false, description: 'Chu·ªói ƒë·ªô d√†i l·∫∑p l·∫°i (vd: 2,1,2,1)'},
                    'Symmetrical Streaks': { check: (h) => this.checkSymmetricalStreaks(h), danger: false, description: 'Chu·ªói ƒë·ªô d√†i ƒë·ªëi x·ª©ng (vd: 1,2,3,2,1)'},
                    'Complex Alternation': { check: (h) => this.checkComplexAlternation(h), danger: false, description: 'Xen k·∫Ω ph·ª©c t·∫°p (vd: PPB-PPB)'},
                };
            }

            // Helper function to get streak information
            getStreakInfo(history) {
                const cleanHistory = history.filter(r => r !== 'T');
                if (cleanHistory.length === 0) return [];
                
                const streaks = [];
                let currentStreak = { type: cleanHistory[0], length: 0 };

                for (const result of cleanHistory) {
                    if (result === currentStreak.type) {
                        currentStreak.length++;
                    } else {
                        streaks.push(currentStreak);
                        currentStreak = { type: result, length: 1 };
                    }
                }
                streaks.push(currentStreak);
                return streaks;
            }

            // C√ÅC THU·∫¨T TO√ÅN M·ªöI
            checkRepeatingStreaks(h) {
                const streaks = this.getStreakInfo(h);
                if (streaks.length < 4) return { detected: false };

                const streakLengths = streaks.map(s => s.length);

                // Check for 2-item repeat (e.g., 2,1,2,1)
                if (streaks.length >= 4) {
                    const last4 = streakLengths.slice(-4);
                    if (last4[0] === last4[2] && last4[1] === last4[3]) {
                        const nextType = streaks[streaks.length - 2].type;
                        return { detected: true, confidence: 0.75, next: nextType, description: `L·∫∑p l·∫°i chu·ªói ${last4[0]}-${last4[1]}` };
                    }
                }
                // Check for 3-item repeat (e.g., 3,1,2,3,1,2)
                if (streaks.length >= 6) {
                    const last6 = streakLengths.slice(-6);
                    if (last6[0] === last6[3] && last6[1] === last6[4] && last6[2] === last6[5]) {
                        const nextType = streaks[streaks.length - 3].type;
                        return { detected: true, confidence: 0.85, next: nextType, description: `L·∫∑p l·∫°i chu·ªói ${last6[0]}-${last6[1]}-${last6[2]}` };
                    }
                }
                return { detected: false };
            }

            checkSymmetricalStreaks(h) {
                const streaks = this.getStreakInfo(h);
                if (streaks.length < 5) return { detected: false };
                
                const streakLengths = streaks.map(s => s.length);
                const last5 = streakLengths.slice(-5);
                
                // Check for 5-item palindrome (e.g., 1,2,3,2,1)
                if (last5[0] === last5[4] && last5[1] === last5[3]) {
                    const lastStreakType = streaks[streaks.length - 1].type;
                    const nextType = lastStreakType === 'P' ? 'B' : 'P';
                    return { detected: true, confidence: 0.7, next: nextType, description: `ƒê·ªëi x·ª©ng 5 chu·ªói: ${last5.join(',')}` };
                }
                return { detected: false };
            }
            
            checkComplexAlternation(h) {
                const cleanHistory = h.filter(r => r !== 'T');
                if (cleanHistory.length < 6) return { detected: false };

                const last6 = cleanHistory.slice(-6);
                const firstHalf = last6.slice(0, 3).join('');
                const secondHalf = last6.slice(3, 6).join('');

                if (firstHalf === secondHalf) {
                    // Pattern like PPB PPB or PBP PBP
                    const nextType = last6[0];
                    return { detected: true, confidence: 0.8, next: nextType, description: `L·∫∑p l·∫°i m·∫´u 3: ${firstHalf}` };
                }
                return { detected: false };
            }

            // C√ÅC THU·∫¨T TO√ÅN G·ªêC
            checkDragon(h){if(h.length<5)return{detected:!1};const t=h.slice(-5);const e=t.every(h=>h===t[0]&&"T"!==h);return{detected:e,confidence:e?.9:0,next:e?t[0]:null}}
            checkBabyDragon(h){if(h.length<3)return{detected:!1};const t=h.slice(-4),e=h.slice(-3),n=e.every(h=>h===e[0]&&"T"!==h),c=4===t.length&&t.every(h=>h===t[0]&&"T"!==h);return{detected:n||c,confidence:c?.8:n?.7:0,next:n?e[0]:c?t[0]:null}}
            checkPingPong(h){if(h.length<4)return{detected:!1};const t=h.slice(-4),e="T",n=t[0]!==t[1]&&t[1]!==t[2]&&t[2]!==t[3]&&t[0]===t[2]&&t[1]===t[3]&&!t.includes(e);return{detected:n,confidence:n?.75:0,next:n?t[0]:null}}
            checkChoppy(h){if(h.length<10)return{detected:!1};const t=h.slice(-10);let e=0;for(let n=1;n<t.length;n++)t[n]!==t[n-1]&&e++;const n=e>=7;return{detected:n,confidence:n?.6:0,next:null}}
            checkTrend(h){if(h.length<10)return{detected:!1};const t=h.slice(-10).filter(h=>"T"!==h),e=t.filter(h=>"P"===h).length,n=t.filter(h=>"B"===h).length,c=e>=7||n>=7;return{detected:c,confidence:c?.8:0,next:e>=7?"P":n>=7?"B":null}}
            checkAntiTrend(h){if(h.length<15)return{detected:!1};const t=h.slice(-15,-8).filter(h=>"T"!==h),e=h.slice(-7).filter(h=>"T"!==h),n=t.filter(h=>"P"===h).length,c=e.filter(h=>"P"===h).length,o=n>=5&&c<=2||n<=2&&c>=5;return{detected:o,confidence:o?.7:0,next:null}}
            checkZigZag(h){if(h.length<6)return{detected:!1};const t=h.slice(-6).filter(h=>"T"!==h),e=[];let n=t[0],c=1;for(let o=1;o<t.length;o++)t[o]===n?c++:(e.push(c),n=t[o],c=1);e.push(c);const o=e.length>=3&&e.every(h=>1===h||2===h);return{detected:o,confidence:o?.65:0,next:null}}
            checkStreaky(h){if(h.length<12)return{detected:!1};const t=h.slice(-12);let e=0,n=1;for(let c=1;c<t.length;c++)t[c]===t[c-1]&&"T"!==t[c]?n++:(n>=2&&e++,n=1);n>=2&&e++;const c=e>=3;return{detected:c,confidence:c?.7:0,next:c?t[t.length-1]:null}}
            checkTripleTie(h){if(h.length<3)return{detected:!1};const t=h.slice(-3).every(h=>"T"===h);return{detected:t,confidence:t?.9:0,next:null}}
            checkSandwich(h){if(h.length<3)return{detected:!1};const t=h.slice(-3),e="T",n=t[0]===t[2]&&t[0]!==t[1]&&!t.includes(e);return{detected:n,confidence:n?.6:0,next:n?t[1]:null}}
            checkDoubleDragon(h){if(h.length<10)return{detected:!1};let t=null,e=0;let n=h[h.length-10],c=1;for(let o=h.length-9;o<h.length;o++)h[o]===n&&"T"!==h[o]?c++:(c>=4&&!t?(t=n,e=c):c>=4&&t&&n!==t&&({detected:!0,confidence:.85,next:h[h.length-1]}),n=h[o],c=1);return{detected:!1}}
            checkMirror(h){if(h.length<6)return{detected:!1};const t=h.slice(-6),e=t.slice(0,3).join(""),n=t.slice(3,6).reverse().join(""),c=e===n;return{detected:c,confidence:c?.7:0,next:c?t[2]:null}}
            
            analyzePatterns(h){const t=[],e=[];for(let n in this.patterns){const c=this.patterns[n],o=c.check(h);o.detected&&(t.push({name:n,confidence:o.confidence,next:o.next,danger:c.danger,description:c.description}),c.danger&&e.push({name:n,description:c.description}))}return{detected:t,warnings:e}}
        }

        // ===== MAIN ANALYZER =====
        class AdvancedBaccaratAnalyzer {
            constructor() {
                this.magicNumber = new MagicNumber142857();
                this.patternSystem = new PatternRecognitionSystem();
                this.accuracyTracker = new AccuracyTracker();
                this.streakAnalyzer = new StreakPatternAnalyzer(); // UPGRADED
                this.history = [];
                this.predictions = [];
                this.confidenceHistory = [];
            }

            addResult(result) {
                // This records the outcome for the prediction made in the previous step
                this.accuracyTracker.recordActualResult(result); 
                this.history.push(result);
                this.magicNumber.getNextPhase();
            }

            analyze() {
                if (this.history.length < 3) {
                    const initialResult = {
                        prediction: { P: 33.3, B: 33.3, T: 33.3 },
                        confidence: 0,
                        patterns: { detected: [], warnings: [] },
                        magic: null,
                        streakPrediction: { prediction: null, confidence: 0, reason: "C·∫ßn th√™m d·ªØ li·ªáu." }
                    };
                    this.accuracyTracker.makePrediction(initialResult.prediction);
                    return initialResult;
                }

                const patterns = this.patternSystem.analyzePatterns(this.history);
                const magicPred = this.magicNumber.calculatePrediction(this.history);
                // UPGRADED: Use the new streak analyzer
                const streakPrediction = this.streakAnalyzer.analyze(this.accuracyTracker.accuracyHistory);
                
                let finalPrediction = { P: 0, B: 0, T: 0 };
                let weights = 0;
                
                if (magicPred) {
                    finalPrediction.P += magicPred.P * 0.3;
                    finalPrediction.B += magicPred.B * 0.3;
                    finalPrediction.T += magicPred.T * 0.3;
                    weights += 0.3;
                }
                
                patterns.detected.forEach(pattern => {
                    if (pattern.next && pattern.confidence > 0.6) {
                        const weight = pattern.confidence * 0.2;
                        if (pattern.next === 'P') finalPrediction.P += weight * 100;
                        if (pattern.next === 'B') finalPrediction.B += weight * 100;
                        weights += weight;
                    }
                });
                
                const statPred = this.getStatisticalPrediction();
                finalPrediction.P += statPred.P * 0.2;
                finalPrediction.B += statPred.B * 0.2;
                finalPrediction.T += statPred.T * 0.2;
                weights += 0.2;
                
                if (weights > 0) {
                    const total = finalPrediction.P + finalPrediction.B + finalPrediction.T;
                    if (total > 0) {
                        finalPrediction.P = (finalPrediction.P / total) * 100;
                        finalPrediction.B = (finalPrediction.B / total) * 100;
                        finalPrediction.T = (finalPrediction.T / total) * 100;
                    } else {
                         finalPrediction = { P: 33.3, B: 33.3, T: 33.3 };
                    }
                }
                
                this.accuracyTracker.makePrediction(finalPrediction);
                const confidence = this.calculateConfidence(patterns, magicPred);
                
                return {
                    prediction: finalPrediction,
                    confidence: confidence,
                    patterns: patterns,
                    magic: magicPred,
                    streakPrediction: streakPrediction // Pass the new analysis result
                };
            }

            getStatisticalPrediction() {
                const recent = this.history.slice(-20).filter(r => ['P', 'B', 'T'].includes(r));
                const counts = { P: 0, B: 0, T: 0 };
                recent.forEach(r => counts[r]++);
                const total = recent.length || 1;
                const expected = total / 3;
                const prediction = {
                    P: 33.3 + (expected - counts.P) * 2,
                    B: 33.3 + (expected - counts.B) * 2,
                    T: 33.3 + (expected - counts.T) * 2
                };
                prediction.P = Math.max(5, Math.min(90, prediction.P));
                prediction.B = Math.max(5, Math.min(90, prediction.B));
                prediction.T = Math.max(5, Math.min(30, prediction.T));
                return prediction;
            }

            calculateConfidence(patterns, magicPred) {
                let confidence = 50;
                if (patterns.detected.length > 0) {
                    const avgPatternConf = patterns.detected.reduce((sum, p) => sum + p.confidence, 0) / patterns.detected.length;
                    confidence += avgPatternConf * 20;
                }
                confidence -= patterns.warnings.length * 10;
                if (magicPred) {
                    const accuracy = this.magicNumber.getAccuracy();
                    confidence += (accuracy - 50) * 0.5;
                }
                confidence += Math.min(20, this.history.length * 0.5);
                return Math.max(0, Math.min(100, confidence));
            }
        }

        // ===== GLOBAL VARIABLES =====
        let gameHistory = [];
        let analyzer = new AdvancedBaccaratAnalyzer();

        // ===== UI FUNCTIONS =====
        function addResult(result) {
            analyzer.analyze(); // Make prediction *before* adding the new result
            gameHistory.push(result);
            analyzer.addResult(result);
            updateDisplay();
            analyzeAndPredict();
            updateAccuracyStats();
        }

        function undoLast() {
            if (gameHistory.length > 0) {
                gameHistory.pop();
                analyzer = new AdvancedBaccaratAnalyzer();
                gameHistory.forEach(result => {
                    analyzer.analyze(); 
                    analyzer.addResult(result);
                });
                updateDisplay();
                analyzeAndPredict();
                updateAccuracyStats();
            }
        }

        function clearHistory() {
            // Replaced window.confirm with a simple check for demonstration.
            // In a real app, you'd use a custom modal.
            if (true) { // Simulating user confirmation
                gameHistory = [];
                analyzer = new AdvancedBaccaratAnalyzer();
                updateDisplay();
                analyzeAndPredict();
                updateAccuracyStats();
            }
        }

        function generateRandom() {
            const options = ['P', 'B', 'T'];
            const weights = [0.45, 0.45, 0.1];
            for (let i = 0; i < 30; i++) {
                const random = Math.random();
                let result;
                if (random < weights[0]) result = 'P';
                else if (random < weights[0] + weights[1]) result = 'B';
                else result = 'T';
                addResult(result);
            }
        }

        function resetAccuracyStats() {
            // Replaced window.confirm
            if (true) {
                analyzer.accuracyTracker.reset();
                updateAccuracyStats();
            }
        }

        function updateAccuracyStats() {
            const tracker = analyzer.accuracyTracker;
            const overallAcc = tracker.getOverallAccuracy();
            const overallElem = document.getElementById('overallAccuracy');
            overallElem.textContent = overallAcc.toFixed(1) + '%';
            overallElem.classList.remove('excellent', 'good', 'average', 'poor');
            if (overallAcc >= 70) overallElem.classList.add('excellent');
            else if (overallAcc >= 55) overallElem.classList.add('good');
            else if (overallAcc >= 45) overallElem.classList.add('average');
            else overallElem.classList.add('poor');
            
            const totalPred = tracker.accuracyHistory.length;
            document.getElementById('totalPredictions').textContent = totalPred;
            const correctPred = tracker.accuracyHistory.filter(r => r === 1).length;
            document.getElementById('correctPredictions').textContent = correctPred;
            
            document.getElementById('winStreak').textContent = tracker.currentStreak;
            document.getElementById('maxWinStreak').textContent = tracker.maxStreak;
            
            const roi = tracker.getROIPercentage();
            const roiElem = document.getElementById('simulatedROI');
            roiElem.textContent = (roi > 0 ? '+' : '') + roi.toFixed(1) + '%';
            roiElem.classList.remove('excellent', 'good', 'average', 'poor');
            if (roi > 20) roiElem.classList.add('excellent');
            else if (roi > 5) roiElem.classList.add('good');
            else if (roi > -5) roiElem.classList.add('average');
            else roiElem.classList.add('poor');
            
            ['P', 'B', 'T'].forEach(type => {
                const stats = tracker.stats[type];
                const typeName = type === 'P' ? 'player' : type === 'B' ? 'banker' : 'tie';
                document.getElementById(`${typeName}PredCount`).textContent = stats.predicted;
                document.getElementById(`${typeName}Correct`).textContent = stats.correct;
                const accuracy = tracker.getAccuracyByType(type);
                document.getElementById(`${typeName}Accuracy`).textContent = accuracy.toFixed(1) + '%';
            });
            
            const trend = document.getElementById('accuracyTrend');
            if (tracker.last20Accuracy.length >= 2) {
                const recent = tracker.last20Accuracy.slice(-10);
                const older = tracker.last20Accuracy.slice(0, -10);
                const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
                const olderAvg = older.length > 0 ? older.reduce((a, b) => a + b, 0) / older.length : 0;
                if (recentAvg > olderAvg) {
                    trend.textContent = '‚Üë ƒêang c·∫£i thi·ªán';
                    trend.classList.add('positive');
                    trend.classList.remove('negative');
                } else if (recentAvg < olderAvg) {
                    trend.textContent = '‚Üì ƒêang gi·∫£m';
                    trend.classList.add('negative');
                    trend.classList.remove('positive');
                } else {
                    trend.textContent = '‚Üí ·ªîn ƒë·ªãnh';
                    trend.classList.remove('positive', 'negative');
                }
            }
            
            const roiTrend = document.getElementById('roiTrend');
            if (tracker.roiHistory.length >= 10) {
                const recent = tracker.roiHistory.slice(-5);
                const older = tracker.roiHistory.slice(-10, -5);
                const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
                const olderAvg = older.reduce((a, b) => a + b, 0) / older.length;
                if (recentAvg > olderAvg) {
                    roiTrend.textContent = '‚Üë TƒÉng';
                    roiTrend.classList.add('positive');
                    roiTrend.classList.remove('negative');
                } else if (recentAvg < olderAvg) {
                    roiTrend.textContent = '‚Üì Gi·∫£m';
                    roiTrend.classList.add('negative');
                    roiTrend.classList.remove('positive');
                } else {
                    roiTrend.textContent = '‚Üí ·ªîn ƒë·ªãnh';
                    roiTrend.classList.remove('positive', 'negative');
                }
            }
            
            updateAccuracyChart();
            updatePredictionHistory();
            updateAccuracyStreakSequence();
        }

        function updateAccuracyChart() {
            const tracker = analyzer.accuracyTracker;
            const chartContainer = document.querySelector('.accuracy-chart');
            const chartDiv = document.getElementById('accuracyChart');
            const historyToShow = tracker.accuracyHistory;
            
            if (historyToShow.length === 0) {
                chartDiv.innerHTML = '<div style="text-align: center; color: #888; width: 100%;">Ch∆∞a c√≥ d·ªØ li·ªáu</div>';
                return;
            }
            
            const chartTitle = chartContainer.querySelector('h4');
            if (chartTitle) {
                chartTitle.textContent = `üìä Bi·ªÉu ƒë·ªì ƒë·ªô ch√≠nh x√°c to√†n b·ªô (${historyToShow.length} v√°n)`;
            }

            const bars = historyToShow.map((acc, idx) => {
                const height = acc ? '100%' : '5%';
                const colorClass = acc ? 'bar-correct' : 'bar-incorrect';
                const title = `V√°n #${idx + 1} - ${acc ? 'ƒê√∫ng' : 'Sai'}`;
                return `<div class="chart-bar ${colorClass}" style="height: ${height};" title="${title}"><div class="chart-bar-value">${acc ? '‚úì' : '‚úó'}</div><div class="chart-bar-label">#${idx + 1}</div></div>`;
            }).join('');
            
            chartDiv.innerHTML = bars;
            chartContainer.scrollLeft = chartContainer.scrollWidth;
        }

        function updateAccuracyStreakSequence() {
            const history = analyzer.accuracyTracker.accuracyHistory;
            const sequenceDiv = document.getElementById('accuracyStreakSequence');

            if (history.length === 0) {
                sequenceDiv.innerHTML = '<span style="color: #888;">Ch∆∞a c√≥ d·ªØ li·ªáu</span>';
                return;
            }

            const streaks = [];
            if (history.length > 0) {
                let currentStreakType = history[0];
                let currentStreakLength = 0;
                for (const result of history) {
                    if (result === currentStreakType) {
                        currentStreakLength++;
                    } else {
                        streaks.push({ type: currentStreakType, length: currentStreakLength });
                        currentStreakType = result;
                        currentStreakLength = 1;
                    }
                }
                streaks.push({ type: currentStreakType, length: currentStreakLength });
            }

            sequenceDiv.innerHTML = streaks.map(streak => {
                const className = streak.type === 1 ? 'correct' : 'incorrect';
                return `<span class="streak-number ${className}">${streak.length}</span>`;
            }).join('');
        }


        function updatePredictionHistory() {
            const tracker = analyzer.accuracyTracker;
            const historyDiv = document.getElementById('predictionHistory');
            const recentHistory = tracker.getRecentHistory(20); 
            
            if (recentHistory.length === 0) {
                historyDiv.innerHTML = '<div style="text-align: center; color: #888;">Ch∆∞a c√≥ l·ªãch s·ª≠ d·ª± ƒëo√°n</div>';
                return;
            }
            
            const entries = recentHistory.reverse().map(entry => `
                <div class="history-entry ${entry.correct ? 'correct' : 'incorrect'}">
                    <span class="entry-number">#${entry.number}</span>
                    <span class="entry-prediction">D·ª± ƒëo√°n: ${entry.predicted}</span>
                    <span class="entry-actual">K·∫øt qu·∫£: ${entry.actual}</span>
                    <span class="entry-result ${entry.correct ? 'correct' : 'incorrect'}">${entry.correct ? 'ƒê√öNG' : 'SAI'}</span>
                </div>
            `).join('');
            historyDiv.innerHTML = entries;
        }

        function updateDisplay() {
            const historyDiv = document.getElementById('historyDisplay');
            historyDiv.innerHTML = gameHistory.map((result, index) => {
                let className = '';
                let text = '';
                switch(result) {
                    case 'P': className = 'player-history'; text = 'P'; break;
                    case 'B': className = 'banker-history'; text = 'B'; break;
                    case 'T': className = 'tie-history'; text = 'T'; break;
                }
                return `<span class="history-item ${className}">${index + 1}. ${text}</span>`;
            }).join('');
            updateStatistics();
        }

        function updateStatistics() {
            const mainResults = gameHistory.filter(r => ['P', 'B', 'T'].includes(r));
            const total = mainResults.length;
            const counts = { P: 0, B: 0, T: 0 };
            mainResults.forEach(r => counts[r]++);
            
            document.getElementById('totalGames').textContent = total;
            document.getElementById('playerRate').textContent = total > 0 ? (counts.P / total * 100).toFixed(1) + '%' : '0%';
            document.getElementById('bankerRate').textContent = total > 0 ? (counts.B / total * 100).toFixed(1) + '%' : '0%';
            document.getElementById('tieRate').textContent = total > 0 ? (counts.T / total * 100).toFixed(1) + '%' : '0%';
            
            if (mainResults.length > 0) {
                let streak = 1;
                const lastResult = mainResults[mainResults.length - 1];
                for (let i = mainResults.length - 2; i >= 0; i--) {
                    if (mainResults[i] === lastResult) streak++; else break;
                }
                document.getElementById('currentStreak').textContent = `${streak} ${lastResult}`;
            } else {
                document.getElementById('currentStreak').textContent = '-';
            }
        }

        function analyzeAndPredict() {
            const analysis = analyzer.analyze();
            updatePredictions(analysis.prediction, analysis.confidence);
            updatePatterns(analysis.patterns);
            updateWarnings(analysis.patterns.warnings);
            updateMagicNumber(analysis.magic);
            updateConfidenceMeter(analysis.confidence);
            updateStreakPrediction(analysis.streakPrediction);
        }
        
        // === MODIFIED: UI Function for Streak Pattern Analyzer ===
        function updateStreakPrediction(analysis) {
            const valueDiv = document.getElementById('streakPredictionValue');
            const reasonDiv = document.getElementById('streakPredictionReason');

            if (analysis.prediction !== null) {
                valueDiv.textContent = analysis.prediction;
                valueDiv.style.color = '#ffd700'; // Gold color for a confident prediction
            } else {
                valueDiv.textContent = '?';
                valueDiv.style.color = '#aaa'; // Grey for uncertainty
            }
            
            reasonDiv.textContent = `${analysis.reason} (ƒê·ªô tin c·∫≠y: ${(analysis.confidence * 100).toFixed(0)}%)`;
        }

        function updatePredictions(prediction, overallConfidence) {
            document.getElementById('playerProb').textContent = prediction.P.toFixed(1) + '%';
            document.getElementById('bankerProb').textContent = prediction.B.toFixed(1) + '%';
            document.getElementById('tieProb').textContent = prediction.T.toFixed(1) + '%';
            updateConfidenceBadge('playerConfidence', prediction.P);
            updateConfidenceBadge('bankerConfidence', prediction.B);
            updateConfidenceBadge('tieConfidence', prediction.T);
            
            const cards = document.querySelectorAll('.prediction-card');
            cards.forEach(card => card.classList.remove('recommended'));
            
            const max = Math.max(prediction.P, prediction.B, prediction.T);
            if (max > 40) {
                if (max === prediction.P) document.getElementById('predPlayer').classList.add('recommended');
                else if (max === prediction.B) document.getElementById('predBanker').classList.add('recommended');
                else if (max === prediction.T) document.getElementById('predTie').classList.add('recommended');
            }
        }

        function updateConfidenceBadge(elementId, value) {
            const badge = document.getElementById(elementId);
            badge.classList.remove('confidence-high', 'confidence-medium', 'confidence-low');
            if (value >= 50) {
                badge.classList.add('confidence-high');
                badge.textContent = 'CAO';
            } else if (value >= 35) {
                badge.classList.add('confidence-medium');
                badge.textContent = 'TRUNG B√åNH';
            } else {
                badge.classList.add('confidence-low');
                badge.textContent = 'TH·∫§P';
            }
        }

        function updatePatterns(patterns) {
            const grid = document.getElementById('patternGrid');
            const topPatterns = patterns.detected.sort((a, b) => b.confidence - a.confidence).slice(0, 6);
            if (topPatterns.length > 0) {
                grid.innerHTML = topPatterns.map(p => `<div class="pattern-card detected"><div class="pattern-name">${p.name}</div><div class="pattern-confidence">ƒê·ªô tin c·∫≠y: ${(p.confidence*100).toFixed(0)}%</div><div class="pattern-description">${p.description}</div></div>`).join('');
                document.getElementById('currentPattern').textContent = topPatterns[0].name;
            } else {
                grid.innerHTML = '<div class="pattern-card"><div class="pattern-name">ƒêang ph√¢n t√≠ch...</div></div>';
                document.getElementById('currentPattern').textContent = '-';
            }
        }

        function updateWarnings(warnings) {
            const warningSystem = document.getElementById('warningSystem');
            const warningList = document.getElementById('warningList');
            if (warnings.length > 0) {
                warningSystem.classList.add('active');
                warningList.innerHTML = warnings.map(w => `<li>‚ö° ${w.name}: ${w.description}</li>`).join('');
            } else {
                warningSystem.classList.remove('active');
            }
        }

        function updateMagicNumber(magic) {
            if (magic) {
                document.getElementById('magicPhase').textContent = magic.phase;
                document.getElementById('magicCycle').textContent = magic.cycle;
                const maxPred = Math.max(magic.P, magic.B, magic.T);
                let prediction = '-';
                if (maxPred === magic.P) prediction = 'PLAYER';
                else if (maxPred === magic.B) prediction = 'BANKER';
                else if (maxPred === magic.T) prediction = 'TIE';
                document.getElementById('magicPrediction').textContent = prediction;
                document.getElementById('magicAccuracy').textContent = analyzer.magicNumber.getAccuracy().toFixed(1) + '%';
            } else {
                document.getElementById('magicPhase').textContent = '1';
                document.getElementById('magicCycle').textContent = '0';
                document.getElementById('magicPrediction').textContent = '-';
                document.getElementById('magicAccuracy').textContent = '0%';
            }
        }

        function updateConfidenceMeter(confidence) {
            const fill = document.getElementById('confidenceFill');
            fill.style.width = confidence + '%';
            fill.textContent = confidence.toFixed(0) + '%';
        }

        // Initialize
        updateDisplay();
        analyzeAndPredict();
        updateAccuracyStats();
    </script>
</body>
</html>
