<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H·ªá Th·ªëng Ph√¢n T√≠ch Baccarat To√†n Di·ªán V3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            color: #F9FAFB;
        }
        .btn {
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        /* Golden Signal Styling */
        .golden-signal {
            background: linear-gradient(145deg, #4a3a0a, #a0821c);
            border: 2px solid #FFD700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
            animation: golden-pulse 2s infinite;
        }
        @keyframes golden-pulse {
            0% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.4); }
            50% { box-shadow: 0 0 40px rgba(255, 215, 0, 0.8); }
            100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.4); }
        }
        .no-signal {
            background-color: #1f2937; /* gray-800 */
             border: 2px dashed #4b5563;
        }
        /* Big Road Styles */
        #bigRoadDisplay {
            display: grid;
            grid-auto-flow: column;
            grid-auto-columns: 2.5rem;
            gap: 2px;
            overflow-x: auto;
            padding: 8px;
            scrollbar-width: thin;
            scrollbar-color: #4b5563 #1f2937;
        }
        #bigRoadDisplay::-webkit-scrollbar { height: 6px; }
        #bigRoadDisplay::-webkit-scrollbar-track { background: #1f2937; }
        #bigRoadDisplay::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }
        .road-col { display: grid; grid-auto-rows: 2.5rem; gap: 2px; }
        .road-item {
            width: 2.5rem; height: 2.5rem; border-radius: 9999px;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 1.125rem; color: white;
        }
        /* Session List Item Styles */
        .session-item.active { background-color: #3b82f6; color: white; }
        .session-item.active .text-gray-400 { color: #bfdbfe; }
        .session-item { transition: background-color 0.2s ease-in-out; }
        
        /* Collapsible Settings */
        details > summary { list-style: none; }
        details > summary::-webkit-details-marker { display: none; }
        details summary:before {
            content: '‚ñ∂'; margin-right: 0.5rem; font-size: 0.8em;
            transition: transform 0.2s;
        }
        details[open] > summary:before { transform: rotate(90deg); }
    </style>
</head>
<body class="p-4 md:p-6">
    <div class="max-w-screen-2xl mx-auto">
        <header class="bg-gray-800 p-4 rounded-2xl shadow-lg text-center mb-6">
            <h1 class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 via-orange-500 to-red-500">H·ªá Th·ªëng Ph√¢n T√≠ch To√†n Di·ªán V3</h1>
            <p class="text-gray-400 mt-1">K·∫øt h·ª£p Ph√¢n T√≠ch Chuy√™n S√¢u v√† T√≠n Hi·ªáu Tinh Anh</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 xl:grid-cols-4 gap-6">

            <!-- Left Column: Primary Controls & Big Picture -->
            <div class="lg:col-span-1 xl:col-span-1 space-y-6">
                <!-- Input Section -->
                <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 text-blue-300">üé≤ Nh·∫≠p K·∫øt Qu·∫£</h2>
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <button onclick="addResult('P')" class="py-5 text-xl font-bold bg-blue-600 hover:bg-blue-500 rounded-lg transition">PLAYER</button>
                        <button onclick="addResult('B')" class="py-5 text-xl font-bold bg-red-600 hover:bg-red-500 rounded-lg transition">BANKER</button>
                    </div>
                    <div class="flex gap-4">
                        <button onclick="undoLast()" class="flex-1 py-3 bg-gray-600 hover:bg-gray-500 rounded-lg transition">‚Ü©Ô∏è Ho√†n T√°c</button>
                        <button onclick="clearCurrentSessionHistory()" class="flex-1 py-3 bg-yellow-600 hover:bg-yellow-500 rounded-lg transition">üóëÔ∏è X√≥a L·ªãch S·ª≠</button>
                    </div>
                </div>

                <!-- Session Management -->
                 <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-semibold text-blue-300">üìÅ Qu·∫£n L√Ω Phi√™n</h2>
                        <div class="flex items-center">
                            <input type="checkbox" id="selectAllCheckbox" class="h-4 w-4 rounded bg-gray-700 border-gray-600 text-blue-600 focus:ring-blue-500">
                            <label for="selectAllCheckbox" class="ml-2 text-sm font-medium text-gray-300">Ch·ªçn t·∫•t c·∫£</label>
                        </div>
                    </div>
                    <div id="sessionListContainer" class="space-y-1 bg-gray-900/50 p-2 rounded-lg max-h-48 overflow-y-auto mb-4 border border-gray-700"></div>
                    <div class="grid grid-cols-2 gap-3 mb-4">
                        <button onclick="createNewSession()" class="btn w-full bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-3 rounded-lg text-sm">‚ûï M·ªõi</button>
                        <button onclick="renameSession()" class="btn w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-3 rounded-lg text-sm">‚úèÔ∏è ƒê·ªïi T√™n</button>
                        <button onclick="deleteSelectedSessions()" class="btn w-full bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-3 rounded-lg text-sm">üóëÔ∏è X√≥a Ch·ªçn</button>
                        <button onclick="deleteAllSessions()" class="btn w-full bg-red-800 hover:bg-red-700 text-white font-bold py-2 px-3 rounded-lg text-sm">üí• X√≥a H·∫øt</button>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-4 border-t border-gray-700 pt-4 mt-4">
                        <button onclick="exportData()" class="btn w-full bg-sky-600 hover:bg-sky-500 text-white font-bold py-3 px-4 rounded-lg">üì§ Xu·∫•t</button>
                        <button onclick="document.getElementById('fileInput').click()" class="btn w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-4 rounded-lg">üì• Nh·∫≠p</button>
                        <input type="file" id="fileInput" class="hidden" accept=".json" onchange="importData(event)">
                    </div>
                </div>

                <!-- Analysis Settings (Collapsible) -->
                <details class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                    <summary class="text-xl font-semibold text-purple-300 cursor-pointer">‚öôÔ∏è C√†i ƒê·∫∑t</summary>
                    <div class="mt-6 border-t border-gray-700 pt-4">
                        <p class="text-sm text-gray-400 mb-4">√Åp d·ª•ng cho ch·∫ø ƒë·ªô ph√¢n t√≠ch to√†n di·ªán.</p>
                        <div class="space-y-4">
                            <div>
                                <label for="minPatternLength" class="block text-sm font-medium text-gray-300 mb-1">ƒê·ªô d√†i c·∫ßu t·ªëi thi·ªÉu</label>
                                <input type="number" id="minPatternLength" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white">
                            </div>
                            <div>
                                <label for="maxPatternLength" class="block text-sm font-medium text-gray-300 mb-1">ƒê·ªô d√†i c·∫ßu t·ªëi ƒëa</label>
                                <input type="number" id="maxPatternLength" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white">
                            </div>
                            <div>
                                <label for="minCertainOccurrences" class="block text-sm font-medium text-gray-300 mb-1">S·ªë l·∫ßn l·∫∑p l·∫°i cho "Tay Ch·∫Øc Ch·∫Øn"</label>
                                <input type="number" id="minCertainOccurrences" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white">
                            </div>
                        </div>
                        <button onclick="saveSettings()" class="btn w-full mt-6 bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-4 rounded-lg">L∆∞u C√†i ƒê·∫∑t</button>
                    </div>
                </details>
            </div>

            <!-- Center Column: Analysis & Signals -->
            <div class="lg:col-span-2 xl:col-span-2 space-y-6">
                <!-- Golden Signal -->
                <div id="signal-display" class="p-6 rounded-2xl text-center transition-all duration-500 no-signal">
                     <div id="signal-content">
                        <i class="fas fa-search text-5xl text-gray-500 mb-2"></i>
                        <h2 class="text-2xl font-bold text-gray-400">ƒêang Ch·ªù T√≠n Hi·ªáu V√†ng...</h2>
                    </div>
                </div>
                
                 <!-- Main Analysis -->
                <div id="analysis-card" class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 text-yellow-300">üß† Ph√¢n T√≠ch To√†n Di·ªán</h2>
                    <div id="analysisResult"></div>
                </div>

                <!-- Trend Analysis -->
                <div id="trend-analysis-card" class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 text-indigo-300"><i class="fa-solid fa-arrows-rotate mr-2"></i>Ph√¢n T√≠ch Xu H∆∞·ªõng Ng∆∞·ª£c</h2>
                    <div id="trendAnalysisResult" class="text-center"></div>
                </div>
                
                 <!-- Big Road -->
                <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-semibold text-blue-300">üìú B·∫£ng C·∫ßu Big Road</h2>
                        <span class="text-gray-400 font-medium">T·ªïng: <span id="totalGames">0</span> v√°n</span>
                    </div>
                    <div class="bg-gray-900 rounded-lg min-h-[280px] border border-gray-700">
                        <div id="bigRoadDisplay"></div>
                    </div>
                </div>
            </div>
            
            <!-- Right Column: Stats & History -->
            <div class="lg:col-span-3 xl:col-span-1 space-y-6">
                <!-- Stats Cluster -->
                <div class="bg-gray-800 p-6 rounded-2xl shadow-lg space-y-6">
                    <div>
                        <h2 class="text-xl font-semibold mb-4 text-green-300">üéØ Th·ªëng K√™ (Phi√™n Hi·ªán T·∫°i)</h2>
                        <div class="space-y-4">
                            <div class="flex justify-between items-center bg-gray-700/50 p-3 rounded-lg"><span class="font-medium text-gray-300 text-sm">T·ª∑ L·ªá Th·∫Øng</span><span id="accuracyRate" class="text-xl font-bold text-green-400">0.0%</span></div>
                            <div class="flex justify-between items-center bg-gray-700/50 p-3 rounded-lg"><span class="font-medium text-gray-300 text-sm">Th·∫Øng / T·ªïng</span><div><span id="correctPredictions" class="text-base font-semibold">0</span><span class="text-gray-400">/</span><span id="totalPredictions" class="text-base font-semibold">0</span></div></div>
                        </div>
                    </div>
                    <hr class="border-gray-700">
                    <div>
                         <h2 class="text-xl font-semibold mb-4 text-cyan-300">üåê Th·ªëng K√™ (To√†n C·ª•c)</h2>
                        <div class="space-y-4">
                            <div class="flex justify-between items-center bg-gray-700/50 p-3 rounded-lg"><span class="font-medium text-gray-300 text-sm">T·ª∑ L·ªá Th·∫Øng</span><span id="globalAccuracyRate" class="text-xl font-bold text-cyan-400">0.0%</span></div>
                            <div class="flex justify-between items-center bg-gray-700/50 p-3 rounded-lg"><span class="font-medium text-gray-300 text-sm">Th·∫Øng / T·ªïng</span><div><span id="globalCorrectPredictions" class="text-base font-semibold">0</span><span class="text-gray-400">/</span><span id="globalTotalPredictions" class="text-base font-semibold">0</span></div></div>
                        </div>
                    </div>
                     <hr class="border-gray-700">
                    <div>
                        <h2 class="text-xl font-semibold mb-4 text-indigo-300">üìà Th·ªëng K√™ Xu H∆∞·ªõng Ng∆∞·ª£c</h2>
                        <div class="space-y-4">
                             <div class="flex justify-between items-center bg-gray-700/50 p-3 rounded-lg"><span class="font-medium text-gray-300 text-sm">T·ª∑ L·ªá Th·∫Øng</span><span id="trendAccuracyRate" class="text-xl font-bold text-indigo-400">0.0%</span></div>
                            <div class="flex justify-between items-center bg-gray-700/50 p-3 rounded-lg"><span class="font-medium text-gray-300 text-sm">Th·∫Øng / T·ªïng</span><div><span id="trendCorrectPredictions" class="text-base font-semibold">0</span><span class="text-gray-400">/</span><span id="trendTotalPredictions" class="text-base font-semibold">0</span></div></div>
                        </div>
                    </div>
                     <hr class="border-gray-700">
                     <div>
                        <h2 class="text-xl font-semibold mb-4 text-yellow-300">‚≠ê Th·ªëng K√™ T√≠n Hi·ªáu V√†ng</h2>
                        <div class="space-y-4">
                             <div class="flex justify-between items-center bg-gray-700/50 p-3 rounded-lg"><span class="font-medium text-gray-300 text-sm">T·ª∑ L·ªá Th·∫Øng</span><span id="goldenSignalAccuracyRate" class="text-xl font-bold text-yellow-400">0.0%</span></div>
                            <div class="flex justify-between items-center bg-gray-700/50 p-3 rounded-lg"><span class="font-medium text-gray-300 text-sm">Th·∫Øng / T·ªïng</span><div><span id="goldenSignalCorrect" class="text-base font-semibold">0</span><span class="text-gray-400">/</span><span id="goldenSignalTotal" class="text-base font-semibold">0</span></div></div>
                        </div>
                    </div>
                </div>

                <!-- Confidence Stats Table -->
                <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-2 text-blue-300">üìä Th·ªëng K√™ ƒê·ªô Tin C·∫≠y</h2>
                    <div id="confidenceRecommendation" class="my-4 p-3 bg-gray-900 rounded-lg text-center text-sm"></div>
                    <div class="space-y-2" id="confidenceStatsTable"></div>
                </div>
            </div>
        </div>
    </div>

<script>
// --- GLOBAL STATE ---
let state = {
    currentSessionId: null,
    sessions: {},
    matcher: new PatternMatcher(),
    currentPrediction: null, // For main analysis
    goldenSignal: null, // For elite rules
    goldenRange: null
};

// For Shift-Click functionality
let lastCheckedSessionBox = null;


// --- ELITE RULES ENGINE ---
const expertRules = [
    { name: "B·∫ª B·ªát 2 Tr·∫£ 1 (PP->B)", pattern: ['P', 'P'], prediction: 'B' },
    { name: "B·∫ª B·ªát 2 Tr·∫£ 1 (BB->P)", pattern: ['B', 'B'], prediction: 'P' },
    { name: "C·∫ßu 1-1-2 (PBPB->B)", pattern: ['P', 'B', 'P', 'B'], prediction: 'B' },
    { name: "C·∫ßu 1-1-2 (BPBP->P)", pattern: ['B', 'P', 'B', 'P'], prediction: 'P' },
    { name: "B·ªát 3 Tr·∫£ B·ªát 2 (PPPBB->B)", pattern: ['P', 'P', 'P', 'B', 'B'], prediction: 'B' },
    { name: "B·ªát 3 Tr·∫£ B·ªát 2 (BBBPP->P)", pattern: ['B', 'B', 'B', 'P', 'P'], prediction: 'P' }
];

function checkAllRules(currentHistory) {
    for (const rule of expertRules) {
        if (currentHistory.length < rule.pattern.length) continue;
        const segment = currentHistory.slice(-rule.pattern.length);
        if (segment.every((val, index) => val === rule.pattern[index])) {
            return { prediction: rule.prediction, ruleName: rule.name };
        }
    }
    return null;
}


// --- CORE LOGIC: PATTERN MATCHER (CLASS) ---
function PatternMatcher() {
    this.MIN_HISTORY_FOR_ANALYSIS = 10;
    this.MIN_PATTERN_LENGTH = 10;
    this.MAX_PATTERN_LENGTH = 15;
    this.MIN_CERTAIN_OCCURRENCES = 2;
    this.STREAK_DANGER_THRESHOLD = 5;

    this.calculateSimilarity = (arr1, arr2) => {
        if (arr1.length !== arr2.length || arr1.length === 0) return 0;
        return arr1.filter((item, index) => item === arr2[index]).length / arr1.length;
    };

    this.findPatternOccurrences = (pattern, allHistory) => {
        const occurrences = [];
        const reversedPattern = [...pattern].reverse();
        for (const session of allHistory) {
            const sessionHistory = session.history || [];
            if (sessionHistory.length < pattern.length + 1) continue;
            for (let i = 0; i <= sessionHistory.length - pattern.length - 1; i++) {
                const segment = sessionHistory.slice(i, i + pattern.length);
                const nextResult = sessionHistory[i + pattern.length];
                if (this.calculateSimilarity(pattern, segment) >= 0.9) {
                    occurrences.push({ type: 'similar', next: nextResult, similarity: this.calculateSimilarity(pattern, segment) });
                }
                if (this.calculateSimilarity(reversedPattern, segment) >= 0.9) {
                     occurrences.push({ type: 'reversed', next: nextResult, similarity: this.calculateSimilarity(reversedPattern, segment) });
                }
            }
        }
        return occurrences;
    };
    
    this.getPredictionForPattern = (pattern, allHistoricalSessions) => {
        const occurrences = this.findPatternOccurrences(pattern, allHistoricalSessions);
        if (occurrences.length === 0) return { prediction: null };
        const votes = { P: 0, B: 0 };
        occurrences.forEach(match => { if (votes[match.next] !== undefined) votes[match.next] += match.similarity; });
        const totalVotes = votes.P + votes.B;
        if (totalVotes === 0) return { prediction: null };
        const predictedWinner = votes.P > votes.B ? 'P' : 'B';
        const confidence = (Math.max(votes.P, votes.B) / totalVotes) * 100;
        return { prediction: predictedWinner, confidence, votes };
    };

    this.analyzeCurrentStreak = (currentHistory) => {
        if (currentHistory.length < 2) return { type: 'none', length: 0 };
        const last = currentHistory[currentHistory.length - 1];
        const secondLast = currentHistory[currentHistory.length - 2];
        if (last === secondLast) {
            let length = 0;
            for (let i = currentHistory.length - 1; i >= 0; i--) { if (currentHistory[i] === last) length++; else break; }
            return { type: 'b·ªát', length, value: last };
        } else {
            let length = 0;
            for (let i = currentHistory.length - 1; i >= 1; i--) { if (currentHistory[i] !== currentHistory[i-1]) length++; else break; }
            return { type: '1-1', length: length + 1 };
        }
    };
    
    this.applyHeuristicAdjustments = (prediction, confidence, currentHistory) => {
        if (confidence < 99) return { adjustedConfidence: confidence, warningText: '' };
        const streakInfo = this.analyzeCurrentStreak(currentHistory);
        const isFollowingStreak = (streakInfo.type === 'b·ªát' && prediction === streakInfo.value) || (streakInfo.type === '1-1' && prediction !== currentHistory[currentHistory.length - 1]);
        if (streakInfo.length >= this.STREAK_DANGER_THRESHOLD && isFollowingStreak) {
            return { 
                adjustedConfidence: confidence * 0.85, 
                warningText: `\n\n‚ö†Ô∏è **C·∫£nh b√°o:** C·∫ßu ${streakInfo.type} d√†i (${streakInfo.length} v√°n) c√≥ r·ªßi ro b·ªã b·∫ª g√£y. ƒê·ªô tin c·∫≠y ƒë√£ ƒë∆∞·ª£c ƒëi·ªÅu ch·ªânh.` 
            };
        }
        return { adjustedConfidence: confidence, warningText: '' };
    };

    this.getPrediction = (currentHistory, allHistoricalSessions, { optimalLength, lengthPerformance }) => {
        if (currentHistory.length < this.MIN_HISTORY_FOR_ANALYSIS) {
            return { prediction: null, analysisText: `C·∫ßn √≠t nh·∫•t ${this.MIN_HISTORY_FOR_ANALYSIS} k·∫øt qu·∫£...`, confidence: 0 };
        }

        if (optimalLength && currentHistory.length >= optimalLength) {
            const result = this.getPredictionForPattern(currentHistory.slice(-optimalLength), allHistoricalSessions);
            if (result.prediction) {
                const perf = lengthPerformance[optimalLength] || { wins: 0, total: 0 };
                const rate = perf.total > 0 ? (perf.wins / perf.total * 100).toFixed(1) : 'N/A';
                let analysisText = `S·ª≠ d·ª•ng chi·ªÅu d√†i c·∫ßu t·ªëi ∆∞u: ${optimalLength} v√°n.\n(T·ª∑ l·ªá th·∫Øng: ${rate}%)\n\nL·ªãch s·ª≠ cho th·∫•y:\n- PLAYER: ${result.votes.P.toFixed(1)} ƒëi·ªÉm\n- BANKER: ${result.votes.B.toFixed(1)} ƒëi·ªÉm`;
                const { adjustedConfidence, warningText } = this.applyHeuristicAdjustments(result.prediction, result.confidence, currentHistory);
                analysisText += `\n\nüèÜ ƒê·ªô tin c·∫≠y: ${adjustedConfidence.toFixed(1)}%` + warningText;
                return { prediction: result.prediction, recommendation: 'THEO CHI·ªÄU D√ÄI T·ªêI ∆ØU', analysisText, confidence: adjustedConfidence };
            }
        }
        
        return { prediction: null, analysisText: 'Kh√¥ng t√¨m th·∫•y h√¨nh c·∫ßu t∆∞∆°ng t·ª±.', confidence: 0 };
    };
}


// --- UI UPDATE FUNCTIONS ---
function updateAllUI() {
    const session = state.sessions[state.currentSessionId] || { history: [] };
    
    updateBigRoadUI();
    updateSignalUI();
    updateAnalysisUI();
    updateTrendAnalysisUI();

    updateStatsUI('accuracyRate', 'correctPredictions', 'totalPredictions', session.predictions || []);
    updateStatsUI('goldenSignalAccuracyRate', 'goldenSignalCorrect', 'goldenSignalTotal', session.goldenSignalPredictions || []);
    updateTrendStatsUI();
    updateGlobalStatsUI();
    
    updateConfidenceStatsUI();
    updateSessionListUI();
}

function updateSignalUI() {
    const displayDiv = document.getElementById('signal-display');
    const contentDiv = document.getElementById('signal-content');
    if (state.goldenSignal) {
        displayDiv.classList.remove('no-signal');
        displayDiv.classList.add('golden-signal');
        const resultText = state.goldenSignal.prediction === 'P' ? 'PLAYER' : 'BANKER';
        const icon = state.goldenSignal.prediction === 'P' ? 'üë§' : 'üè¶';
        contentDiv.innerHTML = `<i class="fas fa-star text-5xl text-yellow-300 mb-2"></i><h2 class="text-2xl font-bold text-white">T√çN HI·ªÜU V√ÄNG!</h2><p class="text-yellow-200 mt-1">${state.goldenSignal.ruleName}</p><div class="bg-black/30 rounded-lg p-2 mt-2"><p class="text-lg">ƒê·ªÅ xu·∫•t:</p><p class="text-4xl font-extrabold">${icon} ${resultText}</p></div>`;
    } else {
        displayDiv.classList.add('no-signal');
        displayDiv.classList.remove('golden-signal');
        contentDiv.innerHTML = `<i class="fas fa-search text-5xl text-gray-500 mb-2"></i><h2 class="text-2xl font-bold text-gray-400">ƒêang Ch·ªù T√≠n Hi·ªáu V√†ng...</h2>`;
    }
}

function updateAnalysisUI() {
    const resultDiv = document.getElementById('analysisResult');
    const { prediction, recommendation, analysisText } = state.currentPrediction || {};

    if (prediction) {
        const resultText = prediction === 'P' ? 'PLAYER' : 'BANKER';
        const icon = prediction === 'P' ? 'üë§' : 'üè¶';
        const borderColor = prediction === 'P' ? 'border-blue-500' : 'border-red-500';
        const textColor = prediction === 'P' ? 'text-blue-400' : 'text-red-400';
        
        resultDiv.innerHTML = `
            <div class="bg-gray-700 p-4 rounded-lg text-sm mb-4"><p class="whitespace-pre-wrap">${analysisText || ''}</p></div>
            <div class="text-center bg-gray-900 py-4 rounded-lg border-2 ${borderColor}">
                <p class="text-lg text-gray-400">${recommendation || 'ƒê·ªÅ xu·∫•t'}</p>
                <p class="text-4xl font-bold mt-1 ${textColor}">${icon} ${resultText}</p>
            </div>`;
    } else {
        resultDiv.innerHTML = `<p class="text-gray-400 text-center py-8">${analysisText || 'C·∫ßn th√™m d·ªØ li·ªáu...'}</p>`;
    }
}


function getPredictionStats(predictions = []) {
    const total = predictions.length;
    if (total === 0) return { rate: 0, correct: 0, total: 0 };
    const correct = predictions.filter(p => p.predicted === p.actual).length;
    return { rate: (correct / total) * 100, correct, total };
}

function updateStatsUI(rateId, correctId, totalId, predictions) {
    const stats = getPredictionStats(predictions);
    document.getElementById(rateId).textContent = stats.total > 0 ? `${stats.rate.toFixed(1)}%` : 'N/A';
    document.getElementById(correctId).textContent = stats.correct;
    document.getElementById(totalId).textContent = stats.total;
}

function updateGlobalStatsUI() {
    const allPredictions = Object.values(state.sessions).flatMap(s => s.predictions || []);
    updateStatsUI('globalAccuracyRate', 'globalCorrectPredictions', 'globalTotalPredictions', allPredictions);
}

function updateTrendStatsUI() {
     const session = state.sessions[state.currentSessionId] || {};
     updateStatsUI('trendAccuracyRate', 'trendCorrectPredictions', 'trendTotalPredictions', session.trendPredictions || []);
}


function updateBigRoadUI() {
    const history = state.sessions[state.currentSessionId]?.history || [];
    const roadDiv = document.getElementById('bigRoadDisplay');
    document.getElementById('totalGames').textContent = history.length;

    if (history.length === 0) {
        roadDiv.innerHTML = '<p class="text-gray-500 p-4">Ch∆∞a c√≥ k·∫øt qu·∫£...</p>';
        roadDiv.style.display = 'block';
        return;
    }
    roadDiv.style.display = 'grid';
    roadDiv.innerHTML = '';

    const columns = [];
    if (history.length > 0) {
        let currentCol = [history[0]];
        for (let i = 1; i < history.length; i++) {
            if (history[i] === history[i-1]) {
                currentCol.push(history[i]);
            } else {
                columns.push(currentCol);
                currentCol = [history[i]];
            }
        }
        columns.push(currentCol);
    }

    columns.forEach(colData => {
        const colDiv = document.createElement('div');
        colDiv.className = 'road-col';
        colData.forEach(item => {
            const itemDiv = document.createElement('div');
            const bgColor = item === 'P' ? 'bg-blue-600' : 'bg-red-600';
            itemDiv.className = `road-item ${bgColor}`;
            itemDiv.textContent = item;
            colDiv.appendChild(itemDiv);
        });
        roadDiv.appendChild(colDiv);
    });

    roadDiv.scrollLeft = roadDiv.scrollWidth;
}
function updateConfidenceStatsUI() {

if (!state.currentSessionId || !state.sessions[state.currentSessionId]) return;



const sessionPredictions = state.sessions[state.currentSessionId].predictions || [];

const ranges = [

{min: 50, max: 60, total: 0, wins: 0},

{min: 60, max: 70, total: 0, wins: 0},

{min: 70, max: 80, total: 0, wins: 0},

{min: 80, max: 90, total: 0, wins: 0},

{min: 90, max: 100, total: 0, wins: 0},

];



const tableDiv = document.getElementById('confidenceStatsTable');

const recommendationDiv = document.getElementById('confidenceRecommendation');

const currentConfidence = state.currentPrediction?.confidence;
const previousConfidence = sessionPredictions.length > 0 ? sessionPredictions[sessionPredictions.length - 1].confidence : null;


let bestRange = null;

let maxRate = -1;



ranges.forEach(range => {

const predictionsForRange = sessionPredictions.filter(p => {

const confidence = p.confidence;

return confidence >= range.min && (confidence < range.max || (range.max === 100 && confidence >= 100));

});

range.total = predictionsForRange.length;

range.wins = predictionsForRange.filter(p => p.predicted === p.actual).length;

const rate = range.total > 0 ? ((range.wins / range.total) * 100) : -1;

range.rate = rate;

if (range.total >= 3 && rate > maxRate) {

maxRate = rate;

bestRange = range;

}

});


state.goldenRange = bestRange;



if (bestRange) {

recommendationDiv.innerHTML = `<p class="text-yellow-300"><span class="font-bold">‚ú® Kho·∫£ng V√†ng:</span> T·ª∑ l·ªá th·∫Øng cao nh·∫•t l√† <b class="text-blue-400">${maxRate.toFixed(1)}%</b> trong kho·∫£ng <b class="text-white">${bestRange.min}%-${bestRange.max}%</b>.</p>`;

} else {

recommendationDiv.innerHTML = `<p class="text-gray-400">Ch∆∞a ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ t√¨m ra kho·∫£ng v√†ng.</p>`;

}
}
function updateTrendAnalysisUI() {
¬† ¬† const resultDiv = document.getElementById('trendAnalysisResult');
¬† ¬† const { prediction, confidence } = state.currentPrediction || {};
¬† ¬†¬†
¬† ¬† if (!prediction) {
¬† ¬† ¬† ¬† resultDiv.innerHTML = '<p class="text-gray-400 py-8">Ch·ªù ph√°n ƒëo√°n ti·∫øp theo...</p>';
¬† ¬† ¬† ¬† return;
¬† ¬† }

¬† ¬† const sessionPredictions = state.sessions[state.currentSessionId]?.predictions || [];
¬† ¬† const confidenceRanges = [
¬† ¬† ¬† ¬† {min: 50, max: 60}, {min: 60, max: 70}, {min: 70, max: 80},
¬† ¬† ¬† ¬† {min: 80, max: 90}, {min: 90, max: 100}
¬† ¬† ];

¬† ¬† const currentRange = confidenceRanges.find(r => confidence >= r.min && (confidence < r.max || (r.max === 100 && confidence >= 100)));

¬† ¬† if (!currentRange) {
¬† ¬† ¬† ¬† ¬†resultDiv.innerHTML = '<p class="text-gray-500 py-4">ƒê·ªô tin c·∫≠y d∆∞·ªõi 50%, kh√¥ng √°p d·ª•ng ph√¢n t√≠ch.</p>';
¬† ¬† ¬† ¬† return;
¬† ¬† }

¬† ¬† const predictionsInSameRange = sessionPredictions.filter(p => {
¬† ¬† ¬† ¬† return p.confidence >= currentRange.min && (p.confidence < currentRange.max || (p.confidence === 100 && currentRange.max === 100));
¬† ¬† });

¬† ¬† if (predictionsInSameRange.length === 0) {
¬† ¬† ¬† ¬† resultDiv.innerHTML = `<p class="text-gray-400 py-4">Ch∆∞a c√≥ d·ªØ li·ªáu xu h∆∞·ªõng cho kho·∫£ng ${currentRange.min}-${currentRange.max}%.</p>`;
¬† ¬† ¬† ¬† return;
¬† ¬† }

¬† ¬† const lastPredictionInRage = predictionsInSameRange[predictionsInSameRange.length - 1];
¬† ¬† const wasLastOneWrong = lastPredictionInRage.predicted !== lastPredictionInRage.actual;
¬† ¬†¬†
¬† ¬† let finalSuggestion, recommendationText, iconClass, textColor, borderColor;

¬† ¬† if (wasLastOneWrong) {
¬† ¬† ¬† ¬† finalSuggestion = prediction === 'P' ? 'B' : 'P';
¬† ¬† ¬† ¬† recommendationText = 'ƒê·ªÄ XU·∫§T NG∆Ø·ª¢C';
¬† ¬† ¬† ¬† iconClass = 'fa-solid fa-repeat text-yellow-400';
¬† ¬† ¬† ¬† textColor = 'text-yellow-400';
¬† ¬† ¬† ¬† borderColor = 'border-yellow-500';
¬† ¬† } else {
¬† ¬† ¬† ¬† finalSuggestion = prediction;
¬† ¬† ¬† ¬† recommendationText = 'THEO XU H∆Ø·ªöNG';
¬† ¬† ¬† ¬† iconClass = 'fa-solid fa-arrow-trend-up text-green-400';
¬† ¬† ¬† ¬† textColor = 'text-green-400';
¬† ¬† ¬† ¬† borderColor = 'border-green-500';
¬† ¬† }

¬† ¬† const infoText = wasLastOneWrong ? 'V√°n tr∆∞·ªõc trong kho·∫£ng n√†y ƒë√£ SAI' : 'V√°n tr∆∞·ªõc trong kho·∫£ng n√†y ƒë√£ ƒê√öNG';
¬† ¬†¬†
¬† ¬† resultDiv.innerHTML = `
¬† ¬† ¬† ¬† <div class="text-center bg-gray-900 py-4 rounded-lg border-2 ${borderColor}">
¬† ¬† ¬† ¬† ¬† ¬† <p class="text-lg text-gray-400 mb-2 flex items-center justify-center gap-2">
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† <i class="${iconClass}"></i>
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† <span class="${textColor} font-extrabold text-2xl">${recommendationText}</span>
¬† ¬† ¬† ¬† ¬† ¬† </p>
¬† ¬† ¬† ¬† ¬† ¬† <p class="text-4xl font-bold mt-2">${finalSuggestion === 'P' ? 'üë§ PLAYER' : 'üè¶ BANKER'}</p>
¬† ¬† ¬† ¬† ¬† ¬† <p class="text-xs text-gray-500 mt-2">(${infoText})</p>
¬† ¬† ¬† ¬† </div>`;
}

function updateSessionListUI() {
¬† ¬† const container = document.getElementById('sessionListContainer');
¬† ¬† container.innerHTML = '';
¬† ¬† const sortedKeys = Object.keys(state.sessions).sort((a, b) => parseInt(b.split('-')[1]) - parseInt(a.split('-')[1]));

¬† ¬† if (sortedKeys.length === 0) {
¬† ¬† ¬† ¬† container.innerHTML = '<p class="text-center text-gray-500 p-4">Kh√¥ng c√≥ phi√™n n√†o.</p>';
¬† ¬† ¬† ¬† return;
¬† ¬† }

¬† ¬† sortedKeys.forEach((sessionId) => {
¬† ¬† ¬† ¬† const session = state.sessions[sessionId];
¬† ¬† ¬† ¬† const isActive = sessionId === state.currentSessionId;

¬† ¬† ¬† ¬† const itemDiv = document.createElement('div');
¬† ¬† ¬† ¬† itemDiv.className = `session-item flex items-center justify-between p-2 rounded-md hover:bg-gray-700 cursor-pointer ${isActive ? 'active' : 'bg-gray-800'}`;
¬† ¬† ¬† ¬† itemDiv.dataset.sessionId = sessionId;

¬† ¬† ¬† ¬† itemDiv.innerHTML = `
            <div class="flex items-center gap-3">
                <input type="checkbox" onclick="event.stopPropagation()" class="session-checkbox h-5 w-5 rounded bg-gray-600 border-gray-500 text-blue-500 focus:ring-blue-600 focus:ring-offset-gray-800 shrink-0">
                <div class="flex flex-col"><span class="font-semibold text-sm">${session.name}</span><span class="text-xs text-gray-400">${session.history.length} v√°n</span></div>
            </div>
            ${isActive ? `<span class="text-xs font-bold bg-gray-900/50 px-2 py-1 rounded-full">ƒêang ch·ªçn</span>` : ''}
        `;
¬† ¬† ¬† ¬† container.appendChild(itemDiv);
¬† ¬† });
¬† ¬† lastCheckedSessionBox = null;
¬† ¬† document.getElementById('selectAllCheckbox').checked = false;
}
// --- EVENT HANDLERS & ACTIONS ---

function addResult(result) {
    if (!state.currentSessionId) return;
    const session = state.sessions[state.currentSessionId];
    
    // 1. Check for golden signal BEFORE adding the new result, and record it
    const lastGoldenSignal = checkAllRules(session.history);
    if (lastGoldenSignal) {
        session.goldenSignalPredictions.push({
            predicted: lastGoldenSignal.prediction,
            actual: result,
            ruleName: lastGoldenSignal.ruleName
        });
    }

    // 2. Record main prediction outcome
    if (state.currentPrediction && state.currentPrediction.prediction) {
        const { prediction: mainPrediction, confidence } = state.currentPrediction;
        session.predictions.push({ predicted: mainPrediction, actual: result, confidence: confidence });
        
        // 3. Record trend prediction outcome
        const confidenceRanges = [{min: 50, max: 60}, {min: 60, max: 70}, {min: 70, max: 80}, {min: 80, max: 90}, {min: 90, max: 100}];
        const currentRange = confidenceRanges.find(r => confidence >= r.min && (confidence < r.max || (confidence === 100 && r.max === 100)));
        if (currentRange) {
            const predictionsInSameRange = session.predictions.filter(p => p.confidence >= currentRange.min && (p.confidence < currentRange.max || (p.confidence === 100 && currentRange.max === 100)));
            if (predictionsInSameRange.length > 1) { // Need at least one previous prediction to determine trend
                const lastInRage = predictionsInSameRange[predictionsInSameRange.length - 2]; // The one before the just-added one
                const wasLastWrong = lastInRage.predicted !== lastInRage.actual;
                let trendSuggestion = wasLastWrong ? (mainPrediction === 'P' ? 'B' : 'P') : mainPrediction;
                session.trendPredictions.push({ predicted: trendSuggestion, actual: result });
            }
        }
    }

    // 4. Add the new result to history
    session.history.push(result);
    
    // 5. Run new analysis and save
    runFullAnalysis();
    saveSessions();
    updateAllUI();
}

function runFullAnalysis() {
    if (!state.currentSessionId) return;
    const session = state.sessions[state.currentSessionId];
    const allHistory = Object.values(state.sessions);

    // Get main prediction
    state.currentPrediction = state.matcher.getPrediction(session.history, allHistory, {
        optimalLength: session.optimalLength,
        lengthPerformance: session.lengthPerformance
    });

    // Get golden signal
    state.goldenSignal = checkAllRules(session.history);
}
function undoLast() {
    if (!state.currentSessionId || !state.sessions[state.currentSessionId].history.length === 0) return;
    const session = state.sessions[state.currentSessionId];
    
    // Determine if the last action resulted in a prediction being stored
    const lastResult = session.history.pop();
    const historyForCheck = session.history;

    const lastMainPrediction = session.predictions.length > 0 ? session.predictions[session.predictions.length-1] : null;

    // A prediction is made when history is >= MIN_HISTORY
    if (historyForCheck.length >= state.matcher.MIN_HISTORY_FOR_ANALYSIS -1) {
        if(session.predictions.length > 0) session.predictions.pop();
        if(session.trendPredictions.length > 0) session.trendPredictions.pop();
    }

    const wasGoldenSignal = checkAllRules(historyForCheck);
    if(wasGoldenSignal && session.goldenSignalPredictions.length > 0) {
        session.goldenSignalPredictions.pop();
    }
    
    runFullAnalysis();
    saveSessions();
    updateAllUI();
}
function clearCurrentSessionHistory() {
    if (!state.currentSessionId) return;
    if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô l·ªãch s·ª≠ v√† th·ªëng k√™ c·ªßa phi√™n n√†y kh√¥ng?')) {
        const session = state.sessions[state.currentSessionId];
        session.history = [];
        session.predictions = [];
        session.trendPredictions = [];
        session.goldenSignalPredictions = [];
        session.lengthPerformance = {};
        session.optimalLength = null;
        runFullAnalysis();
        saveSessions();
        updateAllUI();
    }
}


// --- SESSION MANAGEMENT & DATA I/O ---
function getSessions() { try { return JSON.parse(localStorage.getItem('baccaratUnifiedState_v3')) || {}; } catch (e) { return {}; } }
function saveSessions() { localStorage.setItem('baccaratUnifiedState_v3', JSON.stringify(state.sessions)); localStorage.setItem('lastActiveSession_v3', state.currentSessionId); }

function createNewSession() {
    const newId = `session-${Date.now()}`;
    state.sessions[newId] = { name: `Phi√™n ${new Date().toLocaleString('vi-VN')}`, history: [], predictions: [], trendPredictions: [], goldenSignalPredictions: [], lengthPerformance: {}, optimalLength: null };
    loadSession(newId);
}

function loadSession(sessionId) {
    if (state.sessions[sessionId]) {
        state.currentSessionId = sessionId;
        runFullAnalysis();
        saveSessions();
        updateAllUI();
    }
}

function renameSession() {
    if (!state.currentSessionId) return;
    const newName = prompt("Nh·∫≠p t√™n m·ªõi cho phi√™n:", state.sessions[state.currentSessionId].name);
    if (newName && newName.trim() !== "") {
        state.sessions[state.currentSessionId].name = newName.trim();
        saveSessions();
        updateSessionListUI();
    }
}

function deleteSelectedSessions() {
    const selectedIds = [...document.querySelectorAll('.session-checkbox:checked')].map(cb => cb.closest('.session-item').dataset.sessionId);
    if (selectedIds.length === 0 || selectedIds.length >= Object.keys(state.sessions).length) {
        alert('Vui l√≤ng ch·ªçn phi√™n ƒë·ªÉ x√≥a (kh√¥ng th·ªÉ x√≥a t·∫•t c·∫£).');
        return;
    }
    if (confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a ${selectedIds.length} phi√™n ƒë√£ ch·ªçn?`)) {
        let newCurrentId = state.currentSessionId;
        selectedIds.forEach(id => {
            if (id === state.currentSessionId) newCurrentId = null;
            delete state.sessions[id];
        });
        if (!newCurrentId) {
            const remainingKeys = Object.keys(state.sessions).sort((a, b) => parseInt(b.split('-')[1]) - parseInt(a.split('-')[1]));
            newCurrentId = remainingKeys.length > 0 ? remainingKeys[0] : null;
        }
        if(newCurrentId) loadSession(newCurrentId);
        else initializeApp();
    }
}

function deleteAllSessions() {
     if (confirm('C·∫¢NH B√ÅO: H√†nh ƒë·ªông n√†y s·∫Ω x√≥a T·∫§T C·∫¢ c√°c phi√™n v√† kh√¥ng th·ªÉ ho√†n t√°c. B·∫°n c√≥ ch·∫Øc ch·∫Øn?')) {
        state.sessions = {};
        state.currentSessionId = null;
        initializeApp();
    }
}

function exportData() {
    if (Object.keys(state.sessions).length === 0) { alert("Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t."); return; }
    const dataStr = JSON.stringify(state.sessions, null, 2);
    const dataBlob = new Blob([dataStr], {type: "application/json"});
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.download = `baccarat_unified_v3_backup_${new Date().toISOString().slice(0,10)}.json`;
    link.href = url;
    link.click();
    URL.revokeObjectURL(url);
}

function importData(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const importedSessions = JSON.parse(e.target.result);
            if (typeof importedSessions !== 'object') throw new Error("Invalid format");
             if (confirm('D·ªØ li·ªáu hi·ªán t·∫°i s·∫Ω b·ªã ghi ƒë√®. B·∫°n c√≥ mu·ªën ti·∫øp t·ª•c?')) {
                // Compatibility check loop
                Object.values(importedSessions).forEach(session => {
                    if (!session.goldenSignalPredictions) session.goldenSignalPredictions = [];
                    if (!session.trendPredictions) session.trendPredictions = [];
                    if (!session.predictions) session.predictions = [];
                     if (!session.lengthPerformance) session.lengthPerformance = {};
                });
                state.sessions = importedSessions;
                const firstSessionId = Object.keys(importedSessions).sort((a, b) => parseInt(b.split('-')[1]) - parseInt(a.split('-')[1]))[0];
                loadSession(firstSessionId);
                alert('Nh·∫≠p d·ªØ li·ªáu th√†nh c√¥ng!');
            }
        } catch (error) { alert('L·ªói: File d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá.'); console.error(error); } 
        finally { event.target.value = ''; }
    };
    reader.readAsText(file);
}

function saveSettings() {
    state.matcher.MIN_PATTERN_LENGTH = parseInt(document.getElementById('minPatternLength').value, 10);
    state.matcher.MAX_PATTERN_LENGTH = parseInt(document.getElementById('maxPatternLength').value, 10);
    state.matcher.MIN_CERTAIN_OCCURRENCES = parseInt(document.getElementById('minCertainOccurrences').value, 10);
    alert('C√†i ƒë·∫∑t ƒë√£ ƒë∆∞·ª£c l∆∞u!');
    runFullAnalysis();
    updateAllUI();
}

function loadSettings() {
    document.getElementById('minPatternLength').value = state.matcher.MIN_PATTERN_LENGTH;
    document.getElementById('maxPatternLength').value = state.matcher.MAX_PATTERN_LENGTH;
    document.getElementById('minCertainOccurrences').value = state.matcher.MIN_CERTAIN_OCCURRENCES;
}


// --- INITIALIZATION ---
function initializeApp() {
    state.sessions = getSessions();
    // Ensure compatibility for all loaded sessions
    Object.values(state.sessions).forEach(s => {
        if (!s.goldenSignalPredictions) s.goldenSignalPredictions = [];
        if (!s.trendPredictions) s.trendPredictions = [];
        if (!s.predictions) s.predictions = [];
        if (!s.lengthPerformance) s.lengthPerformance = {};
    });

    const lastActiveId = localStorage.getItem('lastActiveSession_v3');
    
    if (Object.keys(state.sessions).length === 0) {
        createNewSession();
    } else {
        const idToLoad = (lastActiveId && state.sessions[lastActiveId]) ? lastActiveId : Object.keys(state.sessions).sort((a, b) => parseInt(b.split('-')[1]) - parseInt(a.split('-')[1]))[0];
        loadSession(idToLoad);
    }
    loadSettings();
    setupEventListeners();
}
function setupEventListeners() {
¬† ¬† const container = document.getElementById('sessionListContainer');
¬† ¬† container.addEventListener('click', (e) => {
¬† ¬† ¬† ¬† const item = e.target.closest('.session-item');
¬† ¬† ¬† ¬† if (!item) return;
¬† ¬† ¬† ¬† const sessionId = item.dataset.sessionId;
¬† ¬† ¬† ¬† const checkbox = item.querySelector('.session-checkbox');
¬† ¬† ¬† ¬† if (!e.target.matches('.session-checkbox')) {
¬† ¬† ¬† ¬† ¬† ¬† loadSession(sessionId);
¬† ¬† ¬† ¬† } else {
           if (e.shiftKey && lastCheckedSessionBox) {
                const allCheckboxes = [...container.querySelectorAll('.session-checkbox')];
                const start = allCheckboxes.indexOf(lastCheckedSessionBox);
                const end = allCheckboxes.indexOf(checkbox);
                allCheckboxes.slice(Math.min(start, end), Math.max(start, end) + 1).forEach(box => box.checked = checkbox.checked);
            }
            lastCheckedSessionBox = checkbox;
        }
¬† ¬† });
¬† ¬† document.getElementById('selectAllCheckbox').addEventListener('change', (e) => {
¬† ¬† ¬† ¬† document.querySelectorAll('.session-checkbox').forEach(box => box.checked = e.target.checked);
¬† ¬† });
}

document.addEventListener('DOMContentLoaded', initializeApp);

</script>
</body>
</html>

