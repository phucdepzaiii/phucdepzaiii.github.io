<!DOCTYPE html>

<html lang="vi">

<head>

<meta charset="UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>H·ªá Th·ªëng Ph√¢n T√≠ch C·∫ßu (Th·ªëng K√™ N√¢ng Cao)</title>

<script src="https://cdn.tailwindcss.com"></script>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

<style>

body {

font-family: 'Inter', sans-serif;

background-color: #111827; /* Tailwind gray-900 */

color: #F9FAFB; /* Tailwind gray-50 */

}

.btn {

transition: all 0.3s ease;

box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);

}

.btn:hover {

transform: translateY(-2px);

box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);

}

.btn:active {

transform: translateY(1px);

}

.card-glow-p {

box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);

}

.card-glow-b {

box-shadow: 0 0 20px rgba(239, 68, 68, 0.5);

}

.card-glow-certain {

box-shadow: 0 0 25px rgba(250, 204, 21, 0.7);

}

/* Big Road Styles */

#bigRoadDisplay {

display: grid;

grid-auto-flow: column;

grid-auto-columns: 2.5rem; /* 40px */

gap: 2px;

overflow-x: auto;

padding: 8px;

}

.road-col {

display: grid;

grid-auto-rows: 2.5rem; /* 40px */

gap: 2px;

}

.road-item {

width: 2.5rem; /* 40px */

height: 2.5rem; /* 40px */

border-radius: 9999px;

display: flex;

align-items: center;

justify-content: center;

font-weight: bold;

font-size: 1.125rem; /* 18px */

color: white;

animation: fadeIn 0.5s ease;

}

@keyframes fadeIn {

from { opacity: 0; transform: scale(0.8); }

to { opacity: 1; transform: scale(1); }

}

</style>

</head>

<body class="p-4 md:p-8">



<div class="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-3 gap-6">



<!-- Left Column: Input & History -->

<div class="lg:col-span-2 space-y-6">

<!-- Header -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg text-center">

<h1 class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-red-400">H·ªá Th·ªëng Ph√¢n T√≠ch H√¨nh C·∫ßu</h1>

<p class="text-gray-400 mt-2">Ghi nh·ªõ - ƒê·ªëi chi·∫øu - Ph√°n ƒëo√°n</p>

</div>



<!-- Session Management -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<h2 class="text-xl font-semibold mb-4 text-blue-300">üìÅ Qu·∫£n L√Ω Phi√™n</h2>

<div class="flex flex-col sm:flex-row gap-4 mb-4">

<select id="sessionSelector" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"></select>

<div class="grid grid-cols-2 sm:grid-cols-3 gap-4">

<button onclick="createNewSession()" class="btn w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-4 rounded-lg">‚ûï M·ªõi</button>

<button onclick="renameSession()" class="btn w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-4 rounded-lg">‚úèÔ∏è ƒê·ªïi T√™n</button>

<button onclick="deleteSelectedSession()" class="btn w-full bg-red-600 hover:bg-red-500 text-white font-bold py-3 px-4 rounded-lg">üóëÔ∏è X√≥a</button>

</div>

</div>

<!-- Import/Export -->

<div class="flex flex-col sm:flex-row gap-4">

<button onclick="exportData()" class="btn w-full bg-sky-600 hover:bg-sky-500 text-white font-bold py-3 px-4 rounded-lg">üì§ Xu·∫•t D·ªØ Li·ªáu</button>

<button onclick="document.getElementById('fileInput').click()" class="btn w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-4 rounded-lg">üì• Nh·∫≠p D·ªØ Li·ªáu</button>

<input type="file" id="fileInput" class="hidden" accept=".json" onchange="importData(event)">

</div>

</div>



<!-- Input Section -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<h2 class="text-xl font-semibold mb-4 text-blue-300">üé≤ Nh·∫≠p K·∫øt Qu·∫£ V√°n Hi·ªán T·∫°i</h2>

<div class="grid grid-cols-2 gap-4 mb-4">

<button onclick="addResult('P')" class="btn bg-blue-600 hover:bg-blue-500 text-white font-bold py-6 rounded-lg text-2xl">

<span>üë§</span> PLAYER

</button>

<button onclick="addResult('B')" class="btn bg-red-600 hover:bg-red-500 text-white font-bold py-6 rounded-lg text-2xl">

<span>üè¶</span> BANKER

</button>

</div>

<div class="flex gap-4">

<button onclick="undoLast()" class="btn flex-1 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg">‚Ü©Ô∏è Ho√†n T√°c</button>

<button onclick="clearCurrentSessionHistory()" class="btn flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg">üóëÔ∏è X√≥a L·ªãch S·ª≠</button>

</div>

</div>


<!-- Analysis Settings -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<h2 class="text-xl font-semibold mb-4 text-purple-300">‚öôÔ∏è C√†i ƒê·∫∑t Ph√¢n T√≠ch (Th·ªß c√¥ng)</h2>

<p class="text-sm text-gray-400 mb-4">C√†i ƒë·∫∑t n√†y ch·ªâ ƒë∆∞·ª£c s·ª≠ d·ª•ng khi h·ªá th·ªëng ch∆∞a t√¨m th·∫•y chi·ªÅu d√†i c·∫ßu t·ªëi ∆∞u.</p>

<div class="space-y-4">

<div>

<label for="minPatternLength" class="block text-sm font-medium text-gray-300 mb-1">ƒê·ªô d√†i c·∫ßu t·ªëi thi·ªÉu ƒë·ªÉ so s√°nh</label>

<input type="number" id="minPatternLength" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-purple-500 focus:outline-none">

</div>

<div>

<label for="maxPatternLength" class="block text-sm font-medium text-gray-300 mb-1">ƒê·ªô d√†i c·∫ßu t·ªëi ƒëa ƒë·ªÉ so s√°nh</label>

<input type="number" id="maxPatternLength" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-purple-500 focus:outline-none">

</div>

<div>

<label for="minCertainOccurrences" class="block text-sm font-medium text-gray-300 mb-1">S·ªë l·∫ßn l·∫∑p l·∫°i t·ªëi thi·ªÉu cho "Tay Ch·∫Øc Ch·∫Øn"</label>

<input type="number" id="minCertainOccurrences" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-purple-500 focus:outline-none">

</div>

</div>

<button onclick="saveSettings()" class="btn w-full mt-6 bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-4 rounded-lg">L∆∞u C√†i ƒê·∫∑t</button>

</div>



<!-- History Display -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<div class="flex justify-between items-center mb-4">

<h2 class="text-xl font-semibold text-blue-300">üìú B·∫£ng C·∫ßu Big Road</h2>

<span class="text-gray-400 font-medium">T·ªïng: <span id="totalGames">0</span> v√°n</span>

</div>

<div class="bg-gray-900 rounded-lg min-h-[280px] border border-gray-700">

<div id="bigRoadDisplay">

<p class="text-gray-500 p-4">Ch∆∞a c√≥ k·∫øt qu·∫£...</p>

</div>

</div>

</div>

</div>



<!-- Right Column: Analysis & Stats -->

<div class="space-y-6">

<!-- Accuracy Stats -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<h2 class="text-xl font-semibold mb-4 text-green-300">üéØ Th·ªëng K√™ (Phi√™n Hi·ªán T·∫°i)</h2>

<div class="space-y-4">

<div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">

<span class="font-medium text-gray-300">T·ª∑ L·ªá Th·∫Øng</span>

<span id="accuracyRate" class="text-2xl font-bold text-green-400">0.0%</span>

</div>

<div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">

<span class="font-medium text-gray-300">Th·∫Øng / T·ªïng Ph√°n ƒêo√°n</span>

<div>

<span id="correctPredictions" class="text-lg font-semibold text-white">0</span>

<span class="text-gray-400">/</span>

<span id="totalPredictions" class="text-lg font-semibold text-white">0</span>

</div>

</div>

</div>

</div>



<!-- Global Accuracy Stats -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<h2 class="text-xl font-semibold mb-4 text-cyan-300">üåê Th·ªëng K√™ (To√†n C·ª•c)</h2>

<div class="space-y-4">

<div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">

<span class="font-medium text-gray-300">T·ª∑ L·ªá Th·∫Øng</span>

<span id="globalAccuracyRate" class="text-2xl font-bold text-cyan-400">0.0%</span>

</div>

<div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">

<span class="font-medium text-gray-300">Th·∫Øng / T·ªïng Ph√°n ƒêo√°n</span>

<div>

<span id="globalCorrectPredictions" class="text-lg font-semibold text-white">0</span>

<span class="text-gray-400">/</span>

<span id="globalTotalPredictions" class="text-lg font-semibold text-white">0</span>

</div>

</div>

</div>

</div>



<!-- Pattern Analysis -->

<div id="analysis-card" class="bg-gray-800 p-6 rounded-2xl shadow-lg transition-shadow duration-500">

<h2 class="text-xl font-semibold mb-4 text-yellow-300">üß† Ph√¢n T√≠ch & ƒê·ªÅ Xu·∫•t</h2>

<div id="analysisResult" class="space-y-4">

<p class="text-gray-400 text-center py-8">C·∫ßn √≠t nh·∫•t 10 k·∫øt qu·∫£ ƒë·ªÉ b·∫Øt ƒë·∫ßu ph√¢n t√≠ch...</p>

</div>

</div>


<!-- Confidence Stats Table -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<h2 class="text-xl font-semibold mb-2 text-green-300">üìä Th·ªëng K√™ ƒê·ªô Tin C·∫≠y (Phi√™n Hi·ªán T·∫°i)</h2>

<div id="confidenceRecommendation" class="my-4 p-3 bg-gray-900 rounded-lg text-center"></div>

<div class="space-y-2" id="confidenceStatsTable">

<!-- Rows will be generated by JS -->

</div>

</div>



</div>

</div>



<script>

// --- CORE LOGIC: PATTERN MATCHER ---

class PatternMatcher {

constructor() {

this.MIN_HISTORY_FOR_ANALYSIS = 10;

this.MIN_PATTERN_LENGTH = 10;

this.MAX_PATTERN_LENGTH = 15;

this.MIN_CERTAIN_OCCURRENCES = 2; // Default value

}



calculateSimilarity(arr1, arr2) {

if (arr1.length !== arr2.length || arr1.length === 0) return 0;

const matches = arr1.filter((item, index) => item === arr2[index]).length;

return matches / arr1.length;

}



findPatternOccurrences(pattern, allHistory) {

const occurrences = [];

// This check is now more dynamic, so we rely on the calling function's length checks

// if (pattern.length < this.MIN_PATTERN_LENGTH) return occurrences;

const reversedPattern = [...pattern].reverse();



for (const session of allHistory) {

const sessionHistory = session.history || [];

if (sessionHistory.length < pattern.length + 1) continue;


for (let i = 0; i <= sessionHistory.length - pattern.length - 1; i++) {

const segment = sessionHistory.slice(i, i + pattern.length);

const nextResult = sessionHistory[i + pattern.length];

const similarity = this.calculateSimilarity(pattern, segment);


if (similarity >= 0.9) occurrences.push({ type: 'similar', next: nextResult, similarity });


const reverseSimilarity = this.calculateSimilarity(reversedPattern, segment);

if (reverseSimilarity >= 0.9) occurrences.push({ type: 'reversed', next: nextResult, similarity: reverseSimilarity });

}

}

return occurrences;

}



getPredictionForPattern(pattern, allHistoricalSessions) {

const occurrences = this.findPatternOccurrences(pattern, allHistoricalSessions);


if (occurrences.length === 0) {

return { prediction: null };

}



const votes = { P: 0, B: 0 };

occurrences.forEach(match => {

if (votes[match.next] !== undefined) votes[match.next] += match.similarity;

});



const totalVotes = votes.P + votes.B;

if (totalVotes === 0) {

return { prediction: null };

}


const predictedWinner = votes.P > votes.B ? 'P' : 'B';

const confidence = (Math.max(votes.P, votes.B) / totalVotes) * 100;


return { prediction: predictedWinner, confidence, votes, totalOccurrences: occurrences.length };

}


findCertainPrediction(currentHistory, allHistoricalSessions) {

for (let len = Math.min(this.MAX_PATTERN_LENGTH, currentHistory.length); len >= this.MIN_PATTERN_LENGTH; len--) {

const pattern = currentHistory.slice(-len);

const patternString = pattern.join('');

const occurrences = [];



for (const session of allHistoricalSessions) {

const sessionHistory = session.history || [];

if (sessionHistory.length < pattern.length + 1) continue;


for (let i = 0; i <= sessionHistory.length - pattern.length - 1; i++) {

const segment = sessionHistory.slice(i, i + pattern.length);

if (segment.join('') === patternString) {

const nextResult = sessionHistory[i + pattern.length];

occurrences.push(nextResult);

}

}

}



if (occurrences.length >= this.MIN_CERTAIN_OCCURRENCES && new Set(occurrences).size === 1) {

const predictedWinner = occurrences[0];

return {

prediction: predictedWinner,

recommendation: 'TAY CH·∫ÆC CH·∫ÆN',

analysisText: `T√¨m th·∫•y ${occurrences.length} l·∫ßn xu·∫•t hi·ªán ch√≠nh x√°c c·ªßa h√¨nh c·∫ßu n√†y trong l·ªãch s·ª≠.\nT·∫•t c·∫£ ƒë·ªÅu cho k·∫øt qu·∫£ ti·∫øp theo l√†: ${predictedWinner}`,

confidence: 100,

isCertain: true

};

}

}

return null;

}





analyzeCurrentStreak(currentHistory) {

if (currentHistory.length < 2) return { type: 'none', length: currentHistory.length };

const last = currentHistory[currentHistory.length - 1];

const secondLast = currentHistory[currentHistory.length - 2];

if (last === secondLast) {

let length = 0;

for (let i = currentHistory.length - 1; i >= 0; i--) {

if (currentHistory[i] === last) length++; else break;

}

return { type: 'b·ªát', length, value: last };

} else {

let length = 0;

for (let i = currentHistory.length - 1; i >= 1; i--) {

if (currentHistory[i] !== currentHistory[i-1]) length++; else break;

}

return { type: '1-1', length: length + 1 };

}

}



getPrediction(currentHistory, allHistoricalSessions, { optimalLength = null, lengthPerformance = {} } = {}) {

if (currentHistory.length < this.MIN_HISTORY_FOR_ANALYSIS) {

return { prediction: null, analysisText: `C·∫ßn √≠t nh·∫•t ${this.MIN_HISTORY_FOR_ANALYSIS} k·∫øt qu·∫£...`, confidence: 0, isCertain: false };

}


// --- NEW: Optimal Length Logic ---

if (optimalLength && currentHistory.length >= optimalLength) {

const pattern = currentHistory.slice(-optimalLength);

const result = this.getPredictionForPattern(pattern, allHistoricalSessions);

if (result.prediction) {

const perf = lengthPerformance[optimalLength] || { wins: 0, total: 0 };

const rate = perf.total > 0 ? (perf.wins / perf.total * 100).toFixed(1) : 'N/A';

const analysisText = `S·ª≠ d·ª•ng chi·ªÅu d√†i c·∫ßu t·ªëi ∆∞u: ${optimalLength} v√°n.\n(T·ª∑ l·ªá th·∫Øng c·ªßa chi·ªÅu d√†i n√†y: ${rate}% - ${perf.wins}/${perf.total})\n\nL·ªãch s·ª≠ cho th·∫•y:\n- PLAYER: ${result.votes.P.toFixed(1)} ƒëi·ªÉm\n- BANKER: ${result.votes.B.toFixed(1)} ƒëi·ªÉm`;

return {

prediction: result.prediction,

recommendation: 'THEO CHI·ªÄU D√ÄI T·ªêI ∆ØU',

analysisText,

confidence: result.confidence,

isCertain: false

};

}

}


// --- FALLBACK: Original Logic ---

const certainPrediction = this.findCertainPrediction(currentHistory, allHistoricalSessions);

if (certainPrediction) {

return certainPrediction;

}



const allMatches = [];

for (let len = Math.min(this.MAX_PATTERN_LENGTH, currentHistory.length); len >= this.MIN_PATTERN_LENGTH; len--) {

const pattern = currentHistory.slice(-len);

const occurrences = this.findPatternOccurrences(pattern, allHistoricalSessions);

if (occurrences.length > 0) {

allMatches.push(...occurrences);

break;

}

}



if (allMatches.length === 0) {

return { prediction: null, analysisText: 'Kh√¥ng t√¨m th·∫•y h√¨nh c·∫ßu t∆∞∆°ng t·ª± (ch·∫ø ƒë·ªô th·ªß c√¥ng).', confidence: 0, isCertain: false };

}



const votes = { P: 0, B: 0 };

allMatches.forEach(match => {

if (votes[match.next] !== undefined) votes[match.next] += match.similarity;

});



const totalVotes = votes.P + votes.B;

if (totalVotes === 0) {

return { prediction: null, analysisText: 'Kh√¥ng t√¨m th·∫•y h√¨nh c·∫ßu t∆∞∆°ng t·ª± (ch·∫ø ƒë·ªô th·ªß c√¥ng).', confidence: 0, isCertain: false };

}



const confidenceP = (votes.P / totalVotes) * 100;

const confidenceB = (votes.B / totalVotes) * 100;

const maxConfidence = Math.max(confidenceP, confidenceB);

const predictedWinner = votes.P > votes.B ? 'P' : 'B';



const analysisTextPrefix = `T√¨m th·∫•y ${allMatches.length} h√¨nh c·∫ßu t∆∞∆°ng t·ª±. L·ªãch s·ª≠ cho th·∫•y:\n- PLAYER: ${votes.P.toFixed(1)} ƒëi·ªÉm\n- BANKER: ${votes.B.toFixed(1)} ƒëi·ªÉm`;


const streakInfo = this.analyzeCurrentStreak(currentHistory);

let recommendation = '';

if (streakInfo.type === 'b·ªát' && predictedWinner === streakInfo.value) recommendation = `THEO C·∫¶U B·ªÜT (${streakInfo.value} x${streakInfo.length})`;

else if (streakInfo.type === 'b·ªát' && predictedWinner !== streakInfo.value) recommendation = `B·∫∫ C·∫¶U B·ªÜT (${streakInfo.value} x${streakInfo.length})`;

else if (streakInfo.type === '1-1' && predictedWinner !== currentHistory[currentHistory.length - 1]) recommendation = `THEO C·∫¶U 1-1 (D√†i ${streakInfo.length})`;

else if (streakInfo.type === '1-1' && predictedWinner === currentHistory[currentHistory.length - 1]) recommendation = `B·∫∫ C·∫¶U 1-1 (D√†i ${streakInfo.length})`;

else recommendation = `THEO PH√ÇN T√çCH L·ªäCH S·ª¨`;


const analysisText = `${analysisTextPrefix}\n\nüèÜ ƒê·ªô tin c·∫≠y: ${maxConfidence.toFixed(1)}%`;

return { prediction: predictedWinner, recommendation, analysisText, confidence: maxConfidence, isCertain: false };

}

}



// --- GLOBAL STATE ---

let state = {

currentSessionId: null,

sessions: {},

matcher: new PatternMatcher(),

currentPrediction: null,

goldenRange: null

};


// --- STATS CALCULATION ---

function getPredictionStats(predictions) {

const total = predictions.length;

if (total === 0) return { rate: 0, correct: 0, total: 0 };

const correct = predictions.filter(p => p.predicted === p.actual).length;

return { rate: (correct / total) * 100, correct, total };

}





// --- UI UPDATE FUNCTIONS ---

function updateBigRoadUI() {

const history = state.sessions[state.currentSessionId]?.history || [];

const roadDiv = document.getElementById('bigRoadDisplay');

document.getElementById('totalGames').textContent = history.length;



if (history.length === 0) {

roadDiv.innerHTML = '<p class="text-gray-500 p-4">Ch∆∞a c√≥ k·∫øt qu·∫£...</p>';

roadDiv.style.display = 'block';

return;

}

roadDiv.style.display = 'grid';

roadDiv.innerHTML = '';



const columns = [];

if (history.length > 0) {

let currentCol = [history[0]];

for (let i = 1; i < history.length; i++) {

if (history[i] === history[i-1]) {

currentCol.push(history[i]);

} else {

columns.push(currentCol);

currentCol = [history[i]];

}

}

columns.push(currentCol);

}



columns.forEach(colData => {

const colDiv = document.createElement('div');

colDiv.className = 'road-col';

colData.forEach(item => {

const itemDiv = document.createElement('div');

const bgColor = item === 'P' ? 'bg-blue-600' : 'bg-red-600';

itemDiv.className = `road-item ${bgColor}`;

itemDiv.textContent = item;

colDiv.appendChild(itemDiv);

});

roadDiv.appendChild(colDiv);

});

roadDiv.scrollLeft = roadDiv.scrollWidth;

}



function updateAccuracyUI() {

const predictions = state.sessions[state.currentSessionId]?.predictions || [];

const stats = getPredictionStats(predictions);

document.getElementById('accuracyRate').textContent = `${stats.rate.toFixed(1)}%`;

document.getElementById('correctPredictions').textContent = stats.correct;

document.getElementById('totalPredictions').textContent = stats.total;

}



function updateGlobalAccuracyUI() {

const allPredictions = Object.values(state.sessions).flatMap(s => s.predictions || []);

const stats = getPredictionStats(allPredictions);

document.getElementById('globalAccuracyRate').textContent = `${stats.rate.toFixed(1)}%`;

document.getElementById('globalCorrectPredictions').textContent = stats.correct;

document.getElementById('globalTotalPredictions').textContent = stats.total;

}



function updateAnalysisUI() {

const session = state.sessions[state.currentSessionId] || { history: [], optimalLength: null, lengthPerformance: {} };

const currentHistory = session.history;

const allHistory = Object.values(state.sessions);



let { prediction, recommendation, analysisText, confidence, isCertain } = state.matcher.getPrediction(currentHistory, allHistory, {

optimalLength: session.optimalLength,

lengthPerformance: session.lengthPerformance

});


state.currentPrediction = { prediction, confidence };



let finalPrediction = prediction;

let finalRecommendation = recommendation;

let recommendationNote = '';



if (prediction && !isCertain) {

let isInGoldenRange = false;

if (state.goldenRange && confidence >= state.goldenRange.min && confidence <= state.goldenRange.max) {

isInGoldenRange = true;

}



if (isInGoldenRange) {

if (state.goldenRange.rate < 30) {

finalPrediction = prediction === 'P' ? 'B' : 'P';

finalRecommendation = `ƒê·ªÄ XU·∫§T NG∆Ø·ª¢C (T·ª∑ l·ªá th·∫•p)`;

recommendationNote = `<div class="mt-2 p-2 text-center bg-red-800 bg-opacity-50 rounded-lg text-sm text-red-300 font-semibold">‚ö†Ô∏è ƒê·∫£o ng∆∞·ª£c! Kho·∫£ng v√†ng (${state.goldenRange.min}-${state.goldenRange.max}%) c√≥ t·ª∑ l·ªá th·∫Øng ch·ªâ ${state.goldenRange.rate.toFixed(1)}%.</div>`;

} else {

recommendationNote = `<div class="mt-2 p-2 text-center bg-green-800 bg-opacity-50 rounded-lg text-sm text-green-300 font-semibold">‚ú® Ph√°n ƒëo√°n n√†y n·∫±m trong KHO·∫¢NG V√ÄNG!</div>`;

}

} else if (state.goldenRange) {

recommendationNote = `<div class="mt-2 p-2 text-center bg-yellow-800 bg-opacity-50 rounded-lg text-sm text-yellow-300 font-semibold">‚ö†Ô∏è C·∫©n tr·ªçng: Kh√¥ng thu·ªôc Kho·∫£ng V√†ng.</div>`;

}

}


const analysisResultDiv = document.getElementById('analysisResult');

const analysisCard = document.getElementById('analysis-card');

analysisCard.classList.remove('card-glow-p', 'card-glow-b', 'card-glow-certain');



let optimalLengthDisplay = '';

if (session.optimalLength) {

optimalLengthDisplay = `<div class="mb-4 p-3 bg-gray-900 rounded-lg text-center text-cyan-300 text-sm">

<span class="font-semibold">Chi·ªÅu d√†i c·∫ßu t·ªëi ∆∞u ƒëang √°p d·ª•ng:</span>

<span class="text-lg font-bold ml-2">${session.optimalLength}</span>

</div>`;

}



if (finalPrediction) {

let predictionBlockHTML = '';

if (isCertain) {

predictionBlockHTML = `

<div class="text-center bg-yellow-800 bg-opacity-50 py-6 rounded-lg border-2 border-yellow-400">

<p class="text-lg text-yellow-300 mb-2 animate-pulse">ƒê·ªÅ Xu·∫•t Ch·∫Øc Ch·∫Øn (L·ªãch s·ª≠):</p>

<p class="text-3xl font-extrabold text-yellow-300">${finalRecommendation}</p>

<p class="text-4xl font-bold mt-2">${finalPrediction === 'P' ? 'üë§ PLAYER' : 'üè¶ BANKER'}</p>

</div>

`;

analysisCard.classList.add('card-glow-certain');

} else {

predictionBlockHTML = `

<div class="text-center bg-gray-900 py-6 rounded-lg border-2 ${finalPrediction === 'P' ? 'border-blue-500' : 'border-red-500'}">

<p class="text-lg text-gray-400 mb-2">ƒê·ªÅ xu·∫•t:</p>

<p class="text-3xl font-extrabold ${finalPrediction === 'P' ? 'text-blue-400' : 'text-red-400'}">${finalRecommendation}</p>

<p class="text-4xl font-bold mt-2">${finalPrediction === 'P' ? 'üë§ PLAYER' : 'üè¶ BANKER'}</p>

${recommendationNote}

</div>

`;

analysisCard.classList.add(finalPrediction === 'P' ? 'card-glow-p' : 'card-glow-b');

}



analysisResultDiv.innerHTML = `

${optimalLengthDisplay}

<div class="bg-gray-700 p-4 rounded-lg">

<p class="text-gray-300 whitespace-pre-wrap">${analysisText}</p>

</div>

${predictionBlockHTML}

`;



} else {

analysisResultDiv.innerHTML = `

${optimalLengthDisplay}

<p class="text-gray-400 text-center py-8 whitespace-pre-wrap">${analysisText}</p>

`;

}

}


function updateConfidenceStatsUI() {

if (!state.currentSessionId || !state.sessions[state.currentSessionId]) return;



const sessionPredictions = state.sessions[state.currentSessionId].predictions || [];

const ranges = [

{min: 50, max: 60, total: 0, wins: 0},

{min: 60, max: 70, total: 0, wins: 0},

{min: 70, max: 80, total: 0, wins: 0},

{min: 80, max: 90, total: 0, wins: 0},

{min: 90, max: 100, total: 0, wins: 0},

];



const tableDiv = document.getElementById('confidenceStatsTable');

const recommendationDiv = document.getElementById('confidenceRecommendation');


let bestRange = null;

let maxRate = -1;



ranges.forEach(range => {

const predictionsForRange = sessionPredictions.filter(p => {

const confidence = p.confidence;

return confidence >= range.min && (confidence < range.max || (range.max === 100 && confidence >= 100));

});


range.total = predictionsForRange.length;

range.wins = predictionsForRange.filter(p => p.predicted === p.actual).length;

const rate = range.total > 0 ? ((range.wins / range.total) * 100) : -1;

range.rate = rate;


// Calculate trend

let trendIndicator = '';

let streak = 0;

if (predictionsForRange.length >= 1) {

const lastResultIsWin = (predictionsForRange[predictionsForRange.length - 1].predicted === predictionsForRange[predictionsForRange.length - 1].actual);

for (let i = predictionsForRange.length - 1; i >= 0; i--) {

const currentResultIsWin = (predictionsForRange[i].predicted === predictionsForRange[i].actual);

if (currentResultIsWin === lastResultIsWin) {

streak++;

} else {

break;

}

}



if (streak >= 1) {

if (lastResultIsWin) {

trendIndicator = `<span class="flex items-center text-green-400 ml-1.5">

<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z" clip-rule="evenodd"></path></svg>

<span class="font-bold text-xs">${streak}</span>

</span>`;

} else {

trendIndicator = `<span class="flex items-center text-red-400 ml-1.5">

<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>

<span class="font-bold text-xs">${streak}</span>

</span>`;

}

}

}

range.trendIndicator = trendIndicator;



if (range.total >= 3 && rate > maxRate) {

maxRate = rate;

bestRange = range;

}

});


state.goldenRange = bestRange;



if (bestRange) {

recommendationDiv.innerHTML = `<p class="text-sm text-yellow-300"><span class="font-bold">‚ú® Kho·∫£ng V√†ng (Phi√™n):</span> T·ª∑ l·ªá th·∫Øng cao nh·∫•t l√† <b class="text-green-400">${maxRate.toFixed(1)}%</b> trong kho·∫£ng <b class="text-white">${bestRange.min}%-${bestRange.max}%</b>.</p>`;

} else {

recommendationDiv.innerHTML = `<p class="text-sm text-gray-400">Ch∆∞a ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ t√¨m ra kho·∫£ng v√†ng cho phi√™n n√†y (c·∫ßn t·ªëi thi·ªÉu 3 ph√°n ƒëo√°n trong 1 kho·∫£ng).</p>`;

}



let html = `

<div class="grid gap-x-2 text-xs font-semibold text-gray-400 px-3" style="grid-template-columns: 4fr 2fr 2fr 4fr;">

<span class="text-left">Kho·∫£ng</span>

<span class="text-center">T·ªïng</span>

<span class="text-center">Th·∫Øng</span>

<span class="text-right">T·ª∑ L·ªá</span>

</div>

`;

if (sessionPredictions.length === 0) {

tableDiv.innerHTML = '<p class="text-gray-500 text-center py-4">Ch∆∞a c√≥ d·ªØ li·ªáu th·ªëng k√™ cho phi√™n n√†y.</p>';

} else {

ranges.forEach(range => {

const rate = range.rate;

const isBest = range === bestRange;

const highlightClass = isBest ? 'bg-green-800 bg-opacity-40 border border-green-500' : 'bg-gray-700 bg-opacity-50';

html += `

<div class="grid gap-x-2 items-center ${highlightClass} p-3 rounded-lg mt-2 transition-all duration-300 text-sm" style="grid-template-columns: 4fr 2fr 2fr 4fr;">

<span class="font-medium text-gray-300 text-left">${range.min}%-${range.max}%</span>

<span class="text-white font-semibold text-center">${range.total}</span>

<span class="text-green-400 font-semibold text-center">${range.wins}</span>

<span class="font-bold flex items-center justify-end ${rate >= 70 ? 'text-green-400' : (rate >= 50 ? 'text-yellow-400' : 'text-red-400')}">

${rate > -1 ? rate.toFixed(1) + '%' : '-'}

${range.trendIndicator}

</span>

</div>

`;

});

tableDiv.innerHTML = html;

}

}





function updateAllUI() {

updateBigRoadUI();

updateAccuracyUI();

updateGlobalAccuracyUI();

updateConfidenceStatsUI();

updateAnalysisUI();

}



// --- EVENT HANDLERS & ACTIONS ---

function addResult(result) {

if (!state.currentSessionId) return;

const session = state.sessions[state.currentSessionId];

const historyBeforeAdd = [...session.history];

const allSessions = Object.values(state.sessions);



// New logic: Update stats and find optimal length based on the result being added

const newOptimalLength = updateLengthPerformanceAndFindOptimal(historyBeforeAdd, allSessions, result);

session.optimalLength = newOptimalLength;



// Original logic: Store the last prediction vs actual result

if (state.currentPrediction && state.currentPrediction.prediction) {

session.predictions.push({

predicted: state.currentPrediction.prediction,

actual: result,

confidence: state.currentPrediction.confidence

});

}

state.currentPrediction = null;



session.history.push(result);


saveSessions();

updateAllUI();

}



// --- NEW: Optimal Length Finder ---

function updateLengthPerformanceAndFindOptimal(history, allSessions, newResult) {

const session = state.sessions[state.currentSessionId];

if (!session.lengthPerformance) {

session.lengthPerformance = {};

}



const candidates = [];



for (let len = 10; len <= 20; len++) {

if (history.length < len) continue;



const pattern = history.slice(-len);

const { prediction } = state.matcher.getPredictionForPattern(pattern, allSessions);



if (prediction) {

// Initialize stats if not present

if (!session.lengthPerformance[len]) {

session.lengthPerformance[len] = { wins: 0, total: 0 };

}


// Update stats for this length based on its prediction for the newResult

const stats = session.lengthPerformance[len];

stats.total++;

if (prediction === newResult) {

stats.wins++;

}


// Check if this length is a candidate for being the new optimal

// A length is a candidate if its prediction for the previous hand matched the new result

if (prediction === newResult) {

candidates.push({

length: len,

rate: stats.wins / stats.total,

total: stats.total

});

}

}

}


if (candidates.length === 0) {

return session.optimalLength; // Keep the old one if no candidates found

}



// Sort by rate desc, then total desc

candidates.sort((a, b) => {

if (b.rate !== a.rate) {

return b.rate - a.rate;

}

return b.total - a.total;

});


return candidates[0].length; // The new optimal length

}



function undoLast() {

if (!state.currentSessionId || state.sessions[state.currentSessionId].history.length === 0) return;


// This is complex with the new logic, so a simple pop is best.

// Re-calculating optimal length on undo is too intensive.

state.sessions[state.currentSessionId].history.pop();


const predictions = state.sessions[state.currentSessionId].predictions;

if (predictions.length > 0) {

predictions.pop();

}


saveSessions();

updateAllUI();

}



function clearCurrentSessionHistory() {

if (!state.currentSessionId) return;

if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô l·ªãch s·ª≠ v√† th·ªëng k√™ c·ªßa phi√™n n√†y kh√¥ng?')) {

const session = state.sessions[state.currentSessionId];

session.history = [];

session.predictions = [];

session.lengthPerformance = {};

session.optimalLength = null;

saveSessions();

updateAllUI();

}

}



// --- SESSION MANAGEMENT ---

function getSessions() {

try {

return JSON.parse(localStorage.getItem('baccaratPatternSessions_v4')) || {};

} catch (e) { return {}; }

}



function saveSessions() {

localStorage.setItem('baccaratPatternSessions_v4', JSON.stringify(state.sessions));

localStorage.setItem('lastActiveSession_v4', state.currentSessionId);

}


function renameSession() {

if (!state.currentSessionId) return;

const currentName = state.sessions[state.currentSessionId].name;

const newName = prompt("Nh·∫≠p t√™n m·ªõi cho phi√™n:", currentName);

if (newName && newName.trim() !== "") {

state.sessions[state.currentSessionId].name = newName.trim();

saveSessions();

updateSessionSelector();

}

}



function updateSessionSelector() {

const selector = document.getElementById('sessionSelector');

selector.innerHTML = '';

const sortedKeys = Object.keys(state.sessions).sort((a, b) => parseInt(b.split('-')[1]) - parseInt(a.split('-')[1]));


sortedKeys.forEach((sessionId) => {

const session = state.sessions[sessionId];

const option = document.createElement('option');

option.value = sessionId;

option.textContent = `${session.name} (${session.history.length} v√°n)`;

selector.appendChild(option);

});

selector.value = state.currentSessionId;

selector.onchange = () => loadSession(selector.value);

}



function createNewSession() {

const newId = `session-${Date.now()}`;

state.currentSessionId = newId;

state.sessions[newId] = {

name: `Phi√™n ${new Date().toLocaleString('vi-VN')}`,

history: [],

predictions: [],

lengthPerformance: {},

optimalLength: null

};

saveSessions();

updateSessionSelector();

updateAllUI();

}



function deleteSelectedSession() {

if (!state.currentSessionId || Object.keys(state.sessions).length <= 1) {

alert('Kh√¥ng th·ªÉ x√≥a phi√™n cu·ªëi c√πng.');

return;

}

if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a phi√™n n√†y kh√¥ng?')) {

delete state.sessions[state.currentSessionId];

state.currentSessionId = null;

localStorage.removeItem('lastActiveSession_v4');

saveSessions();

initializeApp();

}

}



function loadSession(sessionId) {

if (state.sessions[sessionId]) {

state.currentSessionId = sessionId;

state.currentPrediction = null;

localStorage.setItem('lastActiveSession_v4', state.currentSessionId);

updateSessionSelector();

updateAllUI();

}

}


// --- SETTINGS ---

function saveSettings() {

const settings = {

minPatternLength: document.getElementById('minPatternLength').value,

maxPatternLength: document.getElementById('maxPatternLength').value,

minCertainOccurrences: document.getElementById('minCertainOccurrences').value

};

localStorage.setItem('baccaratSettings_v1', JSON.stringify(settings));

applySettings(settings);

alert('C√†i ƒë·∫∑t ƒë√£ ƒë∆∞·ª£c l∆∞u!');

updateAnalysisUI(); // Re-run analysis with new settings

}



function applySettings(settings) {

if (settings.minPatternLength) {

state.matcher.MIN_PATTERN_LENGTH = parseInt(settings.minPatternLength, 10);

}

if (settings.maxPatternLength) {

state.matcher.MAX_PATTERN_LENGTH = parseInt(settings.maxPatternLength, 10);

}

if (settings.minCertainOccurrences) {

state.matcher.MIN_CERTAIN_OCCURRENCES = parseInt(settings.minCertainOccurrences, 10);

}

}



function loadSettings() {

const settingsStr = localStorage.getItem('baccaratSettings_v1');

const settings = settingsStr ? JSON.parse(settingsStr) : {};


applySettings(settings);



document.getElementById('minPatternLength').value = state.matcher.MIN_PATTERN_LENGTH;

document.getElementById('maxPatternLength').value = state.matcher.MAX_PATTERN_LENGTH;

document.getElementById('minCertainOccurrences').value = state.matcher.MIN_CERTAIN_OCCURRENCES;

}



// --- IMPORT / EXPORT ---

function exportData() {

if (Object.keys(state.sessions).length === 0) {

alert("Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t.");

return;

}

const dataStr = JSON.stringify(state.sessions, null, 2);

const dataBlob = new Blob([dataStr], {type: "application/json"});

const url = URL.createObjectURL(dataBlob);

const link = document.createElement('a');

link.download = `baccarat_backup_${new Date().toISOString().slice(0,10)}.json`;

link.href = url;

link.click();

URL.revokeObjectURL(url);

}



function importData(event) {

const file = event.target.files[0];

if (!file) return;

const reader = new FileReader();

reader.onload = function(e) {

try {

const importedSessions = JSON.parse(e.target.result);

if (typeof importedSessions !== 'object' || importedSessions === null) throw new Error("Invalid format");


for(const key in importedSessions) {

const session = importedSessions[key];

if(!session.name || !Array.isArray(session.history)) {

throw new Error("Invalid session data");

}

// Add new fields if they don't exist in the imported file

if (!session.predictions) session.predictions = [];

if (!session.lengthPerformance) session.lengthPerformance = {};

if (session.optimalLength === undefined) session.optimalLength = null;

}



if (confirm('D·ªØ li·ªáu hi·ªán t·∫°i s·∫Ω b·ªã ghi ƒë√®. B·∫°n c√≥ ch·∫Øc mu·ªën ti·∫øp t·ª•c?')) {

state.sessions = importedSessions;

state.currentSessionId = null;

localStorage.removeItem('lastActiveSession_v4');

saveSessions();

initializeApp();

alert('Nh·∫≠p d·ªØ li·ªáu th√†nh c√¥ng!');

}

} catch (error) {

alert('L·ªói: File d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i file.');

console.error("Import error:", error);

} finally {

event.target.value = '';

}

};

reader.readAsText(file);

}



function initializeApp() {

loadSettings();

state.sessions = getSessions();


// Ensure all loaded sessions have the new properties

Object.values(state.sessions).forEach(session => {

if (!session.lengthPerformance) session.lengthPerformance = {};

if (session.optimalLength === undefined) session.optimalLength = null;

});



const lastActiveId = localStorage.getItem('lastActiveSession_v4');



if (Object.keys(state.sessions).length === 0) {

createNewSession();

} else {

const sortedKeys = Object.keys(state.sessions).sort((a, b) => parseInt(b.split('-')[1]) - parseInt(a.split('-')[1]));

const idToLoad = (lastActiveId && state.sessions[lastActiveId]) ? lastActiveId : sortedKeys[0];

loadSession(idToLoad);

}

}



// --- INITIALIZATION ---

document.addEventListener('DOMContentLoaded', initializeApp);

</script>

</body>

</html>
