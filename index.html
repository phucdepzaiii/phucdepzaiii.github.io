<!DOCTYPE html>

<html lang="vi">

<head>

<meta charset="UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Há»‡ Thá»‘ng PhÃ¢n TÃ­ch Cáº§u (Thá»‘ng KÃª NÃ¢ng Cao)</title>

<script src="https://cdn.tailwindcss.com"></script>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

<style>

body {

font-family: 'Inter', sans-serif;

background-color: #111827; /* Tailwind gray-900 */

color: #F9FAFB; /* Tailwind gray-50 */

}

.btn {

transition: all 0.3s ease;

box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);

}

.btn:hover {

transform: translateY(-2px);

box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);

}

.btn:active {

transform: translateY(1px);

}

.card-glow-p {

box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);

}

.card-glow-b {

box-shadow: 0 0 20px rgba(239, 68, 68, 0.5);

}

.card-glow-certain {

box-shadow: 0 0 25px rgba(250, 204, 21, 0.7);

}

/* Big Road Styles */

#bigRoadDisplay {

display: grid;

grid-auto-flow: column;

grid-auto-columns: 2.5rem; /* 40px */

gap: 2px;

overflow-x: auto;

padding: 8px;

}

.road-col {

display: grid;

grid-auto-rows: 2.5rem; /* 40px */

gap: 2px;

}

.road-item {

width: 2.5rem; /* 40px */

height: 2.5rem; /* 40px */

border-radius: 9999px;

display: flex;

align-items: center;

justify-content: center;

font-weight: bold;

font-size: 1.125rem; /* 18px */

color: white;

animation: fadeIn 0.5s ease;

}

@keyframes fadeIn {

from { opacity: 0; transform: scale(0.8); }

to { opacity: 1; transform: scale(1); }

}

/* Added styles for highlighting */
.road-item.previous-hand {
Â  Â  border: 3px solid #6B7280; /* gray-500 */
}
.road-item.current-hand {
Â  Â  border: 3px solid #FBBF24; /* amber-400 */
Â  Â  animation: pulse 1.5s infinite, fadeIn 0.5s ease;
}

@keyframes pulse {
Â  Â  0%, 100% {
Â  Â  Â  Â  box-shadow: 0 0 10px rgba(250, 204, 21, 0.3);
Â  Â  }
Â  Â  50% {
Â  Â  Â  Â  box-shadow: 0 0 20px rgba(250, 204, 21, 0.8);
Â  Â  }
}

/* Added style for current prediction range */
.current-prediction-range {
Â  Â  animation: pulse-blue 2s infinite;
}

@keyframes pulse-blue {
Â  Â  0%, 100% {
Â  Â  Â  Â  box-shadow: 0 0 12px rgba(147, 197, 253, 0.4);
Â  Â  }
Â  Â  50% {
Â  Â  Â  Â  box-shadow: 0 0 22px rgba(147, 197, 253, 0.8);
Â  Â  }
}

/* Bar Chart for Confidence Stats */
.bar-chart-container {
    display: flex;
    gap: 2px;
    height: 24px;
    align-items: flex-end;
    overflow: hidden;
    padding-top: 4px;
}
.bar {
    flex-shrink: 0;
    width: 5px;
    border-radius: 1px;
    transition: all 0.3s ease;
}
.bar.win {
    height: 100%;
    background-color: #60a5fa; /* blue-400 */
}
.bar.loss {
    height: 40%;
    background-color: #f87171; /* red-400 */
}


</style>

</head>

<body class="p-4 md:p-8">



<div class="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-3 gap-6">



<!-- Left Column: Input & History -->

<div class="lg:col-span-2 space-y-6">

<!-- Header -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg text-center">

<h1 class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-red-400">Há»‡ Thá»‘ng PhÃ¢n TÃ­ch HÃ¬nh Cáº§u</h1>

<p class="text-gray-400 mt-2">Ghi nhá»› - Äá»‘i chiáº¿u - PhÃ¡n Ä‘oÃ¡n</p>

</div>



<!-- Session Management -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<h2 class="text-xl font-semibold mb-4 text-blue-300">ğŸ“ Quáº£n LÃ½ PhiÃªn</h2>

<div class="flex flex-col sm:flex-row gap-4 mb-4">

<select id="sessionSelector" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"></select>

<div class="grid grid-cols-2 sm:grid-cols-3 gap-4">

<button onclick="createNewSession()" class="btn w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-4 rounded-lg">â• Má»›i</button>

<button onclick="renameSession()" class="btn w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-4 rounded-lg">âœï¸ Äá»•i TÃªn</button>

<button onclick="deleteSelectedSession()" class="btn w-full bg-red-600 hover:bg-red-500 text-white font-bold py-3 px-4 rounded-lg">ğŸ—‘ï¸ XÃ³a</button>

</div>

</div>

<!-- Import/Export -->

<div class="flex flex-col sm:flex-row gap-4">

<button onclick="exportData()" class="btn w-full bg-sky-600 hover:bg-sky-500 text-white font-bold py-3 px-4 rounded-lg">ğŸ“¤ Xuáº¥t Dá»¯ Liá»‡u</button>

<button onclick="document.getElementById('fileInput').click()" class="btn w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-4 rounded-lg">ğŸ“¥ Nháº­p Dá»¯ Liá»‡u</button>

<input type="file" id="fileInput" class="hidden" accept=".json" onchange="importData(event)">

</div>

</div>



<!-- Input Section -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<h2 class="text-xl font-semibold mb-4 text-blue-300">ğŸ² Nháº­p Káº¿t Quáº£ VÃ¡n Hiá»‡n Táº¡i</h2>

<div class="grid grid-cols-2 gap-4 mb-4">

<button onclick="addResult('P')" class="btn bg-blue-600 hover:bg-blue-500 text-white font-bold py-6 rounded-lg text-2xl">

<span>ğŸ‘¤</span> PLAYER

</button>

<button onclick="addResult('B')" class="btn bg-red-600 hover:bg-red-500 text-white font-bold py-6 rounded-lg text-2xl">

<span>ğŸ¦</span> BANKER

</button>

</div>

<div class="flex gap-4">

<button onclick="undoLast()" class="btn flex-1 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg">â†©ï¸ HoÃ n TÃ¡c</button>

<button onclick="clearCurrentSessionHistory()" class="btn flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg">ğŸ—‘ï¸ XÃ³a Lá»‹ch Sá»­</button>

</div>

</div>


<!-- Analysis Settings -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<h2 class="text-xl font-semibold mb-4 text-purple-300">âš™ï¸ CÃ i Äáº·t PhÃ¢n TÃ­ch (Thá»§ cÃ´ng)</h2>

<p class="text-sm text-gray-400 mb-4">CÃ i Ä‘áº·t nÃ y chá»‰ Ä‘Æ°á»£c sá»­ dá»¥ng khi há»‡ thá»‘ng chÆ°a tÃ¬m tháº¥y chiá»u dÃ i cáº§u tá»‘i Æ°u.</p>

<div class="space-y-4">

<div>

<label for="minPatternLength" class="block text-sm font-medium text-gray-300 mb-1">Äá»™ dÃ i cáº§u tá»‘i thiá»ƒu Ä‘á»ƒ so sÃ¡nh</label>

<input type="number" id="minPatternLength" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-purple-500 focus:outline-none">

</div>

<div>

<label for="maxPatternLength" class="block text-sm font-medium text-gray-300 mb-1">Äá»™ dÃ i cáº§u tá»‘i Ä‘a Ä‘á»ƒ so sÃ¡nh</label>

<input type="number" id="maxPatternLength" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-purple-500 focus:outline-none">

</div>

<div>

<label for="minCertainOccurrences" class="block text-sm font-medium text-gray-300 mb-1">Sá»‘ láº§n láº·p láº¡i tá»‘i thiá»ƒu cho "Tay Cháº¯c Cháº¯n"</label>

<input type="number" id="minCertainOccurrences" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-purple-500 focus:outline-none">

</div>

</div>

<button onclick="saveSettings()" class="btn w-full mt-6 bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-4 rounded-lg">LÆ°u CÃ i Äáº·t</button>

</div>



<!-- History Display -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<div class="flex justify-between items-center mb-4">

<h2 class="text-xl font-semibold text-blue-300">ğŸ“œ Báº£ng Cáº§u Big Road</h2>

<span class="text-gray-400 font-medium">Tá»•ng: <span id="totalGames">0</span> vÃ¡n</span>

</div>

<div class="bg-gray-900 rounded-lg min-h-[280px] border border-gray-700">

<div id="bigRoadDisplay">

<p class="text-gray-500 p-4">ChÆ°a cÃ³ káº¿t quáº£...</p>

</div>

</div>

</div>

</div>



<!-- Right Column: Analysis & Stats -->

<div class="space-y-6">

<!-- Accuracy Stats -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<h2 class="text-xl font-semibold mb-4 text-green-300">ğŸ¯ Thá»‘ng KÃª (PhiÃªn Hiá»‡n Táº¡i)</h2>

<div class="space-y-4">

<div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">

<span class="font-medium text-gray-300">Tá»· Lá»‡ Tháº¯ng</span>

<span id="accuracyRate" class="text-2xl font-bold text-green-400">0.0%</span>

</div>

<div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">

<span class="font-medium text-gray-300">Tháº¯ng / Tá»•ng PhÃ¡n ÄoÃ¡n</span>

<div>

<span id="correctPredictions" class="text-lg font-semibold text-white">0</span>

<span class="text-gray-400">/</span>

<span id="totalPredictions" class="text-lg font-semibold text-white">0</span>

</div>

</div>

</div>

</div>



<!-- Global Accuracy Stats -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<h2 class="text-xl font-semibold mb-4 text-cyan-300">ğŸŒ Thá»‘ng KÃª (ToÃ n Cá»¥c)</h2>

<div class="space-y-4">

<div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">

<span class="font-medium text-gray-300">Tá»· Lá»‡ Tháº¯ng</span>

<span id="globalAccuracyRate" class="text-2xl font-bold text-cyan-400">0.0%</span>

</div>

<div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">

<span class="font-medium text-gray-300">Tháº¯ng / Tá»•ng PhÃ¡n ÄoÃ¡n</span>

<div>

<span id="globalCorrectPredictions" class="text-lg font-semibold text-white">0</span>

<span class="text-gray-400">/</span>

<span id="globalTotalPredictions" class="text-lg font-semibold text-white">0</span>

</div>

</div>

</div>

</div>



<!-- Pattern Analysis -->

<div id="analysis-card" class="bg-gray-800 p-6 rounded-2xl shadow-lg transition-shadow duration-500">

<h2 class="text-xl font-semibold mb-4 text-yellow-300">ğŸ§  PhÃ¢n TÃ­ch & Äá» Xuáº¥t</h2>

<div id="analysisResult" class="space-y-4">

<p class="text-gray-400 text-center py-8">Cáº§n Ã­t nháº¥t 10 káº¿t quáº£ Ä‘á»ƒ báº¯t Ä‘áº§u phÃ¢n tÃ­ch...</p>

</div>

</div>


<!-- Confidence Stats Table -->

<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">

<h2 class="text-xl font-semibold mb-2 text-blue-300">ğŸ“Š Thá»‘ng KÃª Äá»™ Tin Cáº­y (PhiÃªn Hiá»‡n Táº¡i)</h2>

<div id="confidenceRecommendation" class="my-4 p-3 bg-gray-900 rounded-lg text-center"></div>

<div class="space-y-2" id="confidenceStatsTable">

<!-- Rows will be generated by JS -->

</div>

</div>



</div>

</div>



<script>

// --- CORE LOGIC: PATTERN MATCHER ---

class PatternMatcher {

constructor() {

this.MIN_HISTORY_FOR_ANALYSIS = 10;

this.MIN_PATTERN_LENGTH = 10;

this.MAX_PATTERN_LENGTH = 15;

this.MIN_CERTAIN_OCCURRENCES = 2; // Default value

}



calculateSimilarity(arr1, arr2) {

if (arr1.length !== arr2.length || arr1.length === 0) return 0;

const matches = arr1.filter((item, index) => item === arr2[index]).length;

return matches / arr1.length;

}



findPatternOccurrences(pattern, allHistory) {

const occurrences = [];

// This check is now more dynamic, so we rely on the calling function's length checks

// if (pattern.length < this.MIN_PATTERN_LENGTH) return occurrences;

const reversedPattern = [...pattern].reverse();



for (const session of allHistory) {

const sessionHistory = session.history || [];

if (sessionHistory.length < pattern.length + 1) continue;


for (let i = 0; i <= sessionHistory.length - pattern.length - 1; i++) {

const segment = sessionHistory.slice(i, i + pattern.length);

const nextResult = sessionHistory[i + pattern.length];

const similarity = this.calculateSimilarity(pattern, segment);


if (similarity >= 0.9) occurrences.push({ type: 'similar', next: nextResult, similarity });


const reverseSimilarity = this.calculateSimilarity(reversedPattern, segment);

if (reverseSimilarity >= 0.9) occurrences.push({ type: 'reversed', next: nextResult, similarity: reverseSimilarity });

}

}

return occurrences;

}



getPredictionForPattern(pattern, allHistoricalSessions) {

const occurrences = this.findPatternOccurrences(pattern, allHistoricalSessions);


if (occurrences.length === 0) {

return { prediction: null };

}



const votes = { P: 0, B: 0 };

occurrences.forEach(match => {

if (votes[match.next] !== undefined) votes[match.next] += match.similarity;

});



const totalVotes = votes.P + votes.B;

if (totalVotes === 0) {

return { prediction: null };

}


const predictedWinner = votes.P > votes.B ? 'P' : 'B';

const confidence = (Math.max(votes.P, votes.B) / totalVotes) * 100;


return { prediction: predictedWinner, confidence, votes, totalOccurrences: occurrences.length };

}


findCertainPrediction(currentHistory, allHistoricalSessions) {

for (let len = Math.min(this.MAX_PATTERN_LENGTH, currentHistory.length); len >= this.MIN_PATTERN_LENGTH; len--) {

const pattern = currentHistory.slice(-len);

const patternString = pattern.join('');

const occurrences = [];



for (const session of allHistoricalSessions) {

const sessionHistory = session.history || [];

if (sessionHistory.length < pattern.length + 1) continue;


for (let i = 0; i <= sessionHistory.length - pattern.length - 1; i++) {

const segment = sessionHistory.slice(i, i + pattern.length);

if (segment.join('') === patternString) {

const nextResult = sessionHistory[i + pattern.length];

occurrences.push(nextResult);

}

}

}



if (occurrences.length >= this.MIN_CERTAIN_OCCURRENCES && new Set(occurrences).size === 1) {

const predictedWinner = occurrences[0];

return {

prediction: predictedWinner,

recommendation: 'TAY CHáº®C CHáº®N',

analysisText: `TÃ¬m tháº¥y ${occurrences.length} láº§n xuáº¥t hiá»‡n chÃ­nh xÃ¡c cá»§a hÃ¬nh cáº§u nÃ y trong lá»‹ch sá»­.\nTáº¥t cáº£ Ä‘á»u cho káº¿t quáº£ tiáº¿p theo lÃ : ${predictedWinner}`,

confidence: 100,

isCertain: true

};

}

}

return null;

}





analyzeCurrentStreak(currentHistory) {

if (currentHistory.length < 2) return { type: 'none', length: currentHistory.length };

const last = currentHistory[currentHistory.length - 1];

const secondLast = currentHistory[currentHistory.length - 2];

if (last === secondLast) {

let length = 0;

for (let i = currentHistory.length - 1; i >= 0; i--) {

if (currentHistory[i] === last) length++; else break;

}

return { type: 'bá»‡t', length, value: last };

} else {

let length = 0;

for (let i = currentHistory.length - 1; i >= 1; i--) {

if (currentHistory[i] !== currentHistory[i-1]) length++; else break;

}

return { type: '1-1', length: length + 1 };

}

}



getPrediction(currentHistory, allHistoricalSessions, { optimalLength = null, lengthPerformance = {} } = {}) {

if (currentHistory.length < this.MIN_HISTORY_FOR_ANALYSIS) {

return { prediction: null, analysisText: `Cáº§n Ã­t nháº¥t ${this.MIN_HISTORY_FOR_ANALYSIS} káº¿t quáº£...`, confidence: 0, isCertain: false };

}


// --- NEW: Optimal Length Logic ---

if (optimalLength && currentHistory.length >= optimalLength) {

const pattern = currentHistory.slice(-optimalLength);

const result = this.getPredictionForPattern(pattern, allHistoricalSessions);

if (result.prediction) {

const perf = lengthPerformance[optimalLength] || { wins: 0, total: 0 };

const rate = perf.total > 0 ? (perf.wins / perf.total * 100).toFixed(1) : 'N/A';

// --- MODIFICATION START ---
let confidenceRangeTextOptimal = '';
if (result.confidence >= 50) {
Â  Â  const ranges = [
Â  Â  Â  Â  {min: 50, max: 60}, {min: 60, max: 70}, {min: 70, max: 80},
Â  Â  Â  Â  {min: 80, max: 90}, {min: 90, max: 100}
Â  Â  ];
Â  Â  for (const range of ranges) {
Â  Â  Â  Â  if (result.confidence >= range.min && (result.confidence < range.max || (range.max === 100 && result.confidence >= 100))) {
Â  Â  Â  Â  Â  Â  confidenceRangeTextOptimal = `(Thuá»™c khoáº£ng ${range.min}%-${range.max}%)`;
Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  }
Â  Â  }
}
const analysisText = `Sá»­ dá»¥ng chiá»u dÃ i cáº§u tá»‘i Æ°u: ${optimalLength} vÃ¡n.\n(Tá»· lá»‡ tháº¯ng cá»§a chiá»u dÃ i nÃ y: ${rate}% - ${perf.wins}/${perf.total})\n\nLá»‹ch sá»­ cho tháº¥y:\n- PLAYER: ${result.votes.P.toFixed(1)} Ä‘iá»ƒm\n- BANKER: ${result.votes.B.toFixed(1)} Ä‘iá»ƒm\n\nğŸ† Äá»™ tin cáº­y: ${result.confidence.toFixed(1)}% ${confidenceRangeTextOptimal}`;
// --- MODIFICATION END ---

return {

prediction: result.prediction,

recommendation: 'THEO CHIá»€U DÃ€I Tá»I Æ¯U',

analysisText,

confidence: result.confidence,

isCertain: false

};

}

}


// --- FALLBACK: Original Logic ---

const certainPrediction = this.findCertainPrediction(currentHistory, allHistoricalSessions);

if (certainPrediction) {

return certainPrediction;

}



const allMatches = [];

for (let len = Math.min(this.MAX_PATTERN_LENGTH, currentHistory.length); len >= this.MIN_PATTERN_LENGTH; len--) {

const pattern = currentHistory.slice(-len);

const occurrences = this.findPatternOccurrences(pattern, allHistoricalSessions);

if (occurrences.length > 0) {

allMatches.push(...occurrences);

break;

}

}



if (allMatches.length === 0) {

return { prediction: null, analysisText: 'KhÃ´ng tÃ¬m tháº¥y hÃ¬nh cáº§u tÆ°Æ¡ng tá»± (cháº¿ Ä‘á»™ thá»§ cÃ´ng).', confidence: 0, isCertain: false };

}



const votes = { P: 0, B: 0 };

allMatches.forEach(match => {

if (votes[match.next] !== undefined) votes[match.next] += match.similarity;

});



const totalVotes = votes.P + votes.B;

if (totalVotes === 0) {

return { prediction: null, analysisText: 'KhÃ´ng tÃ¬m tháº¥y hÃ¬nh cáº§u tÆ°Æ¡ng tá»± (cháº¿ Ä‘á»™ thá»§ cÃ´ng).', confidence: 0, isCertain: false };

}



const confidenceP = (votes.P / totalVotes) * 100;

const confidenceB = (votes.B / totalVotes) * 100;

const maxConfidence = Math.max(confidenceP, confidenceB);

const predictedWinner = votes.P > votes.B ? 'P' : 'B';



const analysisTextPrefix = `TÃ¬m tháº¥y ${allMatches.length} hÃ¬nh cáº§u tÆ°Æ¡ng tá»±. Lá»‹ch sá»­ cho tháº¥y:\n- PLAYER: ${votes.P.toFixed(1)} Ä‘iá»ƒm\n- BANKER: ${votes.B.toFixed(1)} Ä‘iá»ƒm`;


const streakInfo = this.analyzeCurrentStreak(currentHistory);

let recommendation = '';

if (streakInfo.type === 'bá»‡t' && predictedWinner === streakInfo.value) recommendation = `THEO Cáº¦U Bá»†T (${streakInfo.value} x${streakInfo.length})`;

else if (streakInfo.type === 'bá»‡t' && predictedWinner !== streakInfo.value) recommendation = `Báºº Cáº¦U Bá»†T (${streakInfo.value} x${streakInfo.length})`;

else if (streakInfo.type === '1-1' && predictedWinner !== currentHistory[currentHistory.length - 1]) recommendation = `THEO Cáº¦U 1-1 (DÃ i ${streakInfo.length})`;

else if (streakInfo.type === '1-1' && predictedWinner === currentHistory[currentHistory.length - 1]) recommendation = `Báºº Cáº¦U 1-1 (DÃ i ${streakInfo.length})`;

else recommendation = `THEO PHÃ‚N TÃCH Lá»ŠCH Sá»¬`;


// --- MODIFICATION START ---
let confidenceRangeTextFallback = '';
if (maxConfidence >= 50) {
Â  Â  const ranges = [
Â  Â  Â  Â  {min: 50, max: 60}, {min: 60, max: 70}, {min: 70, max: 80},
Â  Â  Â  Â  {min: 80, max: 90}, {min: 90, max: 100}
Â  Â  ];
Â  Â  for (const range of ranges) {
Â  Â  Â  Â  if (maxConfidence >= range.min && (maxConfidence < range.max || (range.max === 100 && maxConfidence >= 100))) {
Â  Â  Â  Â  Â  Â  confidenceRangeTextFallback = `(Thuá»™c khoáº£ng ${range.min}%-${range.max}%)`;
Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  }
Â  Â  }
}
const analysisText = `${analysisTextPrefix}\n\nğŸ† Äá»™ tin cáº­y: ${maxConfidence.toFixed(1)}% ${confidenceRangeTextFallback}`;
// --- MODIFICATION END ---
return { prediction: predictedWinner, recommendation, analysisText, confidence: maxConfidence, isCertain: false };

}

}



// --- GLOBAL STATE ---

let state = {

currentSessionId: null,

sessions: {},

matcher: new PatternMatcher(),

currentPrediction: null,

goldenRange: null

};


// --- STATS CALCULATION ---

function getPredictionStats(predictions) {
Â  Â  const total = predictions.length;
Â  Â  if (total === 0) return { rate: 0, correct: 0, total: 0 };
Â  Â  const correct = predictions.filter(p => p.predicted === p.actual).length;
Â  Â  return { rate: (correct / total) * 100, correct, total };
}





// --- UI UPDATE FUNCTIONS ---

function updateBigRoadUI() {

const history = state.sessions[state.currentSessionId]?.history || [];

const roadDiv = document.getElementById('bigRoadDisplay');

document.getElementById('totalGames').textContent = history.length;



if (history.length === 0) {

roadDiv.innerHTML = '<p class="text-gray-500 p-4">ChÆ°a cÃ³ káº¿t quáº£...</p>';

roadDiv.style.display = 'block';

return;

}

roadDiv.style.display = 'grid';

roadDiv.innerHTML = '';



const columns = [];

if (history.length > 0) {

let currentCol = [history[0]];

for (let i = 1; i < history.length; i++) {

if (history[i] === history[i-1]) {

currentCol.push(history[i]);

} else {

columns.push(currentCol);

currentCol = [history[i]];

}

}

columns.push(currentCol);

}


let itemCounter = 0;
const totalLength = history.length;

columns.forEach(colData => {

const colDiv = document.createElement('div');

colDiv.className = 'road-col';

colData.forEach(item => {

const itemDiv = document.createElement('div');

const bgColor = item === 'P' ? 'bg-blue-600' : 'bg-red-600';


let highlightClass = '';
if (itemCounter === totalLength - 2) {
Â  Â  highlightClass = ' previous-hand';
} else if (itemCounter === totalLength - 1) {
Â  Â  highlightClass = ' current-hand';
}


itemDiv.className = `road-item ${bgColor}${highlightClass}`;

itemDiv.textContent = item;

colDiv.appendChild(itemDiv);
itemCounter++;
});

roadDiv.appendChild(colDiv);

});

roadDiv.scrollLeft = roadDiv.scrollWidth;

}



function updateAccuracyUI() {

const predictions = state.sessions[state.currentSessionId]?.predictions || [];

const stats = getPredictionStats(predictions);

document.getElementById('accuracyRate').textContent = `${stats.rate.toFixed(1)}%`;

document.getElementById('correctPredictions').textContent = stats.correct;

document.getElementById('totalPredictions').textContent = stats.total;

}



function updateGlobalAccuracyUI() {

const allPredictions = Object.values(state.sessions).flatMap(s => s.predictions || []);

const stats = getPredictionStats(allPredictions);

document.getElementById('globalAccuracyRate').textContent = `${stats.rate.toFixed(1)}%`;

document.getElementById('globalCorrectPredictions').textContent = stats.correct;

document.getElementById('globalTotalPredictions').textContent = stats.total;

}



function updateAnalysisUI() {

const session = state.sessions[state.currentSessionId] || { history: [], optimalLength: null, lengthPerformance: {} };

const currentHistory = session.history;

const allHistory = Object.values(state.sessions);



let { prediction, recommendation, analysisText, confidence, isCertain } = state.matcher.getPrediction(currentHistory, allHistory, {

optimalLength: session.optimalLength,

lengthPerformance: session.lengthPerformance

});


state.currentPrediction = { prediction, confidence };



let finalPrediction = prediction;

let finalRecommendation = recommendation;

let recommendationNote = '';



if (prediction && !isCertain) {

let isInGoldenRange = false;

if (state.goldenRange && confidence >= state.goldenRange.min && confidence <= state.goldenRange.max) {

isInGoldenRange = true;

}



if (isInGoldenRange) {

if (state.goldenRange.rate < 30) {

finalPrediction = prediction === 'P' ? 'B' : 'P';

finalRecommendation = `Äá»€ XUáº¤T NGÆ¯á»¢C (Tá»· lá»‡ tháº¥p)`;

recommendationNote = `<div class="mt-2 p-2 text-center bg-red-800 bg-opacity-50 rounded-lg text-sm text-red-300 font-semibold">âš ï¸ Äáº£o ngÆ°á»£c! Khoáº£ng vÃ ng (${state.goldenRange.min}-${state.goldenRange.max}%) cÃ³ tá»· lá»‡ tháº¯ng chá»‰ ${state.goldenRange.rate.toFixed(1)}%.</div>`;

} else {

recommendationNote = `<div class="mt-2 p-2 text-center bg-green-800 bg-opacity-50 rounded-lg text-sm text-green-300 font-semibold">âœ¨ PhÃ¡n Ä‘oÃ¡n nÃ y náº±m trong KHOáº¢NG VÃ€NG!</div>`;

}

} else if (state.goldenRange) {

recommendationNote = `<div class="mt-2 p-2 text-center bg-yellow-800 bg-opacity-50 rounded-lg text-sm text-yellow-300 font-semibold">âš ï¸ Cáº©n trá»ng: KhÃ´ng thuá»™c Khoáº£ng VÃ ng.</div>`;

}

}


const analysisResultDiv = document.getElementById('analysisResult');

const analysisCard = document.getElementById('analysis-card');

analysisCard.classList.remove('card-glow-p', 'card-glow-b', 'card-glow-certain');



let optimalLengthDisplay = '';

if (session.optimalLength) {

optimalLengthDisplay = `<div class="mb-4 p-3 bg-gray-900 rounded-lg text-center text-cyan-300 text-sm">

<span class="font-semibold">Chiá»u dÃ i cáº§u tá»‘i Æ°u Ä‘ang Ã¡p dá»¥ng:</span>

<span class="text-lg font-bold ml-2">${session.optimalLength}</span>

</div>`;

}



if (finalPrediction) {

let predictionBlockHTML = '';

if (isCertain) {

predictionBlockHTML = `

<div class="text-center bg-yellow-800 bg-opacity-50 py-6 rounded-lg border-2 border-yellow-400">

<p class="text-lg text-yellow-300 mb-2 animate-pulse">Äá» Xuáº¥t Cháº¯c Cháº¯n (Lá»‹ch sá»­):</p>

<p class="text-3xl font-extrabold text-yellow-300">${finalRecommendation}</p>

<p class="text-4xl font-bold mt-2">${finalPrediction === 'P' ? 'ğŸ‘¤ PLAYER' : 'ğŸ¦ BANKER'}</p>

</div>

`;

analysisCard.classList.add('card-glow-certain');

} else {

predictionBlockHTML = `

<div class="text-center bg-gray-900 py-6 rounded-lg border-2 ${finalPrediction === 'P' ? 'border-blue-500' : 'border-red-500'}">

<p class="text-lg text-gray-400 mb-2">Äá» xuáº¥t:</p>

<p class="text-3xl font-extrabold ${finalPrediction === 'P' ? 'text-blue-400' : 'text-red-400'}">${finalRecommendation}</p>

<p class="text-4xl font-bold mt-2">${finalPrediction === 'P' ? 'ğŸ‘¤ PLAYER' : 'ğŸ¦ BANKER'}</p>

${recommendationNote}

</div>

`;

analysisCard.classList.add(finalPrediction === 'P' ? 'card-glow-p' : 'card-glow-b');

}



analysisResultDiv.innerHTML = `

${optimalLengthDisplay}

<div class="bg-gray-700 p-4 rounded-lg">

<p class="text-gray-300 whitespace-pre-wrap">${analysisText}</p>

</div>

${predictionBlockHTML}

`;



} else {

analysisResultDiv.innerHTML = `

${optimalLengthDisplay}

<p class="text-gray-400 text-center py-8 whitespace-pre-wrap">${analysisText}</p>

`;

}

}


function updateConfidenceStatsUI() {

if (!state.currentSessionId || !state.sessions[state.currentSessionId]) return;



const sessionPredictions = state.sessions[state.currentSessionId].predictions || [];

const ranges = [

{min: 50, max: 60, total: 0, wins: 0},

{min: 60, max: 70, total: 0, wins: 0},

{min: 70, max: 80, total: 0, wins: 0},

{min: 80, max: 90, total: 0, wins: 0},

{min: 90, max: 100, total: 0, wins: 0},

];



const tableDiv = document.getElementById('confidenceStatsTable');

const recommendationDiv = document.getElementById('confidenceRecommendation');

const currentConfidence = state.currentPrediction?.confidence;


let bestRange = null;

let maxRate = -1;



ranges.forEach(range => {

const predictionsForRange = sessionPredictions.filter(p => {

const confidence = p.confidence;

return confidence >= range.min && (confidence < range.max || (range.max === 100 && confidence >= 100));

});


range.predictions = predictionsForRange; // Store predictions for the chart
range.total = predictionsForRange.length;

range.wins = predictionsForRange.filter(p => p.predicted === p.actual).length;

const rate = range.total > 0 ? ((range.wins / range.total) * 100) : -1;

range.rate = rate;


// Calculate trend

let trendIndicator = '';

let streak = 0;

if (predictionsForRange.length >= 1) {

const lastResultIsWin = (predictionsForRange[predictionsForRange.length - 1].predicted === predictionsForRange[predictionsForRange.length - 1].actual);

for (let i = predictionsForRange.length - 1; i >= 0; i--) {

const currentResultIsWin = (predictionsForRange[i].predicted === predictionsForRange[i].actual);

if (currentResultIsWin === lastResultIsWin) {

streak++;

} else {

break;

}

}



if (streak >= 1) {

if (lastResultIsWin) {

trendIndicator = `<span class="flex items-center text-blue-400 ml-1.5">

<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z" clip-rule="evenodd"></path></svg>

<span class="font-bold text-xs">${streak}</span>

</span>`;

} else {

trendIndicator = `<span class="flex items-center text-red-400 ml-1.5">

<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>

<span class="font-bold text-xs">${streak}</span>

</span>`;

}

}

}

range.trendIndicator = trendIndicator;



if (range.total >= 3 && rate > maxRate) {

maxRate = rate;

bestRange = range;

}

});


state.goldenRange = bestRange;



if (bestRange) {

recommendationDiv.innerHTML = `<p class="text-sm text-yellow-300"><span class="font-bold">âœ¨ Khoáº£ng VÃ ng (PhiÃªn):</span> Tá»· lá»‡ tháº¯ng cao nháº¥t lÃ  <b class="text-blue-400">${maxRate.toFixed(1)}%</b> trong khoáº£ng <b class="text-white">${bestRange.min}%-${bestRange.max}%</b>.</p>`;

} else {

recommendationDiv.innerHTML = `<p class="text-sm text-gray-400">ChÆ°a Ä‘á»§ dá»¯ liá»‡u Ä‘á»ƒ tÃ¬m ra khoáº£ng vÃ ng cho phiÃªn nÃ y (cáº§n tá»‘i thiá»ƒu 3 phÃ¡n Ä‘oÃ¡n trong 1 khoáº£ng).</p>`;

}



let html = `

<div class="grid gap-x-2 text-xs font-semibold text-gray-400 px-3" style="grid-template-columns: 4fr 2fr 2fr 4fr;">

<span class="text-left">Khoáº£ng</span>

<span class="text-center">Tá»•ng</span>

<span class="text-center">Tháº¯ng</span>

<span class="text-right">Tá»· Lá»‡</span>

</div>

`;

if (sessionPredictions.length === 0) {

tableDiv.innerHTML = '<p class="text-gray-500 text-center py-4">ChÆ°a cÃ³ dá»¯ liá»‡u thá»‘ng kÃª cho phiÃªn nÃ y.</p>';

} else {

ranges.forEach(range => {

const rate = range.rate;

const isBest = range === bestRange;

let isCurrentPredictionRange = false;
if (currentConfidence) {
Â  Â  if (currentConfidence >= range.min && (currentConfidence < range.max || (range.max === 100 && currentConfidence >= 100))) {
Â  Â  Â  Â  isCurrentPredictionRange = true;
Â  Â  }
}

// --- Build Bar Chart ---
let chartHtml = '';
if (range.predictions && range.predictions.length > 0) {
    chartHtml += '<div class="bar-chart-container mt-2">';
    range.predictions.forEach(p => {
        const resultClass = p.predicted === p.actual ? 'win' : 'loss';
        const title = `Dá»± Ä‘oÃ¡n: ${p.predicted}, Thá»±c táº¿: ${p.actual}, Äá»™ tin cáº­y: ${p.confidence.toFixed(1)}%`;
        chartHtml += `<div class="bar ${resultClass}" title="${title}"></div>`;
    });
    chartHtml += '</div>';
}

const rowHighlightClasses = [
    'p-3', 'rounded-lg', 'mt-2', 'transition-all', 'duration-300',
    ...(isBest ? ['bg-blue-800', 'bg-opacity-40', 'border', 'border-blue-500'] : ['bg-gray-700', 'bg-opacity-50']),
    ...(isCurrentPredictionRange ? ['current-prediction-range'] : [])
].join(' ');


html += `
<div class="${rowHighlightClasses}">
    <div class="grid gap-x-2 items-center text-sm" style="grid-template-columns: 4fr 2fr 2fr 4fr;">
        <span class="font-medium text-gray-300 text-left">${range.min}%-${range.max}%</span>
        <span class="text-white font-semibold text-center">${range.total}</span>
        <span class="text-blue-400 font-semibold text-center">${range.wins}</span>
        <span class="font-bold flex items-center justify-end ${rate >= 70 ? 'text-blue-400' : (rate >= 50 ? 'text-yellow-400' : 'text-red-400')}">
            ${rate > -1 ? rate.toFixed(1) + '%' : '-'}
            ${range.trendIndicator}
        </span>
    </div>
    ${chartHtml}
</div>
`;

});

tableDiv.innerHTML = html;

}

}





function updateAllUI() {

updateBigRoadUI();

updateAccuracyUI();

updateGlobalAccuracyUI();
updateAnalysisUI();
updateConfidenceStatsUI();

}



// --- EVENT HANDLERS & ACTIONS ---

function addResult(result) {

if (!state.currentSessionId) return;

const session = state.sessions[state.currentSessionId];

const historyBeforeAdd = [...session.history];

const allSessions = Object.values(state.sessions);



// New logic: Update stats and find optimal length based on the result being added

const newOptimalLength = updateLengthPerformanceAndFindOptimal(historyBeforeAdd, allSessions, result);

session.optimalLength = newOptimalLength;



// Original logic: Store the last prediction vs actual result

if (state.currentPrediction && state.currentPrediction.prediction) {

session.predictions.push({

predicted: state.currentPrediction.prediction,

actual: result,

confidence: state.currentPrediction.confidence

});

}

state.currentPrediction = null;



session.history.push(result);


saveSessions();

updateAllUI();

}



// --- NEW: Optimal Length Finder ---

function updateLengthPerformanceAndFindOptimal(history, allSessions, newResult) {

const session = state.sessions[state.currentSessionId];

if (!session.lengthPerformance) {

session.lengthPerformance = {};

}



const candidates = [];



for (let len = 10; len <= 20; len++) {

if (history.length < len) continue;



const pattern = history.slice(-len);

const { prediction } = state.matcher.getPredictionForPattern(pattern, allSessions);



if (prediction) {

// Initialize stats if not present

if (!session.lengthPerformance[len]) {

session.lengthPerformance[len] = { wins: 0, total: 0 };

}


// Update stats for this length based on its prediction for the newResult

const stats = session.lengthPerformance[len];

stats.total++;

if (prediction === newResult) {

stats.wins++;

}


// Check if this length is a candidate for being the new optimal

// A length is a candidate if its prediction for the previous hand matched the new result

if (prediction === newResult) {

candidates.push({

length: len,

rate: stats.wins / stats.total,

total: stats.total

});

}

}

}


if (candidates.length === 0) {

return session.optimalLength; // Keep the old one if no candidates found

}



// Sort by rate desc, then total desc

candidates.sort((a, b) => {

if (b.rate !== a.rate) {

return b.rate - a.rate;

}

return b.total - a.total;

});


return candidates[0].length; // The new optimal length

}



function undoLast() {

if (!state.currentSessionId || state.sessions[state.currentSessionId].history.length === 0) return;


// This is complex with the new logic, so a simple pop is best.

// Re-calculating optimal length on undo is too intensive.

state.sessions[state.currentSessionId].history.pop();


const predictions = state.sessions[state.currentSessionId].predictions;

if (predictions.length > 0) {

predictions.pop();

}


saveSessions();

updateAllUI();

}



function clearCurrentSessionHistory() {

if (!state.currentSessionId) return;

if (confirm('Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a toÃ n bá»™ lá»‹ch sá»­ vÃ  thá»‘ng kÃª cá»§a phiÃªn nÃ y khÃ´ng?')) {

const session = state.sessions[state.currentSessionId];

session.history = [];

session.predictions = [];

session.lengthPerformance = {};

session.optimalLength = null;

saveSessions();

updateAllUI();

}

}



// --- SESSION MANAGEMENT ---

function getSessions() {

try {

return JSON.parse(localStorage.getItem('baccaratPatternSessions_v4')) || {};

} catch (e) { return {}; }

}



function saveSessions() {

localStorage.setItem('baccaratPatternSessions_v4', JSON.stringify(state.sessions));

localStorage.setItem('lastActiveSession_v4', state.currentSessionId);

}


function renameSession() {

if (!state.currentSessionId) return;

const currentName = state.sessions[state.currentSessionId].name;

const newName = prompt("Nháº­p tÃªn má»›i cho phiÃªn:", currentName);

if (newName && newName.trim() !== "") {

state.sessions[state.currentSessionId].name = newName.trim();

saveSessions();

updateSessionSelector();

}

}



function updateSessionSelector() {

const selector = document.getElementById('sessionSelector');

selector.innerHTML = '';

const sortedKeys = Object.keys(state.sessions).sort((a, b) => parseInt(b.split('-')[1]) - parseInt(a.split('-')[1]));


sortedKeys.forEach((sessionId) => {

const session = state.sessions[sessionId];

const option = document.createElement('option');

option.value = sessionId;

option.textContent = `${session.name} (${session.history.length} vÃ¡n)`;

selector.appendChild(option);

});

selector.value = state.currentSessionId;

selector.onchange = () => loadSession(selector.value);

}



function createNewSession() {

const newId = `session-${Date.now()}`;

state.currentSessionId = newId;

state.sessions[newId] = {

name: `PhiÃªn ${new Date().toLocaleString('vi-VN')}`,

history: [],

predictions: [],

lengthPerformance: {},

optimalLength: null

};

saveSessions();

updateSessionSelector();

updateAllUI();

}



function deleteSelectedSession() {

if (!state.currentSessionId || Object.keys(state.sessions).length <= 1) {

alert('KhÃ´ng thá»ƒ xÃ³a phiÃªn cuá»‘i cÃ¹ng.');

return;

}

if (confirm('Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a phiÃªn nÃ y khÃ´ng?')) {

delete state.sessions[state.currentSessionId];

state.currentSessionId = null;

localStorage.removeItem('lastActiveSession_v4');

saveSessions();

initializeApp();

}

}



function loadSession(sessionId) {

if (state.sessions[sessionId]) {

state.currentSessionId = sessionId;

state.currentPrediction = null;

localStorage.setItem('lastActiveSession_v4', state.currentSessionId);

updateSessionSelector();

updateAllUI();

}

}


// --- SETTINGS ---

function saveSettings() {

const settings = {

minPatternLength: document.getElementById('minPatternLength').value,

maxPatternLength: document.getElementById('maxPatternLength').value,

minCertainOccurrences: document.getElementById('minCertainOccurrences').value

};

localStorage.setItem('baccaratSettings_v1', JSON.stringify(settings));

applySettings(settings);

alert('CÃ i Ä‘áº·t Ä‘Ã£ Ä‘Æ°á»£c lÆ°u!');

updateAnalysisUI(); // Re-run analysis with new settings

}



function applySettings(settings) {

if (settings.minPatternLength) {

state.matcher.MIN_PATTERN_LENGTH = parseInt(settings.minPatternLength, 10);

}

if (settings.maxPatternLength) {

state.matcher.MAX_PATTERN_LENGTH = parseInt(settings.maxPatternLength, 10);

}

if (settings.minCertainOccurrences) {

state.matcher.MIN_CERTAIN_OCCURRENCES = parseInt(settings.minCertainOccurrences, 10);

}

}



function loadSettings() {

const settingsStr = localStorage.getItem('baccaratSettings_v1');

const settings = settingsStr ? JSON.parse(settingsStr) : {};


applySettings(settings);



document.getElementById('minPatternLength').value = state.matcher.MIN_PATTERN_LENGTH;

document.getElementById('maxPatternLength').value = state.matcher.MAX_PATTERN_LENGTH;

document.getElementById('minCertainOccurrences').value = state.matcher.MIN_CERTAIN_OCCURRENCES;

}



// --- IMPORT / EXPORT ---

function exportData() {

if (Object.keys(state.sessions).length === 0) {

alert("KhÃ´ng cÃ³ dá»¯ liá»‡u Ä‘á»ƒ xuáº¥t.");

return;

}

const dataStr = JSON.stringify(state.sessions, null, 2);

const dataBlob = new Blob([dataStr], {type: "application/json"});

const url = URL.createObjectURL(dataBlob);

const link = document.createElement('a');

link.download = `baccarat_backup_${new Date().toISOString().slice(0,10)}.json`;

link.href = url;

link.click();

URL.revokeObjectURL(url);

}



function importData(event) {

const file = event.target.files[0];

if (!file) return;

const reader = new FileReader();

reader.onload = function(e) {

try {

const importedSessions = JSON.parse(e.target.result);

if (typeof importedSessions !== 'object' || importedSessions === null) throw new Error("Invalid format");


for(const key in importedSessions) {

const session = importedSessions[key];

if(!session.name || !Array.isArray(session.history)) {

throw new Error("Invalid session data");

}

// Add new fields if they don't exist in the imported file

if (!session.predictions) session.predictions = [];

if (!session.lengthPerformance) session.lengthPerformance = {};

if (session.optimalLength === undefined) session.optimalLength = null;

}



if (confirm('Dá»¯ liá»‡u hiá»‡n táº¡i sáº½ bá»‹ ghi Ä‘Ã¨. Báº¡n cÃ³ cháº¯c muá»‘n tiáº¿p tá»¥c?')) {

state.sessions = importedSessions;

state.currentSessionId = null;

localStorage.removeItem('lastActiveSession_v4');

saveSessions();

initializeApp();

alert('Nháº­p dá»¯ liá»‡u thÃ nh cÃ´ng!');

}

} catch (error) {

alert('Lá»—i: File dá»¯ liá»‡u khÃ´ng há»£p lá»‡. Vui lÃ²ng kiá»ƒm tra láº¡i file.');

console.error("Import error:", error);

} finally {

event.target.value = '';

}

};

reader.readAsText(file);

}



function initializeApp() {

loadSettings();

state.sessions = getSessions();


// Ensure all loaded sessions have the new properties

Object.values(state.sessions).forEach(session => {

if (!session.lengthPerformance) session.lengthPerformance = {};

if (session.optimalLength === undefined) session.optimalLength = null;

});



const lastActiveId = localStorage.getItem('lastActiveSession_v4');



if (Object.keys(state.sessions).length === 0) {

createNewSession();

} else {

const sortedKeys = Object.keys(state.sessions).sort((a, b) => parseInt(b.split('-')[1]) - parseInt(a.split('-')[1]));

const idToLoad = (lastActiveId && state.sessions[lastActiveId]) ? lastActiveId : sortedKeys[0];

loadSession(idToLoad);

}

}



// --- INITIALIZATION ---

document.addEventListener('DOMContentLoaded', initializeApp);

</script>

</body>

</html>

