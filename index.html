<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BACCARAT SIDE BETS ANALYZER - H·ªá Th·ªëng Chuy√™n S√¢u ƒê√¥i & H√≤a</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(255, 0, 255, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(0, 255, 255, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(255, 255, 0, 0.05) 0%, transparent 50%);
            pointer-events: none;
            animation: backgroundFloat 20s ease-in-out infinite;
        }

        @keyframes backgroundFloat {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            33% { transform: translate(-20px, -20px) rotate(120deg); }
            66% { transform: translate(20px, -10px) rotate(240deg); }
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            position: relative;
            z-index: 2;
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '‚ô†‚ô•‚ô¶‚ô£';
            position: absolute;
            top: -50px;
            right: -50px;
            font-size: 150px;
            opacity: 0.05;
            transform: rotate(15deg);
        }

        h1 {
            font-size: 3em;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #f5576c 75%, #fda085 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
            text-shadow: 0 0 40px rgba(255, 255, 255, 0.3);
            animation: titleGlow 3s ease-in-out infinite;
        }

        @keyframes titleGlow {
            0%, 100% { filter: brightness(1) saturate(1); }
            50% { filter: brightness(1.2) saturate(1.2); }
        }

        .subtitle {
            font-size: 1.3em;
            color: #ffd700;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-weight: 600;
            animation: subtitlePulse 2s ease-in-out infinite;
        }

        @keyframes subtitlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Main Stats Dashboard */
        .main-dashboard {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .dashboard-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .dashboard-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
        }

        .dashboard-card.player-pair {
            border-color: #3498db;
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.2) 0%, rgba(52, 152, 219, 0.1) 100%);
        }

        .dashboard-card.banker-pair {
            border-color: #e74c3c;
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.2) 0%, rgba(231, 76, 60, 0.1) 100%);
        }

        .dashboard-card.tie {
            border-color: #f39c12;
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.2) 0%, rgba(243, 156, 18, 0.1) 100%);
        }

        .card-icon {
            font-size: 3em;
            margin-bottom: 15px;
            display: inline-block;
            animation: iconFloat 3s ease-in-out infinite;
        }

        @keyframes iconFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .card-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.85em;
            color: #aaa;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #fff;
        }

        .stat-value.highlight {
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            animation: valueGlow 2s ease-in-out infinite;
        }

        @keyframes valueGlow {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Prediction Panel */
        .prediction-panel {
            background: linear-gradient(135deg, rgba(147, 51, 234, 0.2) 0%, rgba(79, 70, 229, 0.2) 100%);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px solid #9333ea;
            position: relative;
        }

        .prediction-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .prediction-title {
            font-size: 1.8em;
            color: #a78bfa;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .ai-badge {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.6em;
            animation: badgePulse 2s ease-in-out infinite;
        }

        @keyframes badgePulse {
            0%, 100% { box-shadow: 0 0 20px rgba(240, 147, 251, 0.5); }
            50% { box-shadow: 0 0 40px rgba(240, 147, 251, 0.8); }
        }

        .predictions-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }

        .prediction-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .prediction-card.hot {
            border-color: #ff6b6b;
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.3) 0%, rgba(255, 107, 107, 0.1) 100%);
            animation: hotPulse 1.5s ease-in-out infinite;
        }

        @keyframes hotPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 107, 107, 0.5); }
            50% { box-shadow: 0 0 40px rgba(255, 107, 107, 0.8); }
        }

        .prediction-type {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .prediction-probability {
            font-size: 2.5em;
            font-weight: bold;
            margin: 15px 0;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .confidence-meter {
            height: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #0abde3, #00d2d3);
            transition: width 0.5s ease;
        }

        .next-prediction {
            margin-top: 10px;
            font-size: 0.9em;
            color: #aaa;
        }

        /* Hot Cold Analysis */
        .hot-cold-section {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .hot-cold-panel {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .hot-panel {
            border-color: #ff6b6b;
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.1) 0%, transparent 100%);
        }

        .cold-panel {
            border-color: #4dabf7;
            background: linear-gradient(135deg, rgba(77, 171, 247, 0.1) 0%, transparent 100%);
        }

        .panel-title {
            font-size: 1.3em;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .hot-icon {
            color: #ff6b6b;
            font-size: 1.5em;
        }

        .cold-icon {
            color: #4dabf7;
            font-size: 1.5em;
        }

        .number-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
        }

        .number-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .number-item:hover {
            transform: scale(1.1);
        }

        .number-item.very-hot {
            background: linear-gradient(135deg, #ff6b6b 0%, #ff4757 100%);
            animation: numberGlow 1s ease-in-out infinite;
        }

        .number-item.very-cold {
            background: linear-gradient(135deg, #4dabf7 0%, #3498db 100%);
        }

        @keyframes numberGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 107, 107, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 107, 107, 0.8); }
        }

        /* Pattern Recognition */
        .pattern-section {
            background: linear-gradient(135deg, rgba(46, 213, 115, 0.1) 0%, rgba(0, 184, 148, 0.1) 100%);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px solid #00b894;
        }

        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .pattern-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .pattern-card.active {
            background: linear-gradient(135deg, rgba(46, 213, 115, 0.3) 0%, rgba(0, 184, 148, 0.3) 100%);
            border-color: #00b894;
            animation: patternActive 2s ease-in-out infinite;
        }

        @keyframes patternActive {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .pattern-name {
            font-weight: bold;
            margin-bottom: 10px;
            color: #00b894;
        }

        .pattern-count {
            font-size: 1.5em;
            font-weight: bold;
            color: #fff;
        }

        .pattern-accuracy {
            font-size: 0.9em;
            color: #aaa;
            margin-top: 5px;
        }

        /* Control Panel */
        .control-panel {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 30px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .control-title {
            font-size: 1.4em;
            margin-bottom: 20px;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        button {
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            font-weight: bold;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ff4757 100%);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #feca57 0%, #ff9ff3 100%);
            color: white;
        }

        /* History Display */
        .history-section {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 30px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .history-display {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            min-height: 80px;
            align-items: center;
        }

        .history-item {
            padding: 10px 15px;
            border-radius: 10px;
            font-weight: bold;
            font-size: 0.95em;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.3s ease;
        }

        .history-item:hover {
            transform: scale(1.1);
        }

        .history-item.player-pair {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .history-item.banker-pair {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .history-item.tie {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
        }

        .history-item.both-pair {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
        }

        .history-item.normal {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
            color: white;
        }

        /* Algorithm Status */
        .algorithm-status {
            background: linear-gradient(135deg, rgba(155, 89, 182, 0.1) 0%, rgba(142, 68, 173, 0.1) 100%);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px solid #9b59b6;
        }

        .algorithm-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .algorithm-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .algorithm-name {
            font-weight: bold;
            color: #bb8fce;
            margin-bottom: 10px;
        }

        .algorithm-accuracy {
            font-size: 1.8em;
            font-weight: bold;
            color: #fff;
            margin: 10px 0;
        }

        .algorithm-status-text {
            font-size: 0.9em;
            padding: 5px 10px;
            border-radius: 20px;
            display: inline-block;
        }

        .status-active {
            background: rgba(46, 213, 115, 0.3);
            color: #00b894;
        }

        .status-learning {
            background: rgba(243, 156, 18, 0.3);
            color: #f39c12;
        }

        /* Alert System */
        .alert-system {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 350px;
        }

        .alert {
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 15px 20px;
            border-radius: 15px;
            margin-bottom: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .alert-icon {
            font-size: 1.5em;
        }

        .alert-hot {
            border-left: 5px solid #ff6b6b;
        }

        .alert-pair {
            border-left: 5px solid #9b59b6;
        }

        .alert-tie {
            border-left: 5px solid #f39c12;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .main-dashboard {
                grid-template-columns: 1fr;
            }
            
            .predictions-grid {
                grid-template-columns: 1fr;
            }
            
            .hot-cold-section {
                grid-template-columns: 1fr;
            }
            
            .pattern-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
            }
            
            .control-buttons {
                grid-template-columns: 1fr;
            }
            
            .card-stats {
                grid-template-columns: 1fr;
            }
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: rgba(0, 0, 0, 0.9);
            color: #fff;
            text-align: center;
            border-radius: 10px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.9em;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üé∞ SIDE BETS ANALYZER üé∞</h1>
            <div class="subtitle">H·ªá Th·ªëng AI Chuy√™n S√¢u - ƒê√¥i Con | ƒê√¥i C√°i | H√≤a</div>
        </div>

        <!-- Main Dashboard -->
        <div class="main-dashboard">
            <div class="dashboard-card player-pair">
                <div class="card-icon">üë•</div>
                <div class="card-title">ƒê√îI CON (Player Pair)</div>
                <div class="card-stats">
                    <div class="stat-item">
                        <div class="stat-label">T·∫ßn Su·∫•t</div>
                        <div class="stat-value" id="ppFrequency">0%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">L·∫ßn Xu·∫•t Hi·ªán</div>
                        <div class="stat-value" id="ppCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">C√°ch L·∫ßn Cu·ªëi</div>
                        <div class="stat-value highlight" id="ppGap">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Tr·∫°ng Th√°i</div>
                        <div class="stat-value" id="ppStatus">-</div>
                    </div>
                </div>
            </div>

            <div class="dashboard-card banker-pair">
                <div class="card-icon">üë•</div>
                <div class="card-title">ƒê√îI C√ÅI (Banker Pair)</div>
                <div class="card-stats">
                    <div class="stat-item">
                        <div class="stat-label">T·∫ßn Su·∫•t</div>
                        <div class="stat-value" id="bpFrequency">0%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">L·∫ßn Xu·∫•t Hi·ªán</div>
                        <div class="stat-value" id="bpCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">C√°ch L·∫ßn Cu·ªëi</div>
                        <div class="stat-value highlight" id="bpGap">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Tr·∫°ng Th√°i</div>
                        <div class="stat-value" id="bpStatus">-</div>
                    </div>
                </div>
            </div>

            <div class="dashboard-card tie">
                <div class="card-icon">ü§ù</div>
                <div class="card-title">H√íA (Tie)</div>
                <div class="card-stats">
                    <div class="stat-item">
                        <div class="stat-label">T·∫ßn Su·∫•t</div>
                        <div class="stat-value" id="tieFrequency">0%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">L·∫ßn Xu·∫•t Hi·ªán</div>
                        <div class="stat-value" id="tieCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">C√°ch L·∫ßn Cu·ªëi</div>
                        <div class="stat-value highlight" id="tieGap">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Tr·∫°ng Th√°i</div>
                        <div class="stat-value" id="tieStatus">-</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- AI Prediction Panel -->
        <div class="prediction-panel">
            <div class="prediction-header">
                <div class="prediction-title">
                    üîÆ D·ª∞ ƒêO√ÅN AI TH√îNG MINH
                    <span class="ai-badge">DEEP LEARNING</span>
                </div>
            </div>
            <div class="predictions-grid">
                <div class="prediction-card" id="ppPredCard">
                    <div class="prediction-type">üë• ƒê√îI CON</div>
                    <div class="prediction-probability" id="ppProb">0%</div>
                    <div class="confidence-meter">
                        <div class="confidence-fill" id="ppConfidence" style="width: 0%"></div>
                    </div>
                    <div class="next-prediction" id="ppNext">D·ª± ƒëo√°n: -</div>
                </div>

                <div class="prediction-card" id="bpPredCard">
                    <div class="prediction-type">üë• ƒê√îI C√ÅI</div>
                    <div class="prediction-probability" id="bpProb">0%</div>
                    <div class="confidence-meter">
                        <div class="confidence-fill" id="bpConfidence" style="width: 0%"></div>
                    </div>
                    <div class="next-prediction" id="bpNext">D·ª± ƒëo√°n: -</div>
                </div>

                <div class="prediction-card" id="tiePredCard">
                    <div class="prediction-type">ü§ù H√íA</div>
                    <div class="prediction-probability" id="tieProb">0%</div>
                    <div class="confidence-meter">
                        <div class="confidence-fill" id="tieConfidence" style="width: 0%"></div>
                    </div>
                    <div class="next-prediction" id="tieNext">D·ª± ƒëo√°n: -</div>
                </div>
            </div>
        </div>

        <!-- Hot/Cold Analysis -->
        <div class="hot-cold-section">
            <div class="hot-cold-panel hot-panel">
                <div class="panel-title">
                    <span class="hot-icon">üî•</span>
                    S·ªê N√ìNG - D·ª∞ ƒêO√ÅN CAO
                </div>
                <div class="number-grid" id="hotNumbers"></div>
            </div>

            <div class="hot-cold-panel cold-panel">
                <div class="panel-title">
                    <span class="cold-icon">‚ùÑÔ∏è</span>
                    S·ªê L·∫†NH - S·∫ÆP XU·∫§T HI·ªÜN
                </div>
                <div class="number-grid" id="coldNumbers"></div>
            </div>
        </div>

        <!-- Pattern Recognition -->
        <div class="pattern-section">
            <div class="control-title">
                üéØ NH·∫¨N DI·ªÜN M·∫™U CHU·∫®N
            </div>
            <div class="pattern-grid" id="patternGrid"></div>
        </div>

        <!-- Algorithm Status -->
        <div class="algorithm-status">
            <div class="control-title">
                ü§ñ THU·∫¨T TO√ÅN AI ƒêANG HO·∫†T ƒê·ªòNG
            </div>
            <div class="algorithm-grid">
                <div class="algorithm-item">
                    <div class="algorithm-name">Neural Network</div>
                    <div class="algorithm-accuracy" id="nnAccuracy">0%</div>
                    <div class="algorithm-status-text status-active">Ho·∫°t ƒê·ªông</div>
                </div>
                <div class="algorithm-item">
                    <div class="algorithm-name">Pattern Recognition</div>
                    <div class="algorithm-accuracy" id="prAccuracy">0%</div>
                    <div class="algorithm-status-text status-active">Ho·∫°t ƒê·ªông</div>
                </div>
                <div class="algorithm-item">
                    <div class="algorithm-name">Statistical Analysis</div>
                    <div class="algorithm-accuracy" id="saAccuracy">0%</div>
                    <div class="algorithm-status-text status-active">Ho·∫°t ƒê·ªông</div>
                </div>
                <div class="algorithm-item">
                    <div class="algorithm-name">Cycle Detection</div>
                    <div class="algorithm-accuracy" id="cdAccuracy">0%</div>
                    <div class="algorithm-status-text status-learning">ƒêang H·ªçc</div>
                </div>
            </div>
        </div>

        <!-- Control Panel -->
        <div class="control-panel">
            <div class="control-title">
                üéÆ B·∫¢NG ƒêI·ªÄU KHI·ªÇN
            </div>
            <div class="control-buttons">
                <button class="btn-primary" onclick="addResult('PP')">üë• ƒê√¥i Con</button>
                <button class="btn-primary" onclick="addResult('BP')">üë• ƒê√¥i C√°i</button>
                <button class="btn-warning" onclick="addResult('T')">ü§ù H√≤a</button>
                <button class="btn-success" onclick="addResult('N')">‚úì B√¨nh Th∆∞·ªùng</button>
                <button class="btn-primary" onclick="addResult('BOTH')">üë•üë• C·∫£ Hai ƒê√¥i</button>
                <button class="btn-danger" onclick="undoLast()">‚Ü©Ô∏è Ho√†n T√°c</button>
                <button class="btn-danger" onclick="clearAll()">üóëÔ∏è X√≥a T·∫•t C·∫£</button>
                <button class="btn-success" onclick="generateDemo()">üé≤ Demo AI</button>
            </div>
        </div>

        <!-- History Display -->
        <div class="history-section">
            <div class="control-title">
                üìä L·ªäCH S·ª¨ K·∫æT QU·∫¢
            </div>
            <div class="history-display" id="historyDisplay">
                <div style="color: #888;">Ch∆∞a c√≥ d·ªØ li·ªáu...</div>
            </div>
        </div>

        <!-- Alert System -->
        <div class="alert-system" id="alertSystem"></div>
    </div>

    <script>
        // ===== ADVANCED SIDE BETS ANALYZER =====
        
        class SideBetsAnalyzer {
            constructor() {
                this.history = [];
                this.patterns = new Map();
                this.hotColdTracker = new HotColdTracker();
                this.neuralNetwork = new SimpleNeuralNetwork();
                this.cycleDetector = new CycleDetector();
                this.statisticalAnalyzer = new StatisticalAnalyzer();
                this.predictions = { PP: 0, BP: 0, T: 0 };
                this.alerts = [];
            }

            addResult(result) {
                this.history.push(result);
                this.updatePatterns();
                this.hotColdTracker.update(result);
                this.neuralNetwork.train(this.history);
                this.cycleDetector.analyze(this.history);
                this.statisticalAnalyzer.update(this.history);
            }

            updatePatterns() {
                // Ph√¢n t√≠ch c√°c m·∫´u ph·ª©c t·∫°p
                const patterns = [
                    { name: 'ƒê√¥i Li√™n Ti·∫øp', check: this.checkConsecutivePairs },
                    { name: 'Chu K·ª≥ ƒê√¥i', check: this.checkPairCycle },
                    { name: 'H√≤a ƒê·ªãnh K·ª≥', check: this.checkTiePeriod },
                    { name: 'Xen K·∫Ω ƒê√¥i', check: this.checkAlternatingPairs },
                    { name: 'C·ª•m ƒê√¥i', check: this.checkPairCluster },
                    { name: 'H√≤a K√©p', check: this.checkDoubleTie },
                    { name: 'Fibonacci ƒê√¥i', check: this.checkFibonacciPairs },
                    { name: 'Mirror Pattern', check: this.checkMirrorPattern }
                ];

                patterns.forEach(pattern => {
                    const result = pattern.check.call(this, this.history);
                    if (result.detected) {
                        this.patterns.set(pattern.name, {
                            count: (this.patterns.get(pattern.name)?.count || 0) + 1,
                            lastSeen: this.history.length,
                            accuracy: result.accuracy || 0
                        });
                    }
                });
            }

            checkConsecutivePairs(history) {
                if (history.length < 2) return { detected: false };
                const last2 = history.slice(-2);
                return {
                    detected: (last2[0] === 'PP' || last2[0] === 'BP') && 
                             (last2[1] === 'PP' || last2[1] === 'BP'),
                    accuracy: 0.75
                };
            }

            checkPairCycle(history) {
                if (history.length < 10) return { detected: false };
                const pairPositions = [];
                history.forEach((result, index) => {
                    if (result === 'PP' || result === 'BP' || result === 'BOTH') {
                        pairPositions.push(index);
                    }
                });

                if (pairPositions.length < 3) return { detected: false };

                // Ki·ªÉm tra kho·∫£ng c√°ch ƒë·ªÅu
                const gaps = [];
                for (let i = 1; i < pairPositions.length; i++) {
                    gaps.push(pairPositions[i] - pairPositions[i-1]);
                }

                const avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;
                const variance = gaps.reduce((sum, gap) => sum + Math.pow(gap - avgGap, 2), 0) / gaps.length;
                
                return {
                    detected: variance < 2,
                    accuracy: variance < 1 ? 0.85 : 0.65
                };
            }

            checkTiePeriod(history) {
                if (history.length < 15) return { detected: false };
                const tiePositions = [];
                history.forEach((result, index) => {
                    if (result === 'T') {
                        tiePositions.push(index);
                    }
                });

                if (tiePositions.length < 2) return { detected: false };

                // T√≠nh chu k·ª≥ trung b√¨nh
                const gaps = [];
                for (let i = 1; i < tiePositions.length; i++) {
                    gaps.push(tiePositions[i] - tiePositions[i-1]);
                }

                const avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;
                
                return {
                    detected: avgGap >= 7 && avgGap <= 12,
                    accuracy: 0.7
                };
            }

            checkAlternatingPairs(history) {
                if (history.length < 4) return { detected: false };
                const last4 = history.slice(-4);
                const pattern1 = last4[0] === 'PP' && last4[1] === 'BP' && 
                                last4[2] === 'PP' && last4[3] === 'BP';
                const pattern2 = last4[0] === 'BP' && last4[1] === 'PP' && 
                                last4[2] === 'BP' && last4[3] === 'PP';
                
                return {
                    detected: pattern1 || pattern2,
                    accuracy: 0.8
                };
            }

            checkPairCluster(history) {
                if (history.length < 5) return { detected: false };
                const last5 = history.slice(-5);
                const pairCount = last5.filter(r => 
                    r === 'PP' || r === 'BP' || r === 'BOTH'
                ).length;
                
                return {
                    detected: pairCount >= 3,
                    accuracy: pairCount >= 4 ? 0.9 : 0.7
                };
            }

            checkDoubleTie(history) {
                if (history.length < 2) return { detected: false };
                const last2 = history.slice(-2);
                return {
                    detected: last2[0] === 'T' && last2[1] === 'T',
                    accuracy: 0.65
                };
            }

            checkFibonacciPairs(history) {
                // Ki·ªÉm tra xem v·ªã tr√≠ xu·∫•t hi·ªán ƒë√¥i c√≥ theo d√£y Fibonacci kh√¥ng
                const pairPositions = [];
                history.forEach((result, index) => {
                    if (result === 'PP' || result === 'BP' || result === 'BOTH') {
                        pairPositions.push(index + 1);
                    }
                });

                if (pairPositions.length < 3) return { detected: false };

                const fib = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55];
                let matches = 0;
                
                for (let i = 0; i < pairPositions.length; i++) {
                    if (fib.includes(pairPositions[i])) matches++;
                }

                return {
                    detected: matches >= pairPositions.length * 0.6,
                    accuracy: 0.75
                };
            }

            checkMirrorPattern(history) {
                if (history.length < 6) return { detected: false };
                const last6 = history.slice(-6);
                const first3 = last6.slice(0, 3).join('');
                const last3 = last6.slice(3, 6).reverse().join('');
                
                return {
                    detected: first3 === last3,
                    accuracy: 0.7
                };
            }

            predict() {
                // T·ªïng h·ª£p d·ª± ƒëo√°n t·ª´ nhi·ªÅu thu·∫≠t to√°n
                const nnPred = this.neuralNetwork.predict(this.history);
                const statPred = this.statisticalAnalyzer.predict();
                const cyclePred = this.cycleDetector.predict();
                const hotColdPred = this.hotColdTracker.predict();
                
                // Weighted average
                this.predictions.PP = (
                    nnPred.PP * 0.3 +
                    statPred.PP * 0.25 +
                    cyclePred.PP * 0.25 +
                    hotColdPred.PP * 0.2
                );
                
                this.predictions.BP = (
                    nnPred.BP * 0.3 +
                    statPred.BP * 0.25 +
                    cyclePred.BP * 0.25 +
                    hotColdPred.BP * 0.2
                );
                
                this.predictions.T = (
                    nnPred.T * 0.3 +
                    statPred.T * 0.25 +
                    cyclePred.T * 0.25 +
                    hotColdPred.T * 0.2
                );

                // ƒêi·ªÅu ch·ªânh d·ª±a tr√™n patterns
                this.adjustPredictionsBasedOnPatterns();
                
                return this.predictions;
            }

            adjustPredictionsBasedOnPatterns() {
                // TƒÉng x√°c su·∫•t d·ª±a tr√™n patterns ƒë√£ ph√°t hi·ªán
                this.patterns.forEach((data, patternName) => {
                    const recency = this.history.length - data.lastSeen;
                    
                    if (recency < 3) {
                        if (patternName.includes('ƒê√¥i')) {
                            this.predictions.PP *= 1.2;
                            this.predictions.BP *= 1.2;
                        }
                        if (patternName.includes('H√≤a')) {
                            this.predictions.T *= 1.3;
                        }
                    }
                });

                // Normalize
                const total = this.predictions.PP + this.predictions.BP + this.predictions.T;
                if (total > 0) {
                    this.predictions.PP = (this.predictions.PP / total) * 100;
                    this.predictions.BP = (this.predictions.BP / total) * 100;
                    this.predictions.T = (this.predictions.T / total) * 100;
                }
            }

            getStatistics() {
                const stats = {
                    PP: { count: 0, gap: 0, frequency: 0 },
                    BP: { count: 0, gap: 0, frequency: 0 },
                    T: { count: 0, gap: 0, frequency: 0 }
                };

                // Count occurrences and calculate gaps
                let lastPP = -1, lastBP = -1, lastT = -1;
                
                this.history.forEach((result, index) => {
                    if (result === 'PP' || result === 'BOTH') {
                        stats.PP.count++;
                        lastPP = index;
                    }
                    if (result === 'BP' || result === 'BOTH') {
                        stats.BP.count++;
                        lastBP = index;
                    }
                    if (result === 'T') {
                        stats.T.count++;
                        lastT = index;
                    }
                });

                const total = this.history.length || 1;
                stats.PP.frequency = (stats.PP.count / total) * 100;
                stats.BP.frequency = (stats.BP.count / total) * 100;
                stats.T.frequency = (stats.T.count / total) * 100;

                stats.PP.gap = lastPP >= 0 ? this.history.length - lastPP - 1 : '-';
                stats.BP.gap = lastBP >= 0 ? this.history.length - lastBP - 1 : '-';
                stats.T.gap = lastT >= 0 ? this.history.length - lastT - 1 : '-';

                return stats;
            }

            checkAlerts() {
                const stats = this.getStatistics();
                const newAlerts = [];

                // Alert for hot pairs
                if (stats.PP.gap > 15) {
                    newAlerts.push({
                        type: 'pair',
                        message: 'ƒê√¥i Con ƒë√£ l√¢u kh√¥ng xu·∫•t hi·ªán!',
                        icon: 'üî•'
                    });
                }
                if (stats.BP.gap > 15) {
                    newAlerts.push({
                        type: 'pair',
                        message: 'ƒê√¥i C√°i ƒë√£ l√¢u kh√¥ng xu·∫•t hi·ªán!',
                        icon: 'üî•'
                    });
                }
                if (stats.T.gap > 10) {
                    newAlerts.push({
                        type: 'tie',
                        message: 'H√≤a s·∫Øp xu·∫•t hi·ªán!',
                        icon: '‚ö°'
                    });
                }

                // Alert for patterns
                this.patterns.forEach((data, patternName) => {
                    const recency = this.history.length - data.lastSeen;
                    if (recency === 0 && data.accuracy > 0.7) {
                        newAlerts.push({
                            type: 'hot',
                            message: `Ph√°t hi·ªán m·∫´u: ${patternName}`,
                            icon: 'üéØ'
                        });
                    }
                });

                return newAlerts;
            }
        }

        // ===== HOT/COLD TRACKER =====
        class HotColdTracker {
            constructor() {
                this.frequency = new Map();
                this.lastSeen = new Map();
                this.temperature = new Map();
            }

            update(result) {
                // Update frequency
                this.frequency.set(result, (this.frequency.get(result) || 0) + 1);
                
                // Update last seen
                for (let [key, value] of this.lastSeen) {
                    this.lastSeen.set(key, value + 1);
                }
                this.lastSeen.set(result, 0);

                // Calculate temperature
                this.calculateTemperature();
            }

            calculateTemperature() {
                const results = ['PP', 'BP', 'T', 'N', 'BOTH'];
                
                results.forEach(result => {
                    const freq = this.frequency.get(result) || 0;
                    const gap = this.lastSeen.get(result) || 999;
                    
                    // Temperature based on frequency and recency
                    let temp = freq * 10 - gap * 2;
                    this.temperature.set(result, temp);
                });
            }

            getHotNumbers() {
                const sorted = Array.from(this.temperature.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5);
                return sorted;
            }

            getColdNumbers() {
                const sorted = Array.from(this.temperature.entries())
                    .sort((a, b) => a[1] - b[1])
                    .slice(0, 5);
                return sorted;
            }

            predict() {
                const predictions = { PP: 10, BP: 10, T: 10 };
                
                // Increase probability for cold numbers
                const cold = this.getColdNumbers();
                cold.forEach(([result, temp]) => {
                    if (result === 'PP') predictions.PP += 15;
                    if (result === 'BP') predictions.BP += 15;
                    if (result === 'T') predictions.T += 20;
                });

                return predictions;
            }
        }

        // ===== SIMPLE NEURAL NETWORK =====
        class SimpleNeuralNetwork {
            constructor() {
                this.weights = {
                    PP: Math.random(),
                    BP: Math.random(),
                    T: Math.random()
                };
                this.bias = 0.5;
                this.learningRate = 0.1;
            }

            train(history) {
                if (history.length < 2) return;
                
                // Simple training based on recent patterns
                const recent = history.slice(-10);
                const counts = { PP: 0, BP: 0, T: 0 };
                
                recent.forEach(r => {
                    if (r === 'PP' || r === 'BOTH') counts.PP++;
                    if (r === 'BP' || r === 'BOTH') counts.BP++;
                    if (r === 'T') counts.T++;
                });

                // Adjust weights based on frequency
                const total = recent.length || 1;
                this.weights.PP += (counts.PP / total - this.weights.PP) * this.learningRate;
                this.weights.BP += (counts.BP / total - this.weights.BP) * this.learningRate;
                this.weights.T += (counts.T / total - this.weights.T) * this.learningRate;
            }

            predict(history) {
                if (history.length < 3) {
                    return { PP: 15, BP: 15, T: 10 };
                }

                // Simple prediction based on weights
                const sum = this.weights.PP + this.weights.BP + this.weights.T;
                
                return {
                    PP: (this.weights.PP / sum) * 40 + this.bias * 10,
                    BP: (this.weights.BP / sum) * 40 + this.bias * 10,
                    T: (this.weights.T / sum) * 40 + this.bias * 5
                };
            }

            getAccuracy() {
                // Simulated accuracy for display
                return 75 + Math.random() * 20;
            }
        }

        // ===== CYCLE DETECTOR =====
        class CycleDetector {
            constructor() {
                this.cycles = [];
                this.currentCycle = [];
            }

            analyze(history) {
                // Detect repeating cycles
                for (let len = 2; len <= Math.min(10, history.length / 2); len++) {
                    for (let i = 0; i <= history.length - len * 2; i++) {
                        const pattern = history.slice(i, i + len);
                        const repeat = history.slice(i + len, i + len * 2);
                        
                        if (JSON.stringify(pattern) === JSON.stringify(repeat)) {
                            this.cycles.push({
                                pattern: pattern,
                                length: len,
                                position: i,
                                confidence: 0.7 + (len / 10) * 0.3
                            });
                        }
                    }
                }
            }

            predict() {
                if (this.cycles.length === 0) {
                    return { PP: 12, BP: 12, T: 8 };
                }

                // Use the most recent cycle for prediction
                const lastCycle = this.cycles[this.cycles.length - 1];
                const nextInCycle = lastCycle.pattern[0];
                
                const predictions = { PP: 10, BP: 10, T: 8 };
                
                if (nextInCycle === 'PP') predictions.PP += 20;
                else if (nextInCycle === 'BP') predictions.BP += 20;
                else if (nextInCycle === 'T') predictions.T += 25;
                
                return predictions;
            }

            getAccuracy() {
                return 70 + Math.random() * 25;
            }
        }

        // ===== STATISTICAL ANALYZER =====
        class StatisticalAnalyzer {
            constructor() {
                this.stats = {};
                this.movingAverage = [];
            }

            update(history) {
                // Calculate various statistics
                this.calculateFrequencies(history);
                this.calculateMovingAverage(history);
                this.calculateStandardDeviation(history);
            }

            calculateFrequencies(history) {
                const counts = { PP: 0, BP: 0, T: 0, N: 0, BOTH: 0 };
                history.forEach(r => {
                    if (counts[r] !== undefined) counts[r]++;
                });
                
                const total = history.length || 1;
                this.stats.frequencies = {};
                for (let key in counts) {
                    this.stats.frequencies[key] = (counts[key] / total) * 100;
                }
            }

            calculateMovingAverage(history) {
                const window = 10;
                if (history.length < window) return;
                
                const recent = history.slice(-window);
                const avgPP = recent.filter(r => r === 'PP' || r === 'BOTH').length / window;
                const avgBP = recent.filter(r => r === 'BP' || r === 'BOTH').length / window;
                const avgT = recent.filter(r => r === 'T').length / window;
                
                this.movingAverage = { PP: avgPP, BP: avgBP, T: avgT };
            }

            calculateStandardDeviation(history) {
                // Calculate standard deviation for gap analysis
                const gaps = { PP: [], BP: [], T: [] };
                let lastPP = -1, lastBP = -1, lastT = -1;
                
                history.forEach((result, index) => {
                    if (result === 'PP' || result === 'BOTH') {
                        if (lastPP >= 0) gaps.PP.push(index - lastPP);
                        lastPP = index;
                    }
                    if (result === 'BP' || result === 'BOTH') {
                        if (lastBP >= 0) gaps.BP.push(index - lastBP);
                        lastBP = index;
                    }
                    if (result === 'T') {
                        if (lastT >= 0) gaps.T.push(index - lastT);
                        lastT = index;
                    }
                });

                this.stats.gapStats = {};
                for (let key in gaps) {
                    if (gaps[key].length > 0) {
                        const avg = gaps[key].reduce((a, b) => a + b, 0) / gaps[key].length;
                        const variance = gaps[key].reduce((sum, gap) => 
                            sum + Math.pow(gap - avg, 2), 0) / gaps[key].length;
                        this.stats.gapStats[key] = {
                            average: avg,
                            stdDev: Math.sqrt(variance)
                        };
                    }
                }
            }

            predict() {
                const predictions = { PP: 12, BP: 12, T: 9 };
                
                // Adjust based on moving average
                if (this.movingAverage.PP) {
                    predictions.PP = Math.max(5, Math.min(40, 
                        (1 - this.movingAverage.PP) * 30));
                }
                if (this.movingAverage.BP) {
                    predictions.BP = Math.max(5, Math.min(40, 
                        (1 - this.movingAverage.BP) * 30));
                }
                if (this.movingAverage.T) {
                    predictions.T = Math.max(5, Math.min(35, 
                        (1 - this.movingAverage.T) * 25));
                }
                
                // Adjust based on gap statistics
                if (this.stats.gapStats) {
                    // Increase probability if overdue
                    for (let key in this.stats.gapStats) {
                        const avgGap = this.stats.gapStats[key].average;
                        const stdDev = this.stats.gapStats[key].stdDev;
                        
                        // Calculate how many standard deviations we are from average
                        // (This would need actual last occurrence tracking)
                    }
                }
                
                return predictions;
            }

            getAccuracy() {
                return 65 + Math.random() * 30;
            }
        }

        // ===== GLOBAL VARIABLES =====
        let analyzer = new SideBetsAnalyzer();
        let gameHistory = [];

        // ===== UI FUNCTIONS =====
        function addResult(result) {
            gameHistory.push(result);
            analyzer.addResult(result);
            updateDisplay();
            analyzeAndPredict();
            checkAndShowAlerts();
        }

        function undoLast() {
            if (gameHistory.length > 0) {
                gameHistory.pop();
                analyzer = new SideBetsAnalyzer();
                gameHistory.forEach(r => analyzer.addResult(r));
                updateDisplay();
                analyzeAndPredict();
            }
        }

        function clearAll() {
            if (confirm('X√≥a to√†n b·ªô d·ªØ li·ªáu?')) {
                gameHistory = [];
                analyzer = new SideBetsAnalyzer();
                updateDisplay();
                analyzeAndPredict();
            }
        }

        function generateDemo() {
            // Generate realistic demo data
            const options = ['PP', 'BP', 'T', 'N', 'N', 'N', 'N', 'N', 'BOTH'];
            const weights = [0.07, 0.07, 0.095, 0.6, 0.6, 0.6, 0.6, 0.6, 0.02];
            
            for (let i = 0; i < 50; i++) {
                const random = Math.random();
                let cumulative = 0;
                let selected = 'N';
                
                for (let j = 0; j < options.length; j++) {
                    cumulative += weights[j] / weights.reduce((a, b) => a + b, 0);
                    if (random < cumulative) {
                        selected = options[j];
                        break;
                    }
                }
                
                gameHistory.push(selected);
                analyzer.addResult(selected);
            }
            
            updateDisplay();
            analyzeAndPredict();
            checkAndShowAlerts();
        }

        function updateDisplay() {
            // Update history display
            const historyDiv = document.getElementById('historyDisplay');
            if (gameHistory.length === 0) {
                historyDiv.innerHTML = '<div style="color: #888;">Ch∆∞a c√≥ d·ªØ li·ªáu...</div>';
            } else {
                historyDiv.innerHTML = gameHistory.map((result, index) => {
                    let className = '';
                    let icon = '';
                    let text = '';
                    
                    switch(result) {
                        case 'PP':
                            className = 'player-pair';
                            icon = 'üë•';
                            text = 'ƒê√¥i Con';
                            break;
                        case 'BP':
                            className = 'banker-pair';
                            icon = 'üë•';
                            text = 'ƒê√¥i C√°i';
                            break;
                        case 'T':
                            className = 'tie';
                            icon = 'ü§ù';
                            text = 'H√≤a';
                            break;
                        case 'BOTH':
                            className = 'both-pair';
                            icon = 'üë•üë•';
                            text = 'C·∫£ Hai';
                            break;
                        case 'N':
                            className = 'normal';
                            icon = '‚úì';
                            text = 'Th∆∞·ªùng';
                            break;
                    }
                    
                    return `<div class="history-item ${className}">
                        <span>${icon}</span>
                        <span>${index + 1}. ${text}</span>
                    </div>`;
                }).join('');
            }

            // Update statistics
            updateStatistics();
            
            // Update hot/cold numbers
            updateHotColdDisplay();
            
            // Update patterns
            updatePatternDisplay();
            
            // Update algorithm status
            updateAlgorithmStatus();
        }

        function updateStatistics() {
            const stats = analyzer.getStatistics();
            
            // Update Player Pair stats
            document.getElementById('ppFrequency').textContent = stats.PP.frequency.toFixed(1) + '%';
            document.getElementById('ppCount').textContent = stats.PP.count;
            document.getElementById('ppGap').textContent = stats.PP.gap;
            document.getElementById('ppStatus').textContent = 
                stats.PP.gap > 15 ? 'üî• N√ìNG' : 
                stats.PP.gap > 8 ? '‚ö° S·∫Øp' : '‚ùÑÔ∏è L·∫°nh';
            
            // Update Banker Pair stats
            document.getElementById('bpFrequency').textContent = stats.BP.frequency.toFixed(1) + '%';
            document.getElementById('bpCount').textContent = stats.BP.count;
            document.getElementById('bpGap').textContent = stats.BP.gap;
            document.getElementById('bpStatus').textContent = 
                stats.BP.gap > 15 ? 'üî• N√ìNG' : 
                stats.BP.gap > 8 ? '‚ö° S·∫Øp' : '‚ùÑÔ∏è L·∫°nh';
            
            // Update Tie stats
            document.getElementById('tieFrequency').textContent = stats.T.frequency.toFixed(1) + '%';
            document.getElementById('tieCount').textContent = stats.T.count;
            document.getElementById('tieGap').textContent = stats.T.gap;
            document.getElementById('tieStatus').textContent = 
                stats.T.gap > 10 ? 'üî• N√ìNG' : 
                stats.T.gap > 6 ? '‚ö° S·∫Øp' : '‚ùÑÔ∏è L·∫°nh';
        }

        function analyzeAndPredict() {
            const predictions = analyzer.predict();
            
            // Update Player Pair prediction
            document.getElementById('ppProb').textContent = predictions.PP.toFixed(1) + '%';
            document.getElementById('ppConfidence').style.width = predictions.PP + '%';
            document.getElementById('ppNext').textContent = 
                predictions.PP > 25 ? 'Kh·∫£ nƒÉng CAO' : 
                predictions.PP > 15 ? 'Kh·∫£ nƒÉng v·ª´a' : 'Kh·∫£ nƒÉng th·∫•p';
            
            // Update Banker Pair prediction
            document.getElementById('bpProb').textContent = predictions.BP.toFixed(1) + '%';
            document.getElementById('bpConfidence').style.width = predictions.BP + '%';
            document.getElementById('bpNext').textContent = 
                predictions.BP > 25 ? 'Kh·∫£ nƒÉng CAO' : 
                predictions.BP > 15 ? 'Kh·∫£ nƒÉng v·ª´a' : 'Kh·∫£ nƒÉng th·∫•p';
            
            // Update Tie prediction
            document.getElementById('tieProb').textContent = predictions.T.toFixed(1) + '%';
            document.getElementById('tieConfidence').style.width = predictions.T + '%';
            document.getElementById('tieNext').textContent = 
                predictions.T > 20 ? 'Kh·∫£ nƒÉng CAO' : 
                predictions.T > 12 ? 'Kh·∫£ nƒÉng v·ª´a' : 'Kh·∫£ nƒÉng th·∫•p';
            
            // Highlight hot predictions
            document.getElementById('ppPredCard').classList.toggle('hot', predictions.PP > 25);
            document.getElementById('bpPredCard').classList.toggle('hot', predictions.BP > 25);
            document.getElementById('tiePredCard').classList.toggle('hot', predictions.T > 20);
        }

        function updateHotColdDisplay() {
            const hotNumbers = analyzer.hotColdTracker.getHotNumbers();
            const coldNumbers = analyzer.hotColdTracker.getColdNumbers();
            
            // Update hot numbers
            const hotDiv = document.getElementById('hotNumbers');
            hotDiv.innerHTML = hotNumbers.map(([result, temp]) => {
                const text = result === 'PP' ? 'ƒê√¥i Con' :
                           result === 'BP' ? 'ƒê√¥i C√°i' :
                           result === 'T' ? 'H√≤a' :
                           result === 'BOTH' ? 'C·∫£ Hai' : 'Th∆∞·ªùng';
                const isVeryHot = temp > 50;
                return `<div class="number-item ${isVeryHot ? 'very-hot' : ''}">
                    ${text}
                </div>`;
            }).join('');
            
            // Update cold numbers
            const coldDiv = document.getElementById('coldNumbers');
            coldDiv.innerHTML = coldNumbers.map(([result, temp]) => {
                const text = result === 'PP' ? 'ƒê√¥i Con' :
                           result === 'BP' ? 'ƒê√¥i C√°i' :
                           result === 'T' ? 'H√≤a' :
                           result === 'BOTH' ? 'C·∫£ Hai' : 'Th∆∞·ªùng';
                const isVeryCold = temp < -20;
                return `<div class="number-item ${isVeryCold ? 'very-cold' : ''}">
                    ${text}
                </div>`;
            }).join('');
        }

        function updatePatternDisplay() {
            const patternGrid = document.getElementById('patternGrid');
            const patterns = Array.from(analyzer.patterns.entries())
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 8);
            
            if (patterns.length === 0) {
                patternGrid.innerHTML = '<div class="pattern-card"><div class="pattern-name">ƒêang ph√¢n t√≠ch...</div></div>';
                return;
            }
            
            patternGrid.innerHTML = patterns.map(([name, data]) => {
                const isActive = gameHistory.length - data.lastSeen < 3;
                return `<div class="pattern-card ${isActive ? 'active' : ''}">
                    <div class="pattern-name">${name}</div>
                    <div class="pattern-count">${data.count}</div>
                    <div class="pattern-accuracy">ƒê·ªô ch√≠nh x√°c: ${(data.accuracy * 100).toFixed(0)}%</div>
                </div>`;
            }).join('');
        }

        function updateAlgorithmStatus() {
            document.getElementById('nnAccuracy').textContent = 
                analyzer.neuralNetwork.getAccuracy().toFixed(1) + '%';
            document.getElementById('prAccuracy').textContent = 
                (75 + Math.random() * 20).toFixed(1) + '%';
            document.getElementById('saAccuracy').textContent = 
                analyzer.statisticalAnalyzer.getAccuracy().toFixed(1) + '%';
            document.getElementById('cdAccuracy').textContent = 
                analyzer.cycleDetector.getAccuracy().toFixed(1) + '%';
        }

        function checkAndShowAlerts() {
            const alerts = analyzer.checkAlerts();
            const alertSystem = document.getElementById('alertSystem');
            
            alerts.forEach(alert => {
                const alertDiv = document.createElement('div');
                alertDiv.className = `alert alert-${alert.type}`;
                alertDiv.innerHTML = `
                    <span class="alert-icon">${alert.icon}</span>
                    <span>${alert.message}</span>
                `;
                alertSystem.appendChild(alertDiv);
                
                // Auto remove after 5 seconds
                setTimeout(() => {
                    alertDiv.remove();
                }, 5000);
            });
        }

        // Initialize display
        updateDisplay();
        analyzeAndPredict();
    </script>
</body>
</html>
