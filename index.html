<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>H·ªá Th·ªëng Ph√¢n T√≠ch C·∫ßu (N√¢ng C·∫•p)</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<style>
body {
font-family: 'Inter', sans-serif;
background-color: #111827; /* Tailwind gray-900 */
color: #F9FAFB; /* Tailwind gray-50 */
}
.btn {
transition: all 0.3s ease;
box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
}
.btn:hover {
transform: translateY(-2px);
box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
}
.btn:active {
transform: translateY(1px);
}
.btn:disabled {
opacity: 0.5;
cursor: not-allowed;
}
.card-glow-p { box-shadow: 0 0 20px rgba(59, 130, 246, 0.5); }
.card-glow-b { box-shadow: 0 0 20px rgba(239, 68, 68, 0.5); }
.card-glow-certain { box-shadow: 0 0 25px rgba(250, 204, 21, 0.7); }
#bigRoadDisplay {
display: grid;
grid-auto-flow: column;
grid-auto-columns: 2.5rem; /* 40px */
gap: 2px;
overflow-x: auto;
padding: 8px;
scrollbar-width: thin;
scrollbar-color: #4B5563 #1F2937;
}
.road-col {
display: grid;
grid-auto-rows: 2.5rem; /* 40px */
gap: 2px;
}
.road-item {
width: 2.5rem; height: 2.5rem; border-radius: 9999px;
display: flex; align-items: center; justify-content: center;
font-weight: bold; font-size: 1.125rem; color: white;
animation: fadeIn 0.5s ease;
}
@keyframes fadeIn {
from { opacity: 0; transform: scale(0.8); }
to { opacity: 1; transform: scale(1); }
}
/* Modal and Toast styles */
.modal-backdrop {
position: fixed; top: 0; left: 0; right: 0; bottom: 0;
background-color: rgba(0,0,0,0.7);
display: flex; align-items: center; justify-content: center;
z-index: 50; animation: fadeIn 0.3s ease;
}
.modal-content {
background-color: #1f2937; /* gray-800 */
padding: 1.5rem; border-radius: 1rem;
width: 90%; max-width: 400px;
animation: slideIn 0.3s ease-out;
border: 1px solid #374151; /* gray-700 */
}
.toast-notification {
position: fixed; top: 20px; right: 20px;
background-color: #1f2937; color: white;
padding: 1rem 1.5rem; border-radius: 0.5rem;
box-shadow: 0 10px 15px -3px rgba(0,0,0,0.3);
z-index: 100; animation: slideDown 0.5s ease;
border-left: 4px solid;
}
@keyframes slideIn {
from { opacity: 0; transform: translateY(-20px) scale(0.95); }
to { opacity: 1; transform: translateY(0) scale(1); }
}
@keyframes slideDown {
from { opacity: 0; transform: translateY(-100%); }
to { opacity: 1; transform: translateY(0); }
}
@keyframes fadeOut {
from { opacity: 1; transform: translateY(0); }
to { opacity: 0; transform: translateY(-20px); }
}
#sessionManagementContent {
transition: max-height 0.5s ease-in-out;
overflow: hidden;
}
/* Style cho bi·ªÉu ƒë·ªì c·ªôt m·ªõi */
#chotHistoryChart {
display: flex;
align-items: flex-end; /* CƒÉn c·ªôt t·ª´ d∆∞·ªõi l√™n */
justify-content: center; /* CƒÉn gi·ªØa c√°c c·ªôt */
gap: 1px; /* Kho·∫£ng c√°ch nh·ªè gi·ªØa c√°c c·ªôt */
height: 40px; /* Chi·ªÅu cao c·ªë ƒë·ªãnh cho khu v·ª±c bi·ªÉu ƒë·ªì */
padding: 5px 0; /* Padding tr√™n d∆∞·ªõi */
overflow: hidden; /* ·∫®n n·∫øu qu√° nhi·ªÅu c·ªôt */
}
.chot-bar {
flex-shrink: 0; /* NgƒÉn c·ªôt b·ªã co l·∫°i */
width: 3px; /* ƒê·ªô r·ªông m·ªói c·ªôt */
border-radius: 1px; /* Bo g√≥c nh·∫π */
}
.chot-bar-correct {
background-color: #3b82f6; /* Blue-500 */
height: 100%; /* C·ªôt d√†i */
}
.chot-bar-incorrect {
background-color: #ef4444; /* Red-500 */
height: 40%; /* C·ªôt ng·∫Øn */
}
</style>
</head>
<body class="p-4 md:p-8">
<div id="modal-container"></div>
<div id="toast-container"></div>
<div class="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-3 gap-6">
<!-- Left Column: Input & History -->
<div class="lg:col-span-2 space-y-6">
<!-- Header -->
<div class="bg-gray-800 p-6 rounded-2xl shadow-lg text-center">
<h1 class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-red-400">H·ªá Th·ªëng Ph√¢n T√≠ch C·∫ßu</h1>
<p class="text-gray-400 mt-2">Ghi nh·ªõ - ƒê·ªëi chi·∫øu - Ph√°n ƒëo√°n</p>
</div>
<!-- Session Management -->
<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
<div class="flex justify-between items-center cursor-pointer" onclick="toggleSessionManagement()">
<h2 class="text-xl font-semibold text-blue-300">üìÅ Qu·∫£n L√Ω Phi√™n</h2>
<button id="toggleSessionBtn" class="text-gray-400 hover:text-white p-1">
<svg id="toggleSessionIcon" class="w-6 h-6 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
</button>
</div>
<div id="sessionManagementContent">
<div class="mt-4">
<div class="flex flex-col sm:flex-row gap-4 mb-2">
<select id="sessionSelector" multiple size="5" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"></select>
<div class="grid grid-cols-2 gap-4">
<button onclick="createNewSession()" class="btn w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-4 rounded-lg">‚ûï M·ªõi</button>
<button onclick="renameSession()" class="btn w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-4 rounded-lg">‚úèÔ∏è ƒê·ªïi T√™n</button>
<button onclick="deleteSelectedSessions()" class="btn w-full bg-red-600 hover:bg-red-500 text-white font-bold py-3 px-4 rounded-lg col-span-2">üóëÔ∏è X√≥a M·ª•c ƒê√£ Ch·ªçn</button>
<button onclick="deleteAllSessions()" class="btn w-full bg-red-800 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg col-span-2">üí• X√≥a T·∫•t C·∫£</button>
</div>
</div>
<p class="text-xs text-gray-500 text-center mb-4 sm:text-left">M·∫πo: Gi·ªØ ph√≠m Shift ho·∫∑c Ctrl (Cmd tr√™n Mac) ƒë·ªÉ ch·ªçn nhi·ªÅu phi√™n.</p>
<!-- Import/Export -->
<div class="flex flex-col sm:flex-row gap-4">
<button onclick="exportData()" class="btn w-full bg-sky-600 hover:bg-sky-500 text-white font-bold py-3 px-4 rounded-lg">üì§ Xu·∫•t D·ªØ Li·ªáu</button>
<button onclick="document.getElementById('fileInput').click()" class="btn w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-4 rounded-lg">üì• Nh·∫≠p D·ªØ Li·ªáu</button>
<input type="file" id="fileInput" class="hidden" accept=".json" onchange="importData(event)">
</div>
</div>
</div>
</div>
<!-- CH·ªêT ANALYSIS PANEL -->
<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
<h2 class="text-xl font-semibold mb-4 text-purple-300">üîê Ch·ªët Ph√°n Quy·∫øt</h2>
<div id="finalChotResult" class="text-center bg-gray-900 py-4 rounded-lg border-2 border-purple-500 mb-4 transition-all duration-300">
<p class="text-sm text-gray-400 mb-1">ƒê·ªÅ xu·∫•t "CH·ªêT" v√°n ti·∫øp theo:</p>
<p class="text-2xl font-extrabold text-gray-400">... Ch·ªù t√≠n hi·ªáu ...</p>
</div>
<!-- S·ª≠a ƒë·ªïi: Hi·ªÉn th·ªã k·∫øt qu·∫£ ph√¢n t√≠ch chi ti·∫øt cho Ch·ªët -->
<div id="chotAnalysisDetails" class="space-y-1">
<!-- Rows will be generated by JS -->
<p class="text-gray-500 text-center py-4">ƒêang t·∫£i d·ªØ li·ªáu ph√¢n t√≠ch Ch·ªët...</p>
</div>
<!-- Bi·ªÉu ƒë·ªì l·ªãch s·ª≠ Ch·ªët -->
<div id="chotHistoryChartContainer" class="bg-gray-900 rounded-lg p-3 mt-4">
<div class="flex justify-between items-center mb-2 px-1">
<span class="text-xs font-medium text-gray-400">L·ªãch s·ª≠ ƒê√∫ng/Sai c·ªßa Ch·ªët (T·ªëi ƒëa 50 v√°n g·∫ßn nh·∫•t):</span>
<span id="chotAccuracyStats" class="text-xs font-semibold text-gray-300">ƒê√∫ng: 0/0 (0.0%)</span>
</div>
<div id="chotHistoryChart">
<!-- Bi·ªÉu ƒë·ªì c·ªôt s·∫Ω ƒë∆∞·ª£c t·∫°o b·ªüi JS -->
<p class="text-gray-600 text-xs text-center w-full">Ch∆∞a c√≥ d·ªØ li·ªáu l·ªãch s·ª≠ Ch·ªët...</p>
</div>
</div>
</div>
<!-- Input Section -->
<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
<h2 class="text-xl font-semibold mb-4 text-blue-300">üé≤ Nh·∫≠p K·∫øt Qu·∫£ V√°n Hi·ªán T·∫°i</h2>
<div class="grid grid-cols-2 gap-4 mb-4">
<button onclick="addResult('P')" class="btn bg-blue-600 hover:bg-blue-500 text-white font-bold py-6 rounded-lg text-2xl"><span>üë§</span> PLAYER</button>
<button onclick="addResult('B')" class="btn bg-red-600 hover:bg-red-500 text-white font-bold py-6 rounded-lg text-2xl"><span>üè¶</span> BANKER</button>
</div>
<div class="flex gap-4">
<button onclick="undoLast()" class="btn flex-1 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg">‚Ü©Ô∏è Ho√†n T√°c</button>
<button onclick="showCustomConfirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô l·ªãch s·ª≠ v√† th·ªëng k√™ c·ªßa phi√™n n√†y kh√¥ng?', clearCurrentSessionHistory)" class="btn flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg">üóëÔ∏è X√≥a L·ªãch S·ª≠</button>
</div>
</div>

<!-- *** V·ªä TR√ç M·ªöI *** History Display (Big Road) -->
<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
<div class="flex justify-between items-center mb-4">
<h2 class="text-xl font-semibold text-blue-300">üìú B·∫£ng C·∫ßu Big Road</h2>
<span class="text-gray-400 font-medium">T·ªïng: <span id="totalGames">0</span> v√°n</span>
</div>
<div class="bg-gray-900 rounded-lg min-h-[280px] border border-gray-700">
<div id="bigRoadDisplay">
<p class="text-gray-500 p-4">Ch∆∞a c√≥ k·∫øt qu·∫£...</p>
</div>
</div>
</div>

<!-- Verdict Stats Table -->
<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
<h2 class="text-xl font-semibold mb-2 text-indigo-300">‚öñÔ∏è Th·ªëng K√™ Ph√°n Quy·∫øt (Phi√™n)</h2>
<div class="mt-4 space-y-2" id="verdictStatsTable">
<!-- Rows will be generated by JS -->
</div>
</div>
<!-- Confidence Stats Table -->
<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
<h2 class="text-xl font-semibold mb-2 text-green-300">üìä Th·ªëng K√™ ƒê·ªô Tin C·∫≠y (Phi√™n)</h2>
<div id="confidenceRecommendation" class="my-4 p-3 bg-gray-900 rounded-lg text-center"></div>
<div class="space-y-2" id="confidenceStatsTable"></div>
</div>
</div>
<!-- Right Column: Analysis & Stats -->
<div class="space-y-6">
<!-- Accuracy Stats -->
<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
<h2 class="text-xl font-semibold mb-4 text-green-300">üéØ Th·ªëng K√™ (Phi√™n Hi·ªán T·∫°i)</h2>
<div class="space-y-4">
<div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
<span class="font-medium text-gray-300">T·ª∑ L·ªá Th·∫Øng</span>
<span id="accuracyRate" class="text-2xl font-bold text-green-400">0.0%</span>
</div>
<div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
<span class="font-medium text-gray-300">Th·∫Øng / T·ªïng Ph√°n ƒêo√°n</span>
<div><span id="correctPredictions" class="text-lg font-semibold text-white">0</span><span class="text-gray-400">/</span><span id="totalPredictions" class="text-lg font-semibold text-white">0</span></div>
</div>
</div>
</div>
<!-- Global Accuracy Stats -->
<div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
<h2 class="text-xl font-semibold mb-4 text-cyan-300">üåê Th·ªëng K√™ (To√†n C·ª•c)</h2>
<div class="space-y-4">
<div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
<span class="font-medium text-gray-300">T·ª∑ L·ªá Th·∫Øng</span>
<span id="globalAccuracyRate" class="text-2xl font-bold text-cyan-400">0.0%</span>
</div>
<div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
<span class="font-medium text-gray-300">Th·∫Øng / T·ªïng Ph√°n ƒêo√°n</span>
<div><span id="globalCorrectPredictions" class="text-lg font-semibold text-white">0</span><span class="text-gray-400">/</span><span id="globalTotalPredictions" class="text-lg font-semibold text-white">0</span></div>
</div>
</div>
</div>
<!-- Pattern Analysis -->
<div id="analysis-card" class="bg-gray-800 p-6 rounded-2xl shadow-lg transition-shadow duration-500">
<h2 class="text-xl font-semibold mb-4 text-yellow-300">üß† Ph√°n Quy·∫øt (Ph√¢n T√≠ch T·ªïng H·ª£p)</h2>
<div id="analysisResult" class="space-y-4">
<p class="text-gray-400 text-center py-8">C·∫ßn √≠t nh·∫•t 10 k·∫øt qu·∫£ ƒë·ªÉ b·∫Øt ƒë·∫ßu ph√¢n t√≠ch...</p>
</div>
</div>
</div>
</div>
<script>
// --- CORE LOGIC: PATTERN MATCHER (Standard) ---
class PatternMatcher {
constructor() {
this.MIN_HISTORY_FOR_ANALYSIS = 10;
this.MIN_PATTERN_LENGTH = 10;
this.MAX_PATTERN_LENGTH = 20; // <<< ƒê√É N√ÇNG C·∫§P T·ª™ 15 L√äN 20
this.MIN_CERTAIN_OCCURRENCES = 5;
}
calculateSimilarity(arr1, arr2) {
if (arr1.length !== arr2.length || arr1.length === 0) return 0;
const matches = arr1.filter((item, index) => item === arr2[index]).length;
return matches / arr1.length;
}
findPatternOccurrences(pattern, allHistory) {
const occurrences = [];
const reversedPattern = [...pattern].reverse();
for (const session of allHistory) {
const sessionHistory = session.history || [];
if (sessionHistory.length < pattern.length + 1) continue;
for (let i = 0; i <= sessionHistory.length - pattern.length - 1; i++) {
const segment = sessionHistory.slice(i, i + pattern.length);
const nextResult = sessionHistory[i + pattern.length];
const similarity = this.calculateSimilarity(pattern, segment);
if (similarity >= 0.9) occurrences.push({ type: 'similar', next: nextResult, similarity });
const reverseSimilarity = this.calculateSimilarity(reversedPattern, segment);
if (reverseSimilarity >= 0.9) occurrences.push({ type: 'reversed', next: nextResult, similarity: reverseSimilarity });
}
}
return occurrences;
}
getPredictionForPattern(pattern, allHistoricalSessions) {
const occurrences = this.findPatternOccurrences(pattern, allHistoricalSessions);
if (occurrences.length === 0) return { prediction: null };
const votes = { P: 0, B: 0 };
occurrences.forEach(match => { if (votes[match.next] !== undefined) votes[match.next] += match.similarity; });
const totalVotes = votes.P + votes.B;
if (totalVotes === 0) return { prediction: null };
const predictedWinner = votes.P > votes.B ? 'P' : 'B';
const confidence = (Math.max(votes.P, votes.B) / totalVotes) * 100;
return { prediction: predictedWinner, confidence, votes, totalOccurrences: occurrences.length };
}
findCertainPrediction(currentHistory, allHistoricalSessions) {
for (let len = Math.min(this.MAX_PATTERN_LENGTH, currentHistory.length); len >= this.MIN_PATTERN_LENGTH; len--) {
const pattern = currentHistory.slice(-len);
const patternString = pattern.join('');
const occurrences = [];
for (const session of allHistoricalSessions) {
const sessionHistory = session.history || [];
if (sessionHistory.length < pattern.length + 1) continue;
for (let i = 0; i <= sessionHistory.length - pattern.length - 1; i++) {
const segment = sessionHistory.slice(i, i + pattern.length);
if (segment.join('') === patternString) {
occurrences.push(sessionHistory[i + pattern.length]);
}
}
}
if (occurrences.length >= this.MIN_CERTAIN_OCCURRENCES && new Set(occurrences).size === 1) {
return {
prediction: occurrences[0],
recommendation: 'TAY CH·∫ÆC CH·∫ÆN',
analysisText: `T√¨m th·∫•y ${occurrences.length} l·∫ßn xu·∫•t hi·ªán ch√≠nh x√°c c·ªßa h√¨nh c·∫ßu n√†y trong l·ªãch s·ª≠.\nT·∫•t c·∫£ ƒë·ªÅu cho k·∫øt qu·∫£ ti·∫øp theo l√†: ${occurrences[0]}`,
confidence: 100,
isCertain: true
};
}
}
return null;
}
analyzeCurrentStreak(currentHistory) {
if (currentHistory.length < 2) return { type: 'none', length: currentHistory.length };
const last = currentHistory[currentHistory.length - 1];
if (last === currentHistory[currentHistory.length - 2]) {
let length = 0;
for (let i = currentHistory.length - 1; i >= 0; i--) {
if (currentHistory[i] === last) length++; else break;
}
return { type: 'b·ªát', length, value: last };
} else {
let length = 0;
for (let i = currentHistory.length - 1; i >= 1; i--) {
if (currentHistory[i] !== currentHistory[i-1]) length++; else break;
}
return { type: '1-1', length: length + 1 };
}
}
getPrediction(currentHistory, allHistoricalSessions, { optimalLength = null, lengthPerformance = {} } = {}) {
if (currentHistory.length < this.MIN_HISTORY_FOR_ANALYSIS) {
return { prediction: null, analysisText: `C·∫ßn √≠t nh·∫•t ${this.MIN_HISTORY_FOR_ANALYSIS} k·∫øt qu·∫£...`, confidence: 0, isCertain: false };
}
if (optimalLength && currentHistory.length >= optimalLength) {
const pattern = currentHistory.slice(-optimalLength);
const result = this.getPredictionForPattern(pattern, allHistoricalSessions);
if (result.prediction) {
const perf = lengthPerformance[optimalLength] || { wins: 0, total: 0 };
if (perf.wins > perf.total) {
perf.wins = perf.total;
}
const rate = perf.total > 0 ? (perf.wins / perf.total * 100).toFixed(1) : 'N/A';
return {
prediction: result.prediction, recommendation: 'THEO CHI·ªÄU D√ÄI T·ªêI ∆ØU',
analysisText: `S·ª≠ d·ª•ng chi·ªÅu d√†i c·∫ßu t·ªëi ∆∞u: ${optimalLength} v√°n.\n(T·ª∑ l·ªá th·∫Øng c·ªßa chi·ªÅu d√†i n√†y: ${rate}% - ${perf.wins}/${perf.total})\n\L·ªãch s·ª≠ cho th·∫•y:\n- PLAYER: ${result.votes.P.toFixed(1)} ƒëi·ªÉm\n- BANKER: ${result.votes.B.toFixed(1)} ƒëi·ªÉm`,
confidence: result.confidence, isCertain: false
};
}
}
const certainPrediction = this.findCertainPrediction(currentHistory, allHistoricalSessions);
if (certainPrediction) return certainPrediction;
const allMatches = [];
for (let len = Math.min(this.MAX_PATTERN_LENGTH, currentHistory.length); len >= this.MIN_PATTERN_LENGTH; len--) {
const pattern = currentHistory.slice(-len);
const occurrences = this.findPatternOccurrences(pattern, allHistoricalSessions);
if (occurrences.length > 0) {
allMatches.push(...occurrences);
break;
}
}
if (allMatches.length === 0) return { prediction: null, analysisText: 'Kh√¥ng t√¨m th·∫•y h√¨nh c·∫ßu t∆∞∆°ng t·ª±.', confidence: 0, isCertain: false };
const votes = { P: 0, B: 0 };
allMatches.forEach(match => { if (votes[match.next] !== undefined) votes[match.next] += match.similarity; });
const totalVotes = votes.P + votes.B;
if (totalVotes === 0) return { prediction: null, analysisText: 'Kh√¥ng t√¨m th·∫•y h√¨nh c·∫ßu t∆∞∆°ng t·ª±.', confidence: 0, isCertain: false };
const predictedWinner = votes.P > votes.B ? 'P' : 'B';
const maxConfidence = (Math.max(votes.P, votes.B) / totalVotes) * 100;
const analysisTextPrefix = `T√¨m th·∫•y ${allMatches.length} h√¨nh c·∫ßu t∆∞∆°ng t·ª±. L·ªãch s·ª≠ cho th·∫•y:\n- PLAYER: ${votes.P.toFixed(1)} ƒëi·ªÉm\n- BANKER: ${votes.B.toFixed(1)} ƒëi·ªÉm`;
const streakInfo = this.analyzeCurrentStreak(currentHistory);
let recommendation = 'THEO PH√ÇN T√çCH L·ªäCH S·ª¨';
if (streakInfo.type === 'b·ªát') recommendation = predictedWinner === streakInfo.value ? `THEO B·ªÜT (${streakInfo.value}x${streakInfo.length})` : `B·∫∫ C·∫¶U B·ªÜT (${streakInfo.value}x${streakInfo.length})`;
else if (streakInfo.type === '1-1') recommendation = predictedWinner !== currentHistory[currentHistory.length - 1] ? `THEO C·∫¶U 1-1 (D√†i ${streakInfo.length})` : `B·∫∫ C·∫¶U 1-1 (D√†i ${streakInfo.length})`;
return { prediction: predictedWinner, recommendation, analysisText: `${analysisTextPrefix}\n\nüèÜ ƒê·ªô tin c·∫≠y: ${maxConfidence.toFixed(1)}%`, confidence: maxConfidence, isCertain: false };
}
}
// --- GLOBAL STATE ---
let state = {
currentSessionId: null,
sessions: {},
matcher: new PatternMatcher(),
currentPrediction: null, // Stores { prediction: 'P'/'B', confidence: number } from core matcher
originalSystemPrediction: null, // <<< M·ªöI: L∆∞u tr·ªØ P/B g·ªëc tr∆∞·ªõc khi verdict c√≥ th·ªÉ ƒë·∫£o ng∆∞·ª£c
currentFinalPrediction: null, // Stores { verdict: 'follow'/'against'/'neutral', prediction: 'P'/'B' } after verdict logic
// <<< M·ªöI: L∆∞u tr·ªØ d·ª± ƒëo√°n Ch·ªët cu·ªëi c√πng cho v√°n hi·ªán t·∫°i ƒë·ªÉ ghi log
currentChotPredictionForLog: null,
goldenRange: null,
deathRange: null,
sessionConfidenceRanges: [],
confidenceSequenceData: {}
};
// --- STATS CALCULATION ---
function getPredictionStats(predictions) {
const total = predictions.length;
if (total === 0) return { rate: 0, correct: 0, total: 0 };
const correct = predictions.filter(p => p.predicted === p.actual).length;
return { rate: (correct / total) * 100, correct, total };
}
function calculateConfidenceRangeStats(predictions) {
const ranges = [{min:50,max:60},{min:60,max:70},{min:70,max:80},{min:80,max:90},{min:90,max:100}].map(r => ({...r, total:0, wins:0, rate: -1}));
ranges.forEach(range => {
const predictionsForRange = predictions.filter(p => p.confidence >= range.min && (p.confidence < range.max || (range.max === 100 && p.confidence >= 100)));
range.total = predictionsForRange.length;
range.wins = predictionsForRange.filter(p => p.predicted === p.actual).length;
range.rate = range.total > 0 ? ((range.wins / range.total) * 100) : -1;
});
return ranges;
}
function getConfidenceSequenceData() {
const sequenceData = {};
const rangeDefs = [{min:50,max:60},{min:60,max:70},{min:70,max:80},{min:80,max:90},{min:90,max:100}];
rangeDefs.forEach(r => {
const key = `${r.min}-${r.max}`;
sequenceData[key] = {};
});
for (const sessionId in state.sessions) {
const session = state.sessions[sessionId];
if (!session.predictions || session.predictions.length === 0) continue;
const sessionSequences = {};
rangeDefs.forEach(r => {
const key = `${r.min}-${r.max}`;
sessionSequences[key] = [];
});
session.predictions.forEach(p => {
const result = (p.predicted === p.actual) ? 'W' : 'L';
const foundRange = rangeDefs.find(r => p.confidence >= r.min && (p.confidence < r.max || (r.max === 100 && p.confidence >= 100)));
if (foundRange) {
const key = `${foundRange.min}-${foundRange.max}`;
sessionSequences[key].push(result);
}
});
for (const key in sessionSequences) {
if (sessionSequences[key].length > 0) {
sequenceData[key][sessionId] = sessionSequences[key].join('');
}
}
}
return sequenceData;
}
// --- SELF-VERDICT LOGIC ---
function getCurrentStreak(sequence) {
if (!sequence || sequence.length === 0) return { type: null, length: 0 }; // S·ª≠a: Th√™m check sequence
const lastChar = sequence.slice(-1);
let length = 0;
for (let i = sequence.length - 1; i >= 0; i--) {
if (sequence[i] === lastChar) {
length++;
} else {
break;
}
}
return { type: lastChar, length };
}
function calculateStreakStats(sequencesObject) {
let maxW = 0, maxL = 0;
const allSequences = Object.values(sequencesObject).join('');
if (!allSequences) return { maxW: 0, maxL: 0 };
const winStreaks = allSequences.match(/W+/g) || [];
if (winStreaks.length > 0) {
maxW = Math.max(...winStreaks.map(s => s.length));
}
const lossStreaks = allSequences.match(/L+/g) || [];
if (lossStreaks.length > 0) {
maxL = Math.max(...lossStreaks.map(s => s.length));
}
return { maxW, maxL };
}
function getFinalVerdict(context) {
const { prediction, confidence, sequenceData, currentSessionId } = context;
if (!prediction) {
return { verdict: 'neutral', explanation: 'Ch∆∞a c√≥ ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ ƒë∆∞a ra ph√°n quy·∫øt.' };
}
const rangeDefs = [{min:50,max:60},{min:60,max:70},{min:70,max:80},{min:80,max:90},{min:90,max:100}];
const foundRange = rangeDefs.find(r => confidence >= r.min && (confidence < r.max || (r.max === 100 && confidence >= 100)));
if (!foundRange) {
return { verdict: 'neutral', explanation: 'Ph√°n ƒëo√°n kh√¥ng thu·ªôc kho·∫£ng tin c·∫≠y n√†o.' };
}
const rangeKey = `${foundRange.min}-${foundRange.max}`;
const historicalSequences = { ...sequenceData[rangeKey] };
const currentSequenceStr = historicalSequences[currentSessionId] || "";
delete historicalSequences[currentSessionId];
// --- Tier 1: Longest possible pattern search (Primary) ---
const maxLen = Math.min(currentSequenceStr.length, 5);
for (let len = maxLen; len >= 2; len--) {
const patternToSearch = currentSequenceStr.slice(-len);
let wins = 0, losses = 0;
for (const sessionId in historicalSequences) {
const history = historicalSequences[sessionId];
let i = -1;
while ((i = history.indexOf(patternToSearch, i + 1)) !== -1) {
const nextCharIndex = i + patternToSearch.length;
if (nextCharIndex < history.length) {
if (history[nextCharIndex] === 'W') wins++; else losses++;
}
}
}
if (wins + losses >= 2) {
const patternText = patternToSearch.replace(/W/g, 'Th·∫Øng-').replace(/L/g, 'Thua-').slice(0, -1);
if (wins > losses) return { verdict: 'follow', explanation: `N√™n theo. Quy lu·∫≠t d√†i ${len} v√°n c·ªßa kho·∫£ng n√†y cho th·∫•y sau chu·ªói ${patternText}, k·∫øt qu·∫£ th∆∞·ªùng l√† Th·∫Øng.` };
if (losses > wins) return { verdict: 'against', explanation: `N√™n ƒëi ng∆∞·ª£c l·∫°i. Quy lu·∫≠t d√†i ${len} v√°n c·ªßa kho·∫£ng n√†y cho th·∫•y sau chu·ªói ${patternText}, k·∫øt qu·∫£ th∆∞·ªùng l√† Thua.` };
}
}
// --- Tier 2: Max Streak Analysis (Secondary) ---
const currentStreak = getCurrentStreak(currentSequenceStr);
const streakStats = calculateStreakStats(historicalSequences);
if (currentStreak.type === 'W' && streakStats.maxW > 0 && currentStreak.length >= streakStats.maxW) {
return { verdict: 'against', explanation: `N√™n ƒëi ng∆∞·ª£c l·∫°i. Chu·ªói Th·∫Øng hi·ªán t·∫°i (${currentStreak.length}) ƒë√£ b·∫±ng ho·∫∑c v∆∞·ª£t ng∆∞·ª°ng t·ªëi ƒëa (${streakStats.maxW}) trong l·ªãch s·ª≠ c·ªßa kho·∫£ng n√†y.` };
}
if (currentStreak.type === 'L' && streakStats.maxL > 0 && currentStreak.length >= streakStats.maxL) {
return { verdict: 'follow', explanation: `N√™n theo. Chu·ªói Thua hi·ªán t·∫°i (${currentStreak.length}) ƒë√£ b·∫±ng ho·∫∑c v∆∞·ª£t ng∆∞·ª°ng t·ªëi ƒëa (${streakStats.maxL}) trong l·ªãch s·ª≠ c·ªßa kho·∫£ng n√†y.` };
}
// --- Tier 3: Cross-range "Absolute" pattern (Fallback) ---
const absolutePatternLength = Math.min(currentSequenceStr.length, 3);
if (absolutePatternLength >= 2) {
const patternToSearch = currentSequenceStr.slice(-absolutePatternLength);
let crossWins = 0, crossLosses = 0;
const MIN_ABSOLUTE_OCCURRENCES = 4;
for (const key in sequenceData) {
const otherRangeSequences = sequenceData[key];
for (const sessionId in otherRangeSequences) {
if (sessionId === currentSessionId) continue;
const history = otherRangeSequences[sessionId];
let i = -1;
while ((i = history.indexOf(patternToSearch, i + 1)) !== -1) {
const nextCharIndex = i + patternToSearch.length;
if (nextCharIndex < history.length) {
if (history[nextCharIndex] === 'W') crossWins++;
else crossLosses++;
}
}
}
}
const patternText = patternToSearch.replace(/W/g, 'Th·∫Øng-').replace(/L/g, 'Thua-').slice(0, -1);
if (crossWins + crossLosses >= MIN_ABSOLUTE_OCCURRENCES) {
if (crossWins === 0) return { verdict: 'against', explanation: `N√™n ƒëi ng∆∞·ª£c l·∫°i. Quy lu·∫≠t tuy·ªát ƒë·ªëi (${patternText} -> Thua) ƒë∆∞·ª£c t√¨m th·∫•y tr√™n to√†n b·ªô l·ªãch s·ª≠.` };
if (crossLosses === 0) return { verdict: 'follow', explanation: `N√™n theo. Quy lu·∫≠t tuy·ªát ƒë·ªëi (${patternText} -> Th·∫Øng) ƒë∆∞·ª£c t√¨m th·∫•y tr√™n to√†n b·ªô l·ªãch s·ª≠.` };
}
}
return { verdict: 'neutral', explanation: 'Kh√¥ng t√¨m th·∫•y quy lu·∫≠t bi·ªÉu ƒë·ªì r√µ r√†ng trong l·ªãch s·ª≠.' };
}
// --- UI UPDATE FUNCTIONS ---
function updateBigRoadUI() {
const history = state.sessions[state.currentSessionId]?.history || [];
const roadDiv = document.getElementById('bigRoadDisplay');
document.getElementById('totalGames').textContent = history.length;
if (history.length === 0) {
roadDiv.innerHTML = '<p class="text-gray-500 p-4">Ch∆∞a c√≥ k·∫øt qu·∫£...</p>';
roadDiv.style.display = 'block';
return;
}
roadDiv.style.display = 'grid';
roadDiv.innerHTML = '';
const columns = [];
if (history.length > 0) {
let currentCol = [history[0]];
for (let i = 1; i < history.length; i++) {
if (history[i] === history[i-1]) currentCol.push(history[i]);
else { columns.push(currentCol); currentCol = [history[i]]; }
}
columns.push(currentCol);
}
columns.forEach(colData => {
const colDiv = document.createElement('div');
colDiv.className = 'road-col';
colData.forEach(item => {
const itemDiv = document.createElement('div');
itemDiv.className = `road-item ${item === 'P' ? 'bg-blue-600' : 'bg-red-600'}`;
itemDiv.textContent = item;
colDiv.appendChild(itemDiv);
});
roadDiv.appendChild(colDiv);
});
roadDiv.scrollLeft = roadDiv.scrollWidth;
}
function updateAccuracyUI() {
const predictions = state.sessions[state.currentSessionId]?.predictions || [];
const stats = getPredictionStats(predictions);
document.getElementById('accuracyRate').textContent = `${stats.rate.toFixed(1)}%`;
document.getElementById('correctPredictions').textContent = stats.correct;
document.getElementById('totalPredictions').textContent = stats.total;
}
function updateGlobalAccuracyUI() {
const allPredictions = Object.values(state.sessions).flatMap(s => s.predictions || []);
const stats = getPredictionStats(allPredictions);
document.getElementById('globalAccuracyRate').textContent = `${stats.rate.toFixed(1)}%`;
document.getElementById('globalCorrectPredictions').textContent = stats.correct;
document.getElementById('globalTotalPredictions').textContent = stats.total;
}
function updateAnalysisUI() {
const session = state.sessions[state.currentSessionId] || { history: [], optimalLength: null, lengthPerformance: {} };
const { prediction, recommendation, analysisText, confidence, isCertain } = state.matcher.getPrediction(session.history, Object.values(state.sessions), {
optimalLength: session.optimalLength,
lengthPerformance: session.lengthPerformance
});
// L∆∞u tr·ªØ d·ª± ƒëo√°n g·ªëc P/B v√† ƒë·ªô tin c·∫≠y
state.currentPrediction = { prediction, confidence };
state.originalSystemPrediction = prediction; // <<< M·ªöI: L∆∞u P/B g·ªëc t·∫°i ƒë√¢y
const verdictContext = {
prediction, confidence,
sequenceData: state.confidenceSequenceData,
currentSessionId: state.currentSessionId
};
const finalVerdict = getFinalVerdict(verdictContext);
let finalPredictionForDisplay = prediction; // D·ª± ƒëo√°n hi·ªÉn th·ªã tr√™n UI ch√≠nh
if (finalVerdict.verdict === 'against' && !isCertain) {
finalPredictionForDisplay = prediction === 'P' ? 'B' : 'P';
}
// L∆∞u tr·ªØ ph√°n quy·∫øt cu·ªëi c√πng v√† d·ª± ƒëo√°n P/B cu·ªëi c√πng (sau khi √°p d·ª•ng verdict)
state.currentFinalPrediction = { verdict: finalVerdict.verdict, prediction: finalPredictionForDisplay };
let verdictHTML = `<div class="mt-3 p-3 text-center bg-gray-800 rounded-lg text-sm font-semibold ${
finalVerdict.verdict === 'follow' || isCertain ? 'text-green-300' :
finalVerdict.verdict === 'against' ? 'text-red-300' : 'text-yellow-300'
}"><strong>Ph√°n Quy·∫øt H·ªá Th·ªëng:</strong> ${isCertain ? 'Tay ch·∫Øc ch·∫Øn, lu√¥n ∆∞u ti√™n theo h·ªá th·ªëng.' : finalVerdict.explanation}</div>`;
let recommendationText = recommendation;
if(finalVerdict.verdict === 'against' && !isCertain) {
recommendationText = 'ƒêI NG∆Ø·ª¢C H·ªÜ TH·ªêNG';
}
const analysisResultDiv = document.getElementById('analysisResult'), analysisCard = document.getElementById('analysis-card');
analysisCard.classList.remove('card-glow-p', 'card-glow-b', 'card-glow-certain');
let optimalLengthDisplay = session.optimalLength ? `<div class="mb-4 p-3 bg-gray-900 rounded-lg text-center text-cyan-300 text-sm"><span class="font-semibold">Chi·ªÅu d√†i c·∫ßu t·ªëi ∆∞u:</span><span class="text-lg font-bold ml-2">${session.optimalLength}</span></div>` : '';
if (prediction) { // A prediction was made
let predictionBlockHTML = `
<div class="text-center bg-gray-900 py-6 rounded-lg border-2 ${finalPredictionForDisplay === 'P' ? 'border-blue-500' : 'border-red-500'}">
<p class="text-lg text-gray-400 mb-2">ƒê·ªÅ xu·∫•t theo h·ªá th·ªëng:</p>
<p class="text-3xl font-extrabold ${finalPredictionForDisplay === 'P' ? 'text-blue-400' : 'text-red-400'}">${recommendationText}</p>
<p class="text-4xl font-bold mt-2">${finalPredictionForDisplay === 'P' ? 'üë§ PLAYER' : 'üè¶ BANKER'}</p>
${verdictHTML}
</div>
<div class="bg-gray-700 p-4 rounded-lg mt-4">
<p class="font-semibold text-gray-300">Ph√¢n t√≠ch ban ƒë·∫ßu c·ªßa h·ªá th·ªëng:</p>
<p class="text-gray-400 whitespace-pre-wrap text-sm">${analysisText}</p>
</div>
`;
if (isCertain) {
// ƒê·ªëi v·ªõi 'TAY CH·∫ÆC CH·∫ÆN', d·ª± ƒëo√°n hi·ªÉn th·ªã lu√¥n l√† d·ª± ƒëo√°n g·ªëc
predictionBlockHTML = `
<div class="text-center bg-yellow-800 bg-opacity-50 py-6 rounded-lg border-2 border-yellow-400">
<p class="text-lg text-yellow-300 mb-2 animate-pulse">ƒê·ªÅ Xu·∫•t Ch·∫Øc Ch·∫Øn (L·ªãch s·ª≠):</p>
<p class="text-3xl font-extrabold text-yellow-300">${recommendation}</p>
<p class="text-4xl font-bold mt-2">${prediction === 'P' ? 'üë§ PLAYER' : 'üè¶ BANKER'}</p>
${verdictHTML}
</div>
<div class="bg-gray-700 p-4 rounded-lg mt-4">
<p class="font-semibold text-gray-300">Ph√¢n t√≠ch ban ƒë·∫ßu c·ªßa h·ªá th·ªëng:</p>
<p class="text-gray-400 whitespace-pre-wrap text-sm">${analysisText}</p>
</div>
`;
analysisCard.classList.add('card-glow-certain');
} else {
analysisCard.classList.add(finalPredictionForDisplay === 'P' ? 'card-glow-p' : 'card-glow-b');
}
analysisResultDiv.innerHTML = optimalLengthDisplay + predictionBlockHTML;
} else {
analysisResultDiv.innerHTML = `${optimalLengthDisplay}<p class="text-gray-400 text-center py-8 whitespace-pre-wrap">${analysisText}</p>`;
}
}
function updateConfidenceStatsUI() {
if (!state.currentSessionId || !state.sessions[state.currentSessionId]) return;
const sessionPredictions = state.sessions[state.currentSessionId].predictions || [];
state.sessionConfidenceRanges = calculateConfidenceRangeStats(sessionPredictions);
state.confidenceSequenceData = getConfidenceSequenceData();
const currentConfidence = state.currentPrediction?.confidence;
const previousConfidence = sessionPredictions.length > 0 ? sessionPredictions[sessionPredictions.length - 1].confidence : null;
let bestRange = null, maxRate = -1;
let worstRange = null, minRate = 101;
state.sessionConfidenceRanges.forEach(range => {
if (range.total >= 3 && range.rate > maxRate) {
maxRate = range.rate;
bestRange = range;
}
if (range.total >= 3 && range.rate !== -1 && range.rate < minRate) {
minRate = range.rate;
worstRange = range;
}
const predictionsForRange = sessionPredictions.filter(p => p.confidence >= range.min && (p.confidence < range.max || (p.confidence >= 100 && range.max === 100)));
let trendIndicator = '', streak = 0;
if (predictionsForRange.length >= 1) {
const lastWin = (predictionsForRange.slice(-1)[0].predicted === predictionsForRange.slice(-1)[0].actual);
for (let i = predictionsForRange.length - 1; i >= 0; i--) {
if ((predictionsForRange[i].predicted === predictionsForRange[i].actual) === lastWin) streak++; else break;
}
if(streak >= 1) trendIndicator = `<span class="flex items-center ${lastWin ? 'text-green-400' : 'text-red-400'} ml-1.5">${lastWin ? '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z" clip-rule="evenodd"></path></svg>' : '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>'}<span class="font-bold text-xs">${streak}</span></span>`;
}
range.trendIndicator = trendIndicator;
});
state.goldenRange = bestRange;
state.deathRange = worstRange;
const recommendationDiv = document.getElementById('confidenceRecommendation');
let recommendationHTML = '';
if (bestRange) {
recommendationHTML += `<p class="text-sm text-yellow-300"><span class="font-bold">‚ú® Kho·∫£ng V√†ng:</span> T·ª∑ l·ªá th·∫Øng cao nh·∫•t l√† <b class="text-green-400">${maxRate.toFixed(1)}%</b> trong kho·∫£ng <b class="text-white">${bestRange.min}%-${bestRange.max}%</b>.</p>`;
}
if (worstRange) {
recommendationHTML += `<p class="text-sm text-yellow-300 mt-1"><span class="font-bold">üíÄ Kho·∫£ng T·ª≠ Th·∫ßn:</span> T·ª∑ l·ªá th·∫Øng th·∫•p nh·∫•t l√† <b class="text-red-400">${minRate.toFixed(1)}%</b> trong kho·∫£ng <b class="text-white">${worstRange.min}%-${worstRange.max}%</b>.</p>`;
}
if (!bestRange && !worstRange) {
recommendationDiv.innerHTML = `<p class="text-sm text-gray-400">Ch∆∞a ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ t√¨m kho·∫£ng v√†ng/t·ª≠ th·∫ßn (c·∫ßn t·ªëi thi·ªÉu 3 ph√°n ƒëo√°n trong 1 kho·∫£ng).</p>`;
} else {
recommendationDiv.innerHTML = recommendationHTML;
}
const tableDiv = document.getElementById('confidenceStatsTable');
let html = `<div class="grid gap-x-2 text-xs font-semibold text-gray-400 px-3" style="grid-template-columns: 2fr 4fr 2fr 2fr 3fr;"><span>Kho·∫£ng</span><span class="text-center">Di·ªÖn Bi·∫øn G·∫ßn ƒê√¢y</span><span class="text-center">T·ªïng</span><span class="text-center">Th·∫Øng</span><span class="text-right">T·ª∑ L·ªá</span></div>`;
if (sessionPredictions.length === 0 && !currentConfidence) {
tableDiv.innerHTML = '<p class="text-gray-500 text-center py-4">Ch∆∞a c√≥ d·ªØ li·ªáu th·ªëng k√™.</p>';
} else {
state.sessionConfidenceRanges.forEach(range => {
let highlightClass = 'bg-gray-700 bg-opacity-50';
if (range === bestRange) {
highlightClass = 'bg-green-800 bg-opacity-40 border border-green-500';
} else if (range === worstRange) {
highlightClass = 'bg-red-800 bg-opacity-40 border border-red-500';
}
let indicatorsHTML = '';
if (currentConfidence && state.currentFinalPrediction?.prediction && currentConfidence >= range.min && (currentConfidence < range.max || (currentConfidence >= 100 && range.max === 100))) {
const finalPrediction = state.currentFinalPrediction.prediction;
const sideText = finalPrediction === 'P' ? 'PLAYER' : 'BANKER';
const sideColor = finalPrediction === 'P' ? 'bg-blue-600' : 'bg-red-600';
indicatorsHTML += `<span class="ml-2 px-1.5 py-0.5 text-xs rounded font-semibold ${sideColor} text-white" title="ƒê·ªÅ xu·∫•t v√°n hi·ªán t·∫°i">${sideText}</span>`;
}
if (previousConfidence && previousConfidence >= range.min && (previousConfidence < range.max || (previousConfidence >= 100 && range.max === 100))) {
const marginLeft = indicatorsHTML ? 'ml-1' : 'ml-2';
indicatorsHTML += `<span class="${marginLeft} px-1.5 py-0.5 text-xs rounded font-semibold bg-gray-500 text-white" title="Ph√°n ƒëo√°n v√°n tr∆∞·ªõc">Tr∆∞·ªõc</span>`;
}
const predictionsForRange = sessionPredictions.filter(p => p.confidence >= range.min && (p.confidence < range.max || (p.confidence >= 100 && range.max === 100)));
const displayedPredictions = predictionsForRange.slice(-30);
let individualBarsHTML = `<div class="flex items-end justify-center gap-px h-5 my-auto overflow-hidden" title="Hi·ªÉn th·ªã t·ªëi ƒëa 30 v√°n g·∫ßn nh·∫•t">`;
if (displayedPredictions.length > 0) {
for (const p of displayedPredictions) {
const isWin = p.predicted === p.actual;
const barClass = isWin ? 'bg-green-500 h-5' : 'bg-red-500 h-2';
const title = `ƒê·ªÅ xu·∫•t: ${p.predicted}, Ra: ${p.actual} -> ${isWin ? 'TH·∫ÆNG' : 'THUA'}\nƒê·ªô tin c·∫≠y: ${p.confidence.toFixed(1)}%`;
individualBarsHTML += `<div class="flex-shrink-0 w-1 ${barClass} rounded-t-sm" title="${title}"></div>`;
}
} else {
individualBarsHTML += `<div class="w-full text-center"><span class="text-gray-600 text-xs">Ch∆∞a c√≥</span></div>`;
}
individualBarsHTML += '</div>';
html += `<div class="grid gap-x-2 items-center ${highlightClass} p-3 rounded-lg mt-2 text-sm" style="grid-template-columns: 2fr 4fr 2fr 2fr 3fr;">
<span class="font-medium text-gray-300">${range.min}%-${range.max}%</span>
${individualBarsHTML}
<span class="text-white font-semibold text-center">${range.total}</span>
<span class="text-green-400 font-semibold text-center">${range.wins}</span>
<span class="font-bold flex items-center justify-end ${range.rate >= 70 ? 'text-green-400' : (range.rate >= 50 ? 'text-yellow-400' : 'text-red-400')}">
${range.rate > -1 ? range.rate.toFixed(1) + '%' : '-'}${range.trendIndicator}${indicatorsHTML}
</span></div>`;
});
tableDiv.innerHTML = html;
}
}
function updateVerdictStatsUI() {
if (!state.currentSessionId || !state.sessions[state.currentSessionId]) return;
const verdictPredictions = state.sessions[state.currentSessionId].verdictPredictions || [];
const tableDiv = document.getElementById('verdictStatsTable');
const stats = {
follow: { total: 0, wins: 0, predictions: [] },
against: { total: 0, wins: 0, predictions: [] }
};
verdictPredictions.forEach(p => {
if (p.verdict === 'follow') {
stats.follow.total++;
stats.follow.predictions.push(p);
if (p.predicted === p.actual) stats.follow.wins++;
} else if (p.verdict === 'against') {
stats.against.total++;
stats.against.predictions.push(p);
if (p.predicted === p.actual) stats.against.wins++;
}
});
let html = `<div class="grid gap-x-2 text-xs font-semibold text-gray-400 px-3" style="grid-template-columns: 2fr 4fr 2fr 2fr 3fr;"><span>Ph√°n Quy·∫øt</span><span class="text-center">Di·ªÖn Bi·∫øn G·∫ßn ƒê√¢y</span><span class="text-center">T·ªïng</span><span class="text-center">Th·∫Øng</span><span class="text-right">T·ª∑ L·ªá</span></div>`;
if (verdictPredictions.length === 0) {
tableDiv.innerHTML = '<p class="text-gray-500 text-center py-4">Ch∆∞a c√≥ d·ªØ li·ªáu ph√°n quy·∫øt.</p>';
return;
}
const createRowHTML = (label, data) => {
const rate = data.total > 0 ? (data.wins / data.total) * 100 : -1;
const displayedPredictions = data.predictions.slice(-30);
let individualBarsHTML = `<div class="flex items-end justify-center gap-px h-5 my-auto overflow-hidden" title="Hi·ªÉn th·ªã t·ªëi ƒëa 30 v√°n g·∫ßn nh·∫•t">`;
if (displayedPredictions.length > 0) {
displayedPredictions.forEach(p => {
const isWin = p.predicted === p.actual;
const barClass = isWin ? 'bg-green-500 h-5' : 'bg-red-500 h-2';
const title = `ƒê·ªÅ xu·∫•t: ${p.predicted}, Ra: ${p.actual} -> ${isWin ? 'TH·∫ÆNG' : 'THUA'}`;
individualBarsHTML += `<div class="flex-shrink-0 w-1 ${barClass} rounded-t-sm" title="${title}"></div>`;
});
} else {
individualBarsHTML += `<div class="w-full text-center"><span class="text-gray-600 text-xs">Ch∆∞a c√≥</span></div>`;
}
individualBarsHTML += '</div>';
return `
<div class="grid gap-x-2 items-center bg-gray-700 bg-opacity-50 p-3 rounded-lg mt-2 text-sm" style="grid-template-columns: 2fr 4fr 2fr 2fr 3fr;">
<span class="font-medium text-gray-300">${label}</span>
${individualBarsHTML}
<span class="text-white font-semibold text-center">${data.total}</span>
<span class="text-green-400 font-semibold text-center">${data.wins}</span>
<span class="font-bold text-right ${rate >= 70 ? 'text-green-400' : (rate >= 50 ? 'text-yellow-400' : 'text-red-400')}">
${rate > -1 ? rate.toFixed(1) + '%' : '-'}
</span>
</div>
`;
};
html += createRowHTML('Theo H·ªá Th·ªëng', stats.follow);
html += createRowHTML('Ng∆∞·ª£c H·ªá Th·ªëng', stats.against);
tableDiv.innerHTML = html;
}
function updateAllUI() {
updateBigRoadUI();
updateAccuracyUI();
updateGlobalAccuracyUI();
updateAnalysisUI(); // T√≠nh to√°n Ph√°n quy·∫øt HT v√† l∆∞u P/B g·ªëc
updateConfidenceStatsUI();
updateVerdictStatsUI();
updateChotAnalysisUI(); // T√≠nh to√°n Ch·ªët d·ª±a tr√™n k·∫øt qu·∫£ Ph√°n quy·∫øt HT
}
function toggleSessionManagement() {
const content = document.getElementById('sessionManagementContent');
const icon = document.getElementById('toggleSessionIcon');
if (content.style.maxHeight && content.style.maxHeight !== '0px') {
content.style.maxHeight = '0px';
icon.style.transform = 'rotate(-180deg)';
} else {
content.style.maxHeight = content.scrollHeight + 'px';
icon.style.transform = 'rotate(0deg)';
}
}
// --- START: M√É M·ªöI CHO PH√ÇN T√çCH "CH·ªêT" ---
/**
* Thu th·∫≠p t·∫•t c·∫£ c√°c chu·ªói W/L l·ªãch s·ª≠ t·ª´ 7 ngu·ªìn d·ªØ li·ªáu.
*/
function getChotAnalysisData() {
const sequencesBySource = {
follow: {}, against: {},
'90-100': {}, '80-90': {}, '70-80': {}, '60-70': {}, '50-60': {}
};
const rangeDefs = [
{ key: '50-60', min: 50, max: 60 },
{ key: '60-70', min: 60, max: 70 },
{ key: '70-80', min: 70, max: 80 },
{ key: '80-90', min: 80, max: 90 },
{ key: '90-100', min: 90, max: 100.1 } // S·ª≠a: 100.1 ƒë·ªÉ bao g·ªìm 100
];
for (const sessionId in state.sessions) {
const session = state.sessions[sessionId];
let followSeq = '', againstSeq = '';
(session.verdictPredictions || []).forEach(p => {
const result = p.predicted === p.actual ? 'W' : 'L';
if (p.verdict === 'follow') followSeq += result;
else if (p.verdict === 'against') againstSeq += result;
});
sequencesBySource.follow[sessionId] = followSeq;
sequencesBySource.against[sessionId] = againstSeq;
const sessionConfSequences = { '90-100': '', '80-90': '', '70-80': '', '60-70': '', '50-60': '' };
(session.predictions || []).forEach(p => {
const result = p.predicted === p.actual ? 'W' : 'L';
const foundRange = rangeDefs.find(r => p.confidence >= r.min && p.confidence < r.max);
if (foundRange) {
sessionConfSequences[foundRange.key] += result;
}
});
for (const key in sessionConfSequences) {
sequencesBySource[key][sessionId] = sessionConfSequences[key];
}
}
return sequencesBySource;
}
/**
* T√¨m ki·∫øm m·ªôt pattern trong l·ªãch s·ª≠ v√† ƒë·∫øm k·∫øt qu·∫£ ti·∫øp theo (W/L).
*/
function findNextOutcomeInHistory(pattern, historicalSequences) {
if (!pattern || pattern.length < 3) return { W: 0, L: 0, total: 0 };
let W = 0, L = 0;
for (const sessionId in historicalSequences) {
const history = historicalSequences[sessionId];
if (!history) continue;
let i = -1;
while ((i = history.indexOf(pattern, i + 1)) !== -1) {
const nextCharIndex = i + pattern.length;
if (nextCharIndex < history.length) {
if (history[nextCharIndex] === 'W') W++;
else L++;
}
}
}
return { W, L, total: W + L };
}
/**
* M·ªöI: T√¨m ƒë·ªô d√†i pattern (3-10) t·ªët nh·∫•t cho Ch·ªët d·ª±a tr√™n l·ªãch s·ª≠ W/L.
* @param {string} currentSequence - Chu·ªói W/L hi·ªán t·∫°i c·ªßa ngu·ªìn.
* @param {Object} historicalSequences - L·ªãch s·ª≠ W/L c·ªßa ngu·ªìn t·ª´ c√°c phi√™n kh√°c.
* @param {number} minLen - ƒê·ªô d√†i t·ªëi thi·ªÉu (3).
* @param {number} maxLen - ƒê·ªô d√†i t·ªëi ƒëa (10).
* @param {number} minOccurrences - S·ªë l·∫ßn xu·∫•t hi·ªán t·ªëi thi·ªÉu (2).
* @returns {Object|null} - Th√¥ng tin v·ªÅ ƒë·ªô d√†i t·ªët nh·∫•t { length, stats: {W, L, total}, rate } ho·∫∑c null.
*/
function findBestChotPatternLength(currentSequence, historicalSequences, minLen = 3, maxLen = 10, minOccurrences = 2) {
const possibleResults = [];
// Duy·ªát t·ª´ d√†i xu·ªëng ng·∫Øn
for (let len = Math.min(maxLen, currentSequence.length); len >= minLen; len--) {
const pattern = currentSequence.slice(-len);
if (!pattern) continue; // B·ªè qua n·∫øu kh√¥ng c·∫Øt ƒë∆∞·ª£c pattern
const stats = findNextOutcomeInHistory(pattern, historicalSequences);
if (stats.total >= minOccurrences) {
const rate = stats.W / stats.total;
possibleResults.push({ length: len, stats: stats, rate: rate });
}
}
if (possibleResults.length === 0) {
return null; // Kh√¥ng t√¨m th·∫•y ƒë·ªô d√†i n√†o ƒë·ªß ƒëi·ªÅu ki·ªán
}
// S·∫Øp x·∫øp: ∆∞u ti√™n t·ª∑ l·ªá th·∫Øng/thua l·ªách nh·∫•t (g·∫ßn 1 ho·∫∑c 0 nh·∫•t), sau ƒë√≥ ƒë·∫øn t·ªïng s·ªë l·∫ßn xu·∫•t hi·ªán
possibleResults.sort((a, b) => {
const deviationA = Math.abs(a.rate - 0.5); // ƒê·ªô l·ªách so v·ªõi 50%
const deviationB = Math.abs(b.rate - 0.5);
if (deviationA !== deviationB) {
return deviationB - deviationA; // ∆Øu ti√™n ƒë·ªô l·ªách l·ªõn h∆°n
}
return b.stats.total - a.stats.total; // N·∫øu ƒë·ªô l·ªách b·∫±ng nhau, ∆∞u ti√™n t·ªïng s·ªë l·∫ßn xu·∫•t hi·ªán cao h∆°n
});
return possibleResults[0]; // Tr·∫£ v·ªÅ k·∫øt qu·∫£ t·ªët nh·∫•t
}
/**
* M·ªöI: Ph√¢n t√≠ch chu·ªói t·ªëi ƒëa (Max Streak) cho m·ªôt ngu·ªìn d·ªØ li·ªáu.
* @param {string} currentSequence - Chu·ªói W/L hi·ªán t·∫°i c·ªßa ngu·ªìn.
* @param {Object} historicalSequences - L·ªãch s·ª≠ W/L c·ªßa ngu·ªìn t·ª´ c√°c phi√™n kh√°c.
* @returns {Object|null} - D·ª± ƒëo√°n W/L d·ª±a tr√™n max streak: { prediction: 'W'|'L', explanation: string } ho·∫∑c null.
*/
function analyzeMaxStreak(currentSequence, historicalSequences) {
const currentStreak = getCurrentStreak(currentSequence);
if (currentStreak.length < 2) {
return null; // Chu·ªói hi·ªán t·∫°i qu√° ng·∫Øn ƒë·ªÉ ph√¢n t√≠ch
}
const streakStats = calculateStreakStats(historicalSequences);
if (currentStreak.type === 'W') {
if (streakStats.maxW > 0 && currentStreak.length >= streakStats.maxW) {
// ƒê√£ ƒë·∫°t ho·∫∑c v∆∞·ª£t max W -> d·ª± ƒëo√°n L
return { prediction: 'L', explanation: `Chu·ªói Th·∫Øng (x${currentStreak.length}) ƒë√£ ch·∫°m/v∆∞·ª£t max l·ªãch s·ª≠ (x${streakStats.maxW})` };
}
} else if (currentStreak.type === 'L') {
if (streakStats.maxL > 0 && currentStreak.length >= streakStats.maxL) {
// ƒê√£ ƒë·∫°t ho·∫∑c v∆∞·ª£t max L -> d·ª± ƒëo√°n W
return { prediction: 'W', explanation: `Chu·ªói Thua (x${currentStreak.length}) ƒë√£ ch·∫°m/v∆∞·ª£t max l·ªãch s·ª≠ (x${streakStats.maxL})` };
}
}
return null; // Ch∆∞a ƒë·∫°t ng∆∞·ª°ng max streak
}
/**
* M·ªöI: T·∫°o HTML cho m·ªôt h√†ng trong b·∫£ng ph√¢n t√≠ch chi ti·∫øt Ch·ªët.
* C·∫≠p nh·∫≠t ƒë·ªÉ hi·ªÉn th·ªã c·∫£ logic Max Streak v√† Pattern.
*/
function getChotRowHTML(name, currentSequence, analysisResult, isActive, finalPBprediction) {
const { predictionType, predictedWL, explanation, stats, optimalLength } = analysisResult;
let wlPredictionText = '-';
let wlPredictionColor = 'text-gray-500';
let analysisTypeDisplay = '-'; // Hi·ªÉn th·ªã lo·∫°i ph√¢n t√≠ch (Max Streak / Pattern)
// ∆Øu ti√™n hi·ªÉn th·ªã gi·∫£i th√≠ch t·ª´ Max Streak n·∫øu c√≥
if (predictionType === 'MAX_STREAK') {
analysisTypeDisplay = `Max (W${stats.maxW}/L${stats.maxL})`; // Hi·ªÉn th·ªã Max W/L
wlPredictionText = `-> ${predictedWL} (${explanation})`;
wlPredictionColor = predictedWL === 'W' ? 'text-green-400' : 'text-red-400';
} else if (predictionType === 'PATTERN') {
// Logic hi·ªÉn th·ªã c·ªßa Pattern nh∆∞ c≈©
const wRate = (stats.W / stats.total) * 100;
const lRate = (stats.L / stats.total) * 100;
analysisTypeDisplay = `Pattern (d√†i ${optimalLength})`;
wlPredictionText = `-> ${predictedWL} (${Math.max(wRate, lRate).toFixed(0)}%)`;
wlPredictionColor = predictedWL === 'W' ? 'text-green-400' : 'text-red-400';
} else if (predictionType === 'BALANCED') {
analysisTypeDisplay = `Pattern (d√†i ${optimalLength})`;
wlPredictionText = 'C√¢n b·∫±ng';
wlPredictionColor = 'text-yellow-400';
} else if (predictionType === 'NOT_ENOUGH_SAMPLES') {
analysisTypeDisplay = `Pattern (d√†i ${optimalLength})`;
wlPredictionText = '√çt m·∫´u';
wlPredictionColor = 'text-gray-500';
} else if (predictionType === 'NO_HISTORY_PATTERN') {
analysisTypeDisplay = '-';
wlPredictionText = 'Ko m·∫´u LS';
wlPredictionColor = 'text-gray-600';
} else if (predictionType === 'NOT_ENOUGH_WL') {
analysisTypeDisplay = '-';
wlPredictionText = 'Ch·ªù W/L';
wlPredictionColor = 'text-gray-600';
}
let pbIndicator = '';
if (isActive && finalPBprediction) {
const pbColor = finalPBprediction === 'P' ? 'text-blue-400' : 'text-red-400';
pbIndicator = `<span class="font-bold ${pbColor} ml-1">[${finalPBprediction}]</span>`;
}
const activeClass = isActive ? 'bg-gray-700 bg-opacity-60 ring-1 ring-purple-500' : 'bg-gray-900';
const displayedHistory = currentSequence.slice(-30);
let individualBarsHTML = `<div class="flex items-end justify-center gap-px h-5 my-auto overflow-hidden" title="Di·ªÖn bi·∫øn W/L g·∫ßn ƒë√¢y (T·ªëi ƒëa 30)">`;
if (displayedHistory.length > 0) {
for (const result of displayedHistory) {
const isWin = result === 'W';
const barClass = isWin ? 'bg-green-500 h-5' : 'bg-red-500 h-2';
const title = `K·∫øt qu·∫£: ${isWin ? 'TH·∫ÆNG' : 'THUA'}`;
individualBarsHTML += `<div class="flex-shrink-0 w-1 ${barClass} rounded-t-sm" title="${title}"></div>`;
}
} else {
individualBarsHTML += `<div class="w-full text-center"><span class="text-gray-600 text-xs">Ch∆∞a c√≥</span></div>`;
}
individualBarsHTML += '</div>';
// C·∫≠p nh·∫≠t grid-cols-12 v√† col-span
return `
<div class="grid grid-cols-12 gap-2 items-center text-xs mb-1 p-1.5 ${activeClass} rounded-lg transition-colors duration-300">
<div class="col-span-2 font-semibold ${isActive ? 'text-purple-300' : 'text-gray-300'} truncate" title="${name}">${name}</div>
<div class="col-span-3 text-center text-gray-400" title="Lo·∫°i ph√¢n t√≠ch (Max Streak / Pattern)">${analysisTypeDisplay}</div>
<div class="col-span-3">
${individualBarsHTML}
</div>
<div class="col-span-4 text-right font-bold ${wlPredictionColor} truncate" title="${wlPredictionText}">
${wlPredictionText}
${pbIndicator}
</div>
</div>
`;
}
/**
* M·ªöI: H√†m quy·∫øt ƒë·ªãnh ch√≠nh cho Ch·ªët, k·∫øt h·ª£p Max Streak v√† Pattern.
* @param {string} currentSequence - Chu·ªói W/L hi·ªán t·∫°i.
* @param {Object} historicalSequences - L·ªãch s·ª≠ W/L t·ª´ c√°c phi√™n kh√°c.
* @returns {Object} - K·∫øt qu·∫£ ph√¢n t√≠ch { predictionType, predictedWL, explanation, stats, optimalLength }
*/
function getChotPrediction(currentSequence, historicalSequences) {
const MIN_PATTERN_LEN = 3;
const MAX_PATTERN_LEN = 10;
const MIN_PATTERN_OCCURRENCES = 2;
// --- B∆Ø·ªöC 1: ∆ØU TI√äN PH√ÇN T√çCH MAX STREAK ---
const maxStreakResult = analyzeMaxStreak(currentSequence, historicalSequences);
if (maxStreakResult) {
const streakStats = calculateStreakStats(historicalSequences);
return {
predictionType: 'MAX_STREAK', // Lo·∫°i ph√¢n t√≠ch
predictedWL: maxStreakResult.prediction, // 'W' ho·∫∑c 'L'
explanation: maxStreakResult.explanation, // Gi·∫£i th√≠ch l√Ω do
stats: streakStats, // G·ª≠i stats (maxW, maxL) ƒë·ªÉ hi·ªÉn th·ªã
optimalLength: null // Kh√¥ng √°p d·ª•ng cho max streak
};
}
// --- B∆Ø·ªöC 2: N·∫æU KH√îNG C√ì MAX STREAK, D√ôNG PH√ÇN T√çCH PATTERN (NH∆Ø C≈®) ---
if (currentSequence.length < MIN_PATTERN_LEN) {
return { predictionType: 'NOT_ENOUGH_WL' }; // Ch∆∞a ƒë·ªß W/L
}
const bestPatternInfo = findBestChotPatternLength(
currentSequence,
historicalSequences,
MIN_PATTERN_LEN,
MAX_PATTERN_LEN,
MIN_PATTERN_OCCURRENCES
);
if (!bestPatternInfo) {
return { predictionType: 'NO_HISTORY_PATTERN' }; // Kh√¥ng t√¨m th·∫•y pattern n√†o trong LS
}
const { length, stats, rate } = bestPatternInfo;
if (stats.W > stats.L) {
return { predictionType: 'PATTERN', predictedWL: 'W', stats: stats, optimalLength: length };
} else if (stats.L > stats.W) {
return { predictionType: 'PATTERN', predictedWL: 'L', stats: stats, optimalLength: length };
} else if (stats.total > 0) { // W == L
return { predictionType: 'BALANCED', stats: stats, optimalLength: length };
} else {
// Tr∆∞·ªùng h·ª£p n√†y kh√¥ng n√™n x·∫£y ra n·∫øu bestPatternInfo tr·∫£ v·ªÅ ƒë√∫ng
return { predictionType: 'NOT_ENOUGH_SAMPLES', stats: stats, optimalLength: length };
}
}
/**
* C·∫≠p nh·∫≠t to√†n b·ªô giao di·ªán cho b·∫£ng ph√¢n t√≠ch "CH·ªêT" - S·ª≠ d·ª•ng logic k·∫øt h·ª£p.
*/
function updateChotAnalysisUI() {
const MAX_BARS_TO_SHOW = 50;
const finalChotResultDiv = document.getElementById('finalChotResult');
const chotAnalysisDetailsDiv = document.getElementById('chotAnalysisDetails');
const chotHistoryChartDiv = document.getElementById('chotHistoryChart');
const chotAccuracyStatsSpan = document.getElementById('chotAccuracyStats');
if (!finalChotResultDiv || !chotAnalysisDetailsDiv || !chotHistoryChartDiv || !chotAccuracyStatsSpan) return;
// --- B∆∞·ªõc 1: X√°c ƒë·ªãnh ngu·ªìn ho·∫°t ƒë·ªông v√† P/B g·ªëc ---
const activeSourcesKeys = new Set();
const originalSystemPB = state.originalSystemPrediction;
const currentConfidence = state.currentPrediction?.confidence;
const finalVerdictInfo = state.currentFinalPrediction;
state.currentChotPredictionForLog = null; // Reset tr∆∞·ªõc khi t√≠nh
let analysisRowsHTML = ''; // HTML cho c√°c h√†ng chi ti·∫øt
const finalVotesPB = { P: 0, B: 0 };
if (originalSystemPB && finalVerdictInfo !== null) {
// X√°c ƒë·ªãnh ngu·ªìn ho·∫°t ƒë·ªông
if (finalVerdictInfo.verdict === 'follow') activeSourcesKeys.add('follow');
else if (finalVerdictInfo.verdict === 'against') activeSourcesKeys.add('against');
const rangeDefs = [
{ key: '50-60', min: 50, max: 60 }, { key: '60-70', min: 60, max: 70 },
{ key: '70-80', min: 70, max: 80 }, { key: '80-90', min: 80, max: 90 },
{ key: '90-100', min: 90, max: 100.1 } // S·ª≠a: 100.1
];
const activeConfidenceRange = rangeDefs.find(r => currentConfidence >= r.min && currentConfidence < r.max);
if (activeConfidenceRange) activeSourcesKeys.add(activeConfidenceRange.key);
// --- T√≠nh to√°n d·ª± ƒëo√°n Ch·ªët v√† t·∫°o HTML chi ti·∫øt ---
const allSequences = getChotAnalysisData();
const currentSessionId = state.currentSessionId;
const sources = [
{ key: 'follow', name: 'Theo HT' }, { key: 'against', name: 'Ng∆∞·ª£c HT' },
{ key: '90-100', name: '90-100%' }, { key: '80-90', name: '80-90%' },
{ key: '70-80', name: '70-80%' }, { key: '60-70', name: '60-70%' },
{ key: '50-60', name: '50-60%' }
];
if (currentSessionId) {
for (const source of sources) {
const isActive = activeSourcesKeys.has(source.key);
const currentSequence = allSequences[source.key][currentSessionId] || "";
const historicalData = { ...allSequences[source.key] };
delete historicalData[currentSessionId];
// *** THAY ƒê·ªîI: S·ª≠ d·ª•ng h√†m quy·∫øt ƒë·ªãnh k·∫øt h·ª£p m·ªõi ***
const analysisResult = getChotPrediction(currentSequence, historicalData);
let finalPBprediction = null;
if (analysisResult.predictedWL && isActive) {
// Ch·ªâ b·ªè phi·∫øu n·∫øu ngu·ªìn ƒëang ho·∫°t ƒë·ªông v√† c√≥ d·ª± ƒëo√°n W/L
const predictedWL = analysisResult.predictedWL;
finalPBprediction = (predictedWL === 'W') ? originalSystemPB : (originalSystemPB === 'P' ? 'B' : 'P');
if (finalPBprediction) {
finalVotesPB[finalPBprediction]++;
}
}
// T·∫°o HTML cho h√†ng n√†y
analysisRowsHTML += getChotRowHTML(source.name, currentSequence, analysisResult, isActive, finalPBprediction);
}
}
// Hi·ªÉn th·ªã c√°c h√†ng ph√¢n t√≠ch chi ti·∫øt
chotAnalysisDetailsDiv.innerHTML = analysisRowsHTML || '<p class="text-gray-500 text-center py-4">Ch∆∞a ƒë·ªß d·ªØ li·ªáu W/L ƒë·ªÉ ph√¢n t√≠ch Ch·ªët...</p>';
} else {
// Tr∆∞·ªùng h·ª£p kh√¥ng ƒë·ªß d·ªØ li·ªáu t·ª´ h·ªá th·ªëng ch√≠nh
state.currentChotPredictionForLog = null;
chotAnalysisDetailsDiv.innerHTML = '<p class="text-gray-500 text-center py-4">Ch·ªù t√≠n hi·ªáu t·ª´ Ph√°n Quy·∫øt H·ªá Th·ªëng...</p>';
}
// --- X√°c ƒë·ªãnh v√† hi·ªÉn th·ªã k·∫øt qu·∫£ Ch·ªët cu·ªëi c√πng ---
let finalChotPredictionText = '... Ch·ªù t√≠n hi·ªáu ...';
let finalChotPredictionColor = 'text-gray-400';
let finalChotBorderColor = 'border-purple-500';
let finalChotPB = null;
const totalVotes = finalVotesPB.P + finalVotesPB.B;
if (totalVotes > 0) {
if (finalVotesPB.P > finalVotesPB.B) {
finalChotPB = 'P';
finalChotPredictionText = `PLAYER ( ${finalVotesPB.P} / ${totalVotes} phi·∫øu )`;
finalChotPredictionColor = 'text-blue-400';
finalChotBorderColor = 'border-blue-500';
} else if (finalVotesPB.B > finalVotesPB.P) {
finalChotPB = 'B';
finalChotPredictionText = `BANKER ( ${finalVotesPB.B} / ${totalVotes} phi·∫øu )`;
finalChotPredictionColor = 'text-red-400';
finalChotBorderColor = 'border-red-500';
} else {
finalChotPredictionText = `H√íA PHI·∫æU (${finalVotesPB.P} - ${finalVotesPB.B})`;
finalChotPredictionColor = 'text-yellow-400';
finalChotBorderColor = 'border-yellow-500';
}
} else if (originalSystemPB && finalVerdictInfo !== null) { // Ch·ªâ hi·ªÉn th·ªã "Ko ƒë·ªß t√≠n hi·ªáu" n·∫øu HT ch√≠nh ƒë√£ ch·∫°y
finalChotPredictionText = 'Kh√¥ng ƒë·ªß t√≠n hi·ªáu b·ªè phi·∫øu';
}
// L∆∞u d·ª± ƒëo√°n Ch·ªët cu·ªëi c√πng
state.currentChotPredictionForLog = finalChotPB;
// C·∫≠p nh·∫≠t UI ph·∫ßn d·ª± ƒëo√°n Ch·ªët
finalChotResultDiv.className = `text-center bg-gray-900 py-4 rounded-lg border-2 ${finalChotBorderColor} mb-4 transition-all duration-300`;
finalChotResultDiv.innerHTML = `
<p class="text-sm text-gray-400 mb-1">ƒê·ªÅ xu·∫•t "CH·ªêT" v√°n ti·∫øp theo:</p>
<p class="text-2xl font-extrabold ${finalChotPredictionColor}">${finalChotPredictionText}</p>
`;
// --- V·∫Ω bi·ªÉu ƒë·ªì l·ªãch s·ª≠ Ch·ªët ---
const session = state.currentSessionId ? state.sessions[state.currentSessionId] : null;
const chotHistory = session?.chotPredictions || [];
let correctChot = 0;
const totalChot = chotHistory.length;
let barsHTML = '';
const historyToShow = chotHistory.slice(-MAX_BARS_TO_SHOW);
if (historyToShow.length > 0) {
historyToShow.forEach(p => {
const isCorrect = p.predicted === p.actual;
if (isCorrect) correctChot++;
const barClass = isCorrect ? 'chot-bar-correct' : 'chot-bar-incorrect';
const title = `Ch·ªët: ${p.predicted}, Ra: ${p.actual} -> ${isCorrect ? 'ƒê√∫ng' : 'Sai'}`;
barsHTML += `<div class="chot-bar ${barClass}" title="${title}"></div>`;
});
chotHistoryChartDiv.innerHTML = barsHTML;
} else {
chotHistoryChartDiv.innerHTML = '<p class="text-gray-600 text-xs text-center w-full">Ch∆∞a c√≥ d·ªØ li·ªáu l·ªãch s·ª≠ Ch·ªët...</p>';
}
const accuracyRate = totalChot > 0 ? (correctChot / totalChot * 100).toFixed(1) : '0.0';
chotAccuracyStatsSpan.textContent = `ƒê√∫ng: ${correctChot}/${totalChot} (${accuracyRate}%)`;
}
// --- END: M√É M·ªöI CHO PH√ÇN T√çCH "CH·ªêT" ---
// --- EVENT HANDLERS & ACTIONS ---
function addResult(result) {
if (!state.currentSessionId) return;
const session = state.sessions[state.currentSessionId];
// *** L·∫•y d·ª± ƒëo√°n Ch·ªët ƒê√É ƒê∆Ø·ª¢C T√çNH TO√ÅN tr∆∞·ªõc ƒë√≥ cho v√°n N√ÄY ***
const chotPredictionForThisRound = state.currentChotPredictionForLog;
// --- Ph·∫ßn x·ª≠ l√Ω prediction h·ªá th·ªëng (gi·ªØ nguy√™n) ---
if (state.currentPrediction && state.currentPrediction.prediction) {
session.predictions.push({ predicted: state.currentPrediction.prediction, actual: result, confidence: state.currentPrediction.confidence });
}
// --- Ph·∫ßn x·ª≠ l√Ω verdict (gi·ªØ nguy√™n) ---
if (!session.verdictPredictions) session.verdictPredictions = [];
if (state.currentFinalPrediction && state.currentFinalPrediction.prediction) {
session.verdictPredictions.push({
verdict: state.currentFinalPrediction.verdict,
predicted: state.currentFinalPrediction.prediction,
actual: result
});
}
// *** M·ªöI: Ghi log cho Ch·ªët Ph√°n Quy·∫øt ***
if (!session.chotPredictions) session.chotPredictions = [];
// Ch·ªâ ghi log n·∫øu c√≥ d·ª± ƒëo√°n Ch·ªët cho v√°n n√†y
if (chotPredictionForThisRound) {
session.chotPredictions.push({
predicted: chotPredictionForThisRound, // D·ª± ƒëo√°n ƒë√£ ƒë∆∞·ª£c l∆∞u tr∆∞·ªõc ƒë√≥
actual: result
});
}
// --- Ph·∫ßn x·ª≠ l√Ω history v√† optimal length (gi·ªØ nguy√™n) ---
session.history.push(result);
const newOptimalLength = updateLengthPerformanceAndFindOptimal([...session.history].slice(0, -1), Object.values(state.sessions), result);
session.optimalLength = newOptimalLength;
// Reset c√°c state d·ª± ƒëo√°n cho v√°n ti·∫øp theo
state.currentPrediction = null;
state.originalSystemPrediction = null;
state.currentFinalPrediction = null;
state.currentChotPredictionForLog = null; // Reset d·ª± ƒëo√°n Ch·ªët cho log
saveSessions();
updateAllUI(); // C·∫≠p nh·∫≠t UI s·∫Ω t·ª± ƒë·ªông t√≠nh to√°n l·∫°i Ch·ªët cho v√°n *ti·∫øp theo*
}
function updateLengthPerformanceAndFindOptimal(history, allSessions, newResult) {
const session = state.sessions[state.currentSessionId];
if (!session) return null;
if (!session.lengthPerformance) session.lengthPerformance = {};
const candidates = [];
for (let len = 10; len <= 20; len++) {
if (history.length < len) continue;
const pattern = history.slice(-len);
const { prediction } = state.matcher.getPredictionForPattern(pattern, allSessions);
if (prediction) {
if (!session.lengthPerformance[len]) session.lengthPerformance[len] = { wins: 0, total: 0 };
const stats = session.lengthPerformance[len];
stats.total++;
if (prediction === newResult) stats.wins++;
candidates.push({ length: len, rate: stats.wins / stats.total, total: stats.total });
}
}
if (candidates.length === 0) return session.optimalLength;
candidates.sort((a, b) => b.rate !== a.rate ? b.rate - a.rate : b.total - a.total);
return candidates[0].length;
}
function undoLast() {
if (!state.currentSessionId || state.sessions[state.currentSessionId].history.length === 0) return;
const session = state.sessions[state.currentSessionId];
// --- Ho√†n t√°c c√°c d·ª± ƒëo√°n kh√°c ---
const lastResult = session.history[session.history.length - 1];
const historyForUndo = session.history.slice(0, -1);
const tempSessions = JSON.parse(JSON.stringify(state.sessions));
tempSessions[state.currentSessionId].history.pop();
const allSessionsForContext = Object.values(tempSessions);
// Ho√†n t√°c lengthPerformance (gi·ªØ nguy√™n)
if (session.lengthPerformance) {
for (let len = 10; len <= 20; len++) {
if (historyForUndo.length < len) continue;
const pattern = historyForUndo.slice(-len);
const { prediction } = state.matcher.getPredictionForPattern(pattern, allSessionsForContext);
if (prediction) {
const stats = session.lengthPerformance[len];
if (stats && stats.total > 0) {
stats.total--;
if (prediction === lastResult && stats.wins > 0) {
stats.wins--;
}
}
}
}
}
// T√≠nh l·∫°i optimalLength (gi·ªØ nguy√™n)
const candidates = [];
if (session.lengthPerformance) {
for (const len in session.lengthPerformance) {
const stats = session.lengthPerformance[len];
if (stats.total > 0) {
candidates.push({ length: parseInt(len, 10), rate: stats.wins / stats.total, total: stats.total });
}
}
}
if (candidates.length > 0) {
candidates.sort((a, b) => b.rate !== a.rate ? b.rate - a.rate : b.total - a.total);
session.optimalLength = candidates[0].length;
} else {
session.optimalLength = null;
}
// Pop history v√† c√°c predictions kh√°c
session.history.pop();
if (session.predictions.length > 0) {
session.predictions.pop();
}
if (session.verdictPredictions && session.verdictPredictions.length > 0) {
session.verdictPredictions.pop();
}
// *** M·ªöI: Ho√†n t√°c Ch·ªët Prediction ***
if (session.chotPredictions && session.chotPredictions.length > 0) {
session.chotPredictions.pop();
}
saveSessions();
updateAllUI();
}
function clearCurrentSessionHistory() {
if (!state.currentSessionId) return;
const session = state.sessions[state.currentSessionId];
session.history = [];
session.predictions = [];
session.verdictPredictions = [];
session.chotPredictions = []; // *** M·ªöI: Reset Ch·ªët Predictions ***
session.lengthPerformance = {};
session.optimalLength = null;
saveSessions();
updateAllUI();
}
// --- SESSION MANAGEMENT ---
function getSessions() { try { return JSON.parse(localStorage.getItem('baccaratPatternSessions_v11_sim')) || {}; } catch (e) { return {}; }}
function saveSessions() { localStorage.setItem('baccaratPatternSessions_v11_sim', JSON.stringify(state.sessions)); localStorage.setItem('lastActiveSession_v11_sim', state.currentSessionId); }
function renameSession() {
if (!state.currentSessionId) return;
const currentName = state.sessions[state.currentSessionId].name;
showCustomPrompt("Nh·∫≠p t√™n m·ªõi cho phi√™n:", currentName, (newName) => {
if (newName && newName.trim() !== "") {
state.sessions[state.currentSessionId].name = newName.trim();
saveSessions();
updateSessionSelector();
}
});
}
function updateSessionSelector() {
const selector = document.getElementById('sessionSelector');
selector.innerHTML = '';
const sortedKeys = Object.keys(state.sessions).sort((a, b) => {
const timeA = parseInt(a.split('-')[1] || 0);
const timeB = parseInt(b.split('-')[1] || 0);
return timeA - timeB;
});
sortedKeys.reverse().forEach(sessionId => {
const option = document.createElement('option');
option.value = sessionId;
option.textContent = `${state.sessions[sessionId].name} (${state.sessions[sessionId].history.length} v√°n)`;
if (sessionId === state.currentSessionId) {
option.selected = true;
}
selector.appendChild(option);
});
selector.onclick = () => {
if(selector.selectedOptions.length === 1) {
if(selector.value !== state.currentSessionId) {
loadSession(selector.value);
}
}
};
}
function createNewSession() {
const newId = `session-${Date.now()}`;
state.currentSessionId = newId;
state.sessions[newId] = {
name: `Phi√™n ${new Date().toLocaleString('vi-VN')}`,
history: [], predictions: [], verdictPredictions: [], chotPredictions: [], // *** M·ªöI: Kh·ªüi t·∫°o Ch·ªët Predictions ***
lengthPerformance: {}, optimalLength: null,
};
saveSessions();
updateSessionSelector();
updateAllUI();
}
function deleteSelectedSessions() {
const selector = document.getElementById('sessionSelector');
const selectedIds = Array.from(selector.selectedOptions).map(opt => opt.value);
if (selectedIds.length === 0) {
showToast('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt phi√™n ƒë·ªÉ x√≥a.', 'warning');
return;
}
if (selectedIds.length === Object.keys(state.sessions).length && Object.keys(state.sessions).length > 0) {
showToast('Kh√¥ng th·ªÉ x√≥a t·∫•t c·∫£ c√°c phi√™n. H√£y d√πng n√∫t "X√≥a T·∫•t C·∫£".', 'error');
return;
}
showCustomConfirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a ${selectedIds.length} phi√™n ƒë√£ ch·ªçn kh√¥ng?`, () => {
let wasCurrentSessionDeleted = false;
selectedIds.forEach(id => {
if (id === state.currentSessionId) {
wasCurrentSessionDeleted = true;
}
delete state.sessions[id];
});
if (wasCurrentSessionDeleted) {
state.currentSessionId = null;
localStorage.removeItem('lastActiveSession_v11_sim');
}
saveSessions();
initializeApp();
showToast(`ƒê√£ x√≥a ${selectedIds.length} phi√™n.`, 'success');
});
}
function deleteAllSessions() {
showCustomConfirm('B·∫†N C√ì CH·∫ÆC MU·ªêN X√ìA T·∫§T C·∫¢ C√ÅC PHI√äN KH√îNG? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.', () => {
state.sessions = {};
state.currentSessionId = null;
localStorage.removeItem('baccaratPatternSessions_v11_sim');
localStorage.removeItem('lastActiveSession_v11_sim');
initializeApp();
showToast('T·∫•t c·∫£ c√°c phi√™n ƒë√£ ƒë∆∞·ª£c x√≥a.', 'success');
});
}
function loadSession(sessionId) {
if (state.sessions[sessionId]) {
state.currentSessionId = sessionId;
state.currentPrediction = null;
state.originalSystemPrediction = null;
state.currentFinalPrediction = null;
state.currentChotPredictionForLog = null; // Reset khi load
localStorage.setItem('lastActiveSession_v11_sim', state.currentSessionId);
updateSessionSelector();
updateAllUI();
}
}
// --- IMPORT / EXPORT & RECALCULATION ---
// Adjusted runSimulation to remove simulation logic and recalculate from history
/**
* S·ª≠a ƒë·ªïi: H√†m n√†y kh√¥ng c√≤n "m√¥ ph·ªèng" m√† l√† "t√°i t√≠nh to√°n" (re-calculate).
* N√≥ s·∫Ω x√¢y d·ª±ng l·∫°i to√†n b·ªô tr·∫°ng th√°i (predictions, verdicts, chot, v.v.)
* t·ª´ m·ªôt file ch·ªâ ch·ª©a 'name' v√† 'history'.
*/
function runSimulation(importedSessions) {
state.sessions = {}; // X√≥a state hi·ªán t·∫°i
state.currentSessionId = null;
localStorage.removeItem('baccaratPatternSessions_v11_sim');
localStorage.removeItem('lastActiveSession_v11_sim');
// S·∫Øp x·∫øp c√°c phi√™n theo th·ªùi gian (d·ª±a tr√™n ID) ƒë·ªÉ x·ª≠ l√Ω theo th·ª© t·ª±
const sortedSessionIds = Object.keys(importedSessions).sort((a, b) => {
const timeA = parseInt(a.split('-')[1] || 0);
const timeB = parseInt(b.split('-')[1] || 0);
return timeA - timeB;
});
sortedSessionIds.forEach((sessionId, index) => {
const importedSession = importedSessions[sessionId];
// Ch·ªâ ki·ªÉm tra 'name' v√† 'history'
if (!importedSession || !importedSession.name || !Array.isArray(importedSession.history)) {
console.warn(`Skipping invalid imported session (name or history missing/invalid): ${sessionId}`);
return;
}
const newId = sessionId; // Gi·ªØ ID c≈© ƒë·ªÉ duy tr√¨ t√≠nh nh·∫•t qu√°n
// T·∫°o phi√™n m·ªõi, tr·ªëng r·ªóng trong state
state.sessions[newId] = {
name: importedSession.name,
history: [], // B·∫Øt ƒë·∫ßu v·ªõi history tr·ªëng
predictions: [], // Tr·ªëng
verdictPredictions: [], // Tr·ªëng
chotPredictions: [], // Tr·ªëng
lengthPerformance: {},
optimalLength: null,
};
// X·ª≠ l√Ω l·∫°i t·ª´ng k·∫øt qu·∫£ trong l·ªãch s·ª≠
importedSession.history.forEach((result, resultIndex) => {
state.currentSessionId = newId; // ƒê·∫∑t context phi√™n hi·ªán t·∫°i
if (result === 'P' || result === 'B') {
// 1. T√≠nh to√°n d·ª± ƒëo√°n (HT, Verdict, Ch·ªët) cho v√°n N√ÄY (d·ª±a tr√™n history 0 -> N-1)
// updateAnalysisUI() -> updateConfidenceStatsUI() -> updateVerdictStatsUI() -> updateChotAnalysisUI()
// C·∫ßn g·ªçi updateAllUI nh∆∞ng ch·ªâ c√°c ph·∫ßn li√™n quan ƒë·∫øn t√≠nh to√°n d·ª± ƒëo√°n
updateAnalysisUI();
updateConfidenceStatsUI();
updateVerdictStatsUI();
updateChotAnalysisUI(); // Quan tr·ªçng: T√≠nh Ch·ªët cho v√°n N√ÄY
// 2. Th√™m k·∫øt qu·∫£ (result)
// addResult s·∫Ω l∆∞u c√°c d·ª± ƒëo√°n ƒë√£ t√≠nh ·ªü b∆∞·ªõc 1 v√†o log v√† th√™m 'result' v√†o history
addResult(result);
} else {
console.warn(`Skipping invalid result '${result}' at index ${resultIndex} in session ${sessionId}`);
}
});
// addResult ƒë√£ saveSessions()
});
// T·∫£i phi√™n cu·ªëi c√πng ho·∫∑c t·∫°o m·ªõi n·∫øu file tr·ªëng/l·ªói
if (Object.keys(state.sessions).length > 0) {
// T·∫£i phi√™n cu·ªëi c√πng ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω
const lastProcessedId = Object.keys(state.sessions)
.sort((a, b) => parseInt(a.split('-')[1] || 0) - parseInt(b.split('-')[1] || 0))
.pop();
loadSession(lastProcessedId);
} else {
console.warn("Imported file was empty or contained no valid sessions. Creating a new session.");
createNewSession();
}
updateSessionSelector(); // C·∫≠p nh·∫≠t selector v·ªõi c√°c phi√™n ƒë√£ x·ª≠ l√Ω
updateAllUI(); // C·∫≠p nh·∫≠t UI l·∫ßn cu·ªëi d·ª±a tr√™n phi√™n ƒë√£ t·∫£i
}
// Adjusted importData to work without simulation fields
function importData(event) {
const file = event.target.files[0];
if (!file) return;
const reader = new FileReader();
reader.onload = function(e) {
try {
const importedSessions = JSON.parse(e.target.result);
if (typeof importedSessions !== 'object' || importedSessions === null) throw new Error("Invalid format: Not an object");
let dataOk = true;
// Check basic structure: name and history array must exist
for(const key in importedSessions) {
const s = importedSessions[key];
if(!s.name || !Array.isArray(s.history)) {
console.error(`Invalid data for session ${key}: Missing name or history is not an array.`);
dataOk = false;
break;
};
}
if (!dataOk && Object.keys(importedSessions).length > 0) {
throw new Error("Invalid session data: name or history format incorrect in one or more sessions.");
}
// S·ª≠a ƒë·ªïi th√¥ng b√°o x√°c nh·∫≠n
showCustomConfirm('D·ªØ li·ªáu hi·ªán t·∫°i s·∫Ω b·ªã ghi ƒë√® (ch·ªâ nh·∫≠p l·ªãch s·ª≠). Qu√° tr√¨nh n√†y s·∫Ω T√çNH TO√ÅN L·∫†I t·∫•t c·∫£ d·ª± ƒëo√°n. B·∫°n c√≥ ch·∫Øc mu·ªën ti·∫øp t·ª•c?', () => {
showLoadingModal('ƒêang nh·∫≠p l·ªãch s·ª≠ v√† t√≠nh to√°n l·∫°i...');
setTimeout(() => { // Cho ph√©p UI hi·ªÉn th·ªã modal
try {
runSimulation(importedSessions); // runSimulation gi·ªù l√† re-calculator
hideLoadingModal();
showToast('Nh·∫≠p l·ªãch s·ª≠ v√† t√≠nh to√°n l·∫°i th√†nh c√¥ng!', 'success');
} catch (simError) {
hideLoadingModal();
showToast('L·ªói trong qu√° tr√¨nh t√≠nh to√°n l·∫°i d·ªØ li·ªáu.', 'error');
console.error("Calculation error during import:", simError);
initializeApp(); // Reload initial state on error
}
}, 100); // 100ms delay
});
} catch (error) {
hideLoadingModal(); // ƒê·∫£m b·∫£o ·∫©n modal n·∫øu parse l·ªói
showToast(`L·ªói: File d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá ho·∫∑c l·ªói ƒë·ªçc file. (${error.message})`, 'error');
console.error("Import error:", error);
} finally {
event.target.value = ''; // Clear file input regardless of outcome
}
};
reader.onerror = function() {
hideLoadingModal(); // ƒê·∫£m b·∫£o ·∫©n modal n·∫øu ƒë·ªçc l·ªói
showToast('L·ªói ƒë·ªçc file.', 'error');
event.target.value = '';
};
reader.readAsText(file);
}
// Adjusted exportData to only export history and name
function exportData() {
if (!state.sessions || Object.keys(state.sessions).length === 0) {
showToast('Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t.', 'warning');
return;
}
// Create object with only name and history
const sessionsToExport = {};
for(const sessionId in state.sessions) {
sessionsToExport[sessionId] = {
name: state.sessions[sessionId].name,
history: state.sessions[sessionId].history
};
}
const dataToExport = JSON.stringify(sessionsToExport, null, 2);
const blob = new Blob([dataToExport], { type: 'application/json' });
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
// const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, ''); // D√íNG C≈®
// a.download = `BaccaratAnalysis_HistoryOnly_${timestamp}.json`; // D√íNG C≈®

// --- THAY ƒê·ªîI ---
const now = new Date();
const day = String(now.getDate()).padStart(2, '0');
const month = String(now.getMonth() + 1).padStart(2, '0'); // getMonth() tr·∫£ v·ªÅ t·ª´ 0-11, n√™n c·∫ßn +1
const year = now.getFullYear();
const filename = `L·ªäCH S·ª¨ NG√ÄY ${day} TH√ÅNG ${month} NƒÇM ${year}.json`;
a.download = filename;
// --- K·∫æT TH√öC THAY ƒê·ªîI ---

document.body.appendChild(a);
a.click();
document.body.removeChild(a);
URL.revokeObjectURL(url);
showToast('L·ªãch s·ª≠ c√°c phi√™n ƒë√£ ƒë∆∞·ª£c xu·∫•t (ch·ªâ g·ªìm history)!', 'success'); // Updated message
}
// --- CUSTOM UI COMPONENTS (MODAL, TOAST, PROMPT) ---
function showToast(message, type = 'info') {
const container = document.getElementById('toast-container');
const toast = document.createElement('div');
const colors = {
success: 'border-green-500', info: 'border-blue-500',
warning: 'border-yellow-500', error: 'border-red-500'
};
toast.className = `toast-notification ${colors[type]}`;
toast.textContent = message;
container.appendChild(toast);
setTimeout(() => {
toast.style.animation = 'fadeOut 0.5s ease';
setTimeout(() => toast.remove(), 500);
}, 3000);
}
function showLoadingModal(message) {
const container = document.getElementById('modal-container');
container.innerHTML = `
<div id="loading-modal" class="modal-backdrop">
<div class="modal-content text-center">
<p class="text-lg text-gray-200">${message}</p>
<div class="mt-4">
<svg class="animate-spin h-8 w-8 text-white mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
<circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
<path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
</svg>
</div>
</div>
</div>`;
}
function hideLoadingModal() {
const modal = document.getElementById('loading-modal');
if (modal) {
modal.style.animation = 'fadeOut 0.3s ease';
setTimeout(() => {
document.getElementById('modal-container').innerHTML = '';
}, 300);
} else {
document.getElementById('modal-container').innerHTML = '';
}
}
function showCustomConfirm(message, onConfirm) {
const container = document.getElementById('modal-container');
const modalHTML = `
<div id="custom-confirm" class="modal-backdrop">
<div class="modal-content">
<p class="text-lg text-gray-200 mb-6">${message}</p>
<div class="flex justify-end gap-4">
<button id="confirm-cancel" class="btn bg-gray-600 hover:bg-gray-500 px-6 py-2 rounded-lg">H·ªßy</button>
<button id="confirm-ok" class="btn bg-red-600 hover:bg-red-500 px-6 py-2 rounded-lg">X√°c nh·∫≠n</button>
</div>
</div>
</div>
`;
container.innerHTML = modalHTML;
const modalElement = document.getElementById('custom-confirm');
document.getElementById('confirm-ok').onclick = () => {
onConfirm();
modalElement.style.animation = 'fadeOut 0.3s ease';
setTimeout(() => { container.innerHTML = ''; }, 300);
};
document.getElementById('confirm-cancel').onclick = () => {
modalElement.style.animation = 'fadeOut 0.3s ease';
setTimeout(() => { container.innerHTML = ''; }, 300);
};
}
function showCustomPrompt(message, defaultValue, onConfirm) {
const container = document.getElementById('modal-container');
const modalHTML = `
<div id="custom-prompt" class="modal-backdrop">
<div class="modal-content">
<p class="text-lg text-gray-200 mb-4">${message}</p>
<input type="text" id="prompt-input" value="${defaultValue}" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none mb-6">
<div class="flex justify-end gap-4">
<button id="prompt-cancel" class="btn bg-gray-600 hover:bg-gray-500 px-6 py-2 rounded-lg">H·ªßy</button>
<button id="prompt-ok" class="btn bg-blue-600 hover:bg-blue-500 px-6 py-2 rounded-lg">L∆∞u</button>
</div>
</div>
</div>
`;
container.innerHTML = modalHTML;
const modalElement = document.getElementById('custom-prompt');
const input = document.getElementById('prompt-input');
input.focus();
input.select();
const closePrompt = (value) => {
modalElement.style.animation = 'fadeOut 0.3s ease';
setTimeout(() => {
container.innerHTML = '';
if (value !== null) {
onConfirm(value);
}
}, 300);
};
document.getElementById('prompt-ok').onclick = () => { closePrompt(input.value); };
document.getElementById('prompt-cancel').onclick = () => { closePrompt(null); };
input.onkeydown = (e) => { if (e.key === 'Enter') document.getElementById('prompt-ok').click(); };
}
function initializeApp() {
state.sessions = getSessions();
Object.values(state.sessions).forEach(s => {
if (!s.lengthPerformance) s.lengthPerformance = {};
if (s.optimalLength === undefined) s.optimalLength = null;
if (!s.verdictPredictions) s.verdictPredictions = [];
if (!s.chotPredictions) s.chotPredictions = []; // *** M·ªöI: ƒê·∫£m b·∫£o chotPredictions t·ªìn t·∫°i ***
// Remove simulation property if it exists from older versions
delete s.simulation;
});
const lastActiveId = localStorage.getItem('lastActiveSession_v11_sim');
if (Object.keys(state.sessions).length === 0) {
createNewSession();
} else {
const sortedKeys = Object.keys(state.sessions).sort((a, b) => parseInt(a.split('-')[1]) - parseInt(b.split('-')[1]));
const idToLoad = (lastActiveId && state.sessions[lastActiveId]) ? lastActiveId : sortedKeys[sortedKeys.length - 1];
state.currentSessionId = idToLoad;
loadSession(idToLoad);
}
const sessionContent = document.getElementById('sessionManagementContent');
sessionContent.style.maxHeight = '0px'; // Start collapsed
document.getElementById('toggleSessionIcon').style.transform = 'rotate(-180deg)'; // Match collapsed state
}
// --- INITIALIZATION ---
document.addEventListener('DOMContentLoaded', initializeApp)
</script>
</body>
</html>


